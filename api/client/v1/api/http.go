// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ErrorCode.
const (
	ABORTED            ErrorCode = "ABORTED"
	ALREADYEXISTS      ErrorCode = "ALREADY_EXISTS"
	BADGATEWAY         ErrorCode = "BAD_GATEWAY"
	CANCELLED          ErrorCode = "CANCELLED"
	CONFLICT           ErrorCode = "CONFLICT"
	DATALOSS           ErrorCode = "DATA_LOSS"
	DEADLINEEXCEEDED   ErrorCode = "DEADLINE_EXCEEDED"
	FAILEDPRECONDITION ErrorCode = "FAILED_PRECONDITION"
	INTERNAL           ErrorCode = "INTERNAL"
	INVALIDARGUMENT    ErrorCode = "INVALID_ARGUMENT"
	METHODNOTALLOWED   ErrorCode = "METHOD_NOT_ALLOWED"
	NOTFOUND           ErrorCode = "NOT_FOUND"
	OK                 ErrorCode = "OK"
	OUTOFRANGE         ErrorCode = "OUT_OF_RANGE"
	PERMISSIONDENIED   ErrorCode = "PERMISSION_DENIED"
	RESOURCEEXHAUSTED  ErrorCode = "RESOURCE_EXHAUSTED"
	UNAUTHENTICATED    ErrorCode = "UNAUTHENTICATED"
	UNAVAILABLE        ErrorCode = "UNAVAILABLE"
	UNIMPLEMENTED      ErrorCode = "UNIMPLEMENTED"
	UNKNOWN            ErrorCode = "UNKNOWN"
)

// Defines values for GetAccessTokenRequestGrantType.
const (
	CLIENTCREDENTIALS GetAccessTokenRequestGrantType = "CLIENT_CREDENTIALS"
	REFRESHTOKEN      GetAccessTokenRequestGrantType = "REFRESH_TOKEN"
)

// Defines values for QueryTimeSeriesMetricsRequestFunction.
const (
	COUNT QueryTimeSeriesMetricsRequestFunction = "COUNT"
	NONE  QueryTimeSeriesMetricsRequestFunction = "NONE"
	RATE  QueryTimeSeriesMetricsRequestFunction = "RATE"
)

// Defines values for QueryTimeSeriesMetricsRequestSpaceAggregation.
const (
	AVG QueryTimeSeriesMetricsRequestSpaceAggregation = "AVG"
	MAX QueryTimeSeriesMetricsRequestSpaceAggregation = "MAX"
	MIN QueryTimeSeriesMetricsRequestSpaceAggregation = "MIN"
	SUM QueryTimeSeriesMetricsRequestSpaceAggregation = "SUM"
)

// Defines values for QueryTimeSeriesMetricsRequestTigrisOperation.
const (
	ALL   QueryTimeSeriesMetricsRequestTigrisOperation = "ALL"
	READ  QueryTimeSeriesMetricsRequestTigrisOperation = "READ"
	WRITE QueryTimeSeriesMetricsRequestTigrisOperation = "WRITE"
)

// Defines values for RollupFunctionAggregator.
const (
	ROLLUPAGGREGATORAVG   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_AVG"
	ROLLUPAGGREGATORCOUNT RollupFunctionAggregator = "ROLLUP_AGGREGATOR_COUNT"
	ROLLUPAGGREGATORMAX   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_MAX"
	ROLLUPAGGREGATORMIN   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_MIN"
	ROLLUPAGGREGATORSUM   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_SUM"
)

// Additional function to apply on metrics query
type AdditionalFunction struct {
	// Rollup function aggregates the slices of metrics returned by original query and lets you operate on the slices using aggregator and constructs the bigger slice of your choice of interval (specified in seconds).
	Rollup *RollupFunction `json:"rollup,omitempty"`
}

// An user application
type Application struct {
	// Created at
	CreatedAt *int64 `json:"created_at,omitempty"`

	// Created by
	CreatedBy *string `json:"created_by,omitempty"`

	// A human readable app description
	Description *string `json:"description,omitempty"`

	// Generated client id
	Id *string `json:"id,omitempty"`

	// A human readable app name
	Name *string `json:"name,omitempty"`

	// Generated app secret
	Secret *string `json:"secret,omitempty"`

	// Updated at
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// Updated by
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// Start new transaction in database specified by "db".
type BeginTransactionRequest struct {
	// Options that can be used to modify the transaction semantics.
	Options *TransactionOptions `json:"options,omitempty"`
}

// Start transaction returns transaction context  which uniquely identifies the transaction
type BeginTransactionResponse struct {
	// Contains ID which uniquely identifies transaction This context is returned by BeginTransaction request and should be passed in the metadata (headers) of subsequent requests in order to run them in the context of the same transaction.
	TxCtx *TransactionCtx `json:"tx_ctx,omitempty"`
}

// A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
type Collation struct {
	Case *string `json:"case,omitempty"`
}

// CollectionDescription defines model for CollectionDescription.
type CollectionDescription struct {
	// Name of the collection.
	Collection *string             `json:"collection,omitempty"`
	Metadata   *CollectionMetadata `json:"metadata,omitempty"`

	// Collections schema
	Schema json.RawMessage `json:"schema,omitempty"`

	// Collection size in bytes
	Size *int64 `json:"size,omitempty"`
}

// CollectionInfo defines model for CollectionInfo.
type CollectionInfo struct {
	// Collection name.
	Collection *string             `json:"collection,omitempty"`
	Metadata   *CollectionMetadata `json:"metadata,omitempty"`
}

// CollectionMetadata defines model for CollectionMetadata.
type CollectionMetadata = map[string]interface{}

// Collection requests modifying options.
type CollectionOptions = map[string]interface{}

// Commit transaction with the given ID
type CommitTransactionRequest = map[string]interface{}

// CommitTransactionResponse defines model for CommitTransactionResponse.
type CommitTransactionResponse struct {
	// Status of commit transaction operation.
	Status *string `json:"status,omitempty"`
}

// Request creation of user application
type CreateApplicationRequest struct {
	// A human readable app description
	Description *string `json:"description,omitempty"`

	// A human readable app name
	Name *string `json:"name,omitempty"`
}

// CreateApplication returns created application
type CreateApplicationResponse struct {
	// An user application
	CreatedApplication *Application `json:"created_application,omitempty"`
}

// CreateDatabaseRequest defines model for CreateDatabaseRequest.
type CreateDatabaseRequest struct {
	// Database requests modifying options.
	Options *DatabaseOptions `json:"options,omitempty"`
}

// CreateDatabaseResponse defines model for CreateDatabaseResponse.
type CreateDatabaseResponse struct {
	// A detailed response message.
	Message *string `json:"message,omitempty"`

	// An enum with value set as "created".
	Status *string `json:"status,omitempty"`
}

// CreateNamespaceRequest defines model for CreateNamespaceRequest.
type CreateNamespaceRequest struct {
	// A unique namespace id.
	Id *int32 `json:"id,omitempty"`
}

// CreateNamespaceResponse defines model for CreateNamespaceResponse.
type CreateNamespaceResponse struct {
	// A detailed response message.
	Message *string `json:"message,omitempty"`

	// An enum with value set as "created".
	Status *string `json:"status,omitempty"`
}

// CreateOrUpdateCollectionRequest defines model for CreateOrUpdateCollectionRequest.
type CreateOrUpdateCollectionRequest struct {
	// If set to true then the update schema request to the collection will fail by returning a conflict with HTTP Status code 409. The default is false.
	OnlyCreate *bool `json:"only_create,omitempty"`

	// Collection requests modifying options.
	Options *CollectionOptions `json:"options,omitempty"`

	// Schema of the documents in this collection. The schema specifications are same as JSON schema specification defined <a href="https://json-schema.org/specification.html" title="here">here</a>. <p></p>The following is an schema example: `{  "title": "user",  "description": "Collection of documents with details of users",  "properties": {    "id": {      "description": "A unique identifier for the user",      "type": "integer"    },    "name": {      "description": "Name of the user",      "type": "string",      "maxLength": 100    },    "balance": {      "description": "User account balance",      "type": "number"    }  },  "primary_key": ["id"] }`
	Schema json.RawMessage `json:"schema,omitempty"`
}

// CreateOrUpdateCollectionResponse defines model for CreateOrUpdateCollectionResponse.
type CreateOrUpdateCollectionResponse struct {
	// A detailed response message.
	Message *string `json:"message,omitempty"`

	// An enum with value set as "created" or "updated"
	Status *string `json:"status,omitempty"`
}

// Represents the data point in timeseries.
type DataPoint struct {
	Timestamp *int64   `json:"timestamp,omitempty"`
	Value     *float64 `json:"value,omitempty"`
}

// DatabaseInfo defines model for DatabaseInfo.
type DatabaseInfo struct {
	// Database name.
	Db       *string           `json:"db,omitempty"`
	Metadata *DatabaseMetadata `json:"metadata,omitempty"`
}

// DatabaseMetadata defines model for DatabaseMetadata.
type DatabaseMetadata = map[string]interface{}

// Database requests modifying options.
type DatabaseOptions = map[string]interface{}

// DeleteApplication returns the flag to convey if application was deleted
type DeleteApplicationResponse struct {
	// status flag for delete operation
	Deleted *bool `json:"deleted,omitempty"`
}

// Request deletion of an application
type DeleteApplicationsRequest struct {
	// application id
	Id *string `json:"id,omitempty"`
}

// DeleteRequest defines model for DeleteRequest.
type DeleteRequest struct {
	// Delete documents which matching specified filter. A filter can simply be key, value where key is the field name and value would be the value for this field. Or a filter can be logical where two or more fields can be logically joined using $or and $and. A few examples of filter: <li> To delete a user document where the id has a value 1: ```{"id": 1 }``` <li> To delete all the user documents where the key "id" has a value 1 or 2 or 3: `{"$or": [{"id": 1}, {"id": 2}, {"id": 3}]}`
	Filter json.RawMessage `json:"filter,omitempty"`

	// Additional options for deleted requests.
	Options *DeleteRequestOptions `json:"options,omitempty"`
}

// Additional options for deleted requests.
type DeleteRequestOptions struct {
	// A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// DeleteResponse defines model for DeleteResponse.
type DeleteResponse struct {
	// Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// an enum with value set as "deleted"
	Status *string `json:"status,omitempty"`
}

// DescribeCollectionRequest defines model for DescribeCollectionRequest.
type DescribeCollectionRequest struct {
	// Name of the collection.
	Collection *string `json:"collection,omitempty"`

	// Name of the database.
	Db *string `json:"db,omitempty"`

	// Collection requests modifying options.
	Options *CollectionOptions `json:"options,omitempty"`
}

// A detailed description of the collection. The description returns collection metadata and the schema.
type DescribeCollectionResponse struct {
	// Name of the collection.
	Collection *string             `json:"collection,omitempty"`
	Metadata   *CollectionMetadata `json:"metadata,omitempty"`

	// Schema of this collection.
	Schema json.RawMessage `json:"schema,omitempty"`

	// The size of this collection in bytes.
	Size *int64 `json:"size,omitempty"`
}

// DescribeDatabaseRequest defines model for DescribeDatabaseRequest.
type DescribeDatabaseRequest struct {
	// Name of the database.
	Db *string `json:"db,omitempty"`
}

// A detailed description of the database and all the associated collections. Description of the collection includes schema details as well.
type DescribeDatabaseResponse struct {
	// A detailed description about all the collections. The description returns collection metadata and the schema.
	Collections *[]CollectionDescription `json:"collections,omitempty"`

	// Name of the database.
	Db       *string           `json:"db,omitempty"`
	Metadata *DatabaseMetadata `json:"metadata,omitempty"`

	// Sum of all the collections sizes present in this database
	Size *int64 `json:"size,omitempty"`
}

// DropCollectionRequest defines model for DropCollectionRequest.
type DropCollectionRequest struct {
	// Collection requests modifying options.
	Options *CollectionOptions `json:"options,omitempty"`
}

// DropCollectionResponse defines model for DropCollectionResponse.
type DropCollectionResponse struct {
	// A detailed response message.
	Message *string `json:"message,omitempty"`

	// An enum with value set as "dropped".
	Status *string `json:"status,omitempty"`
}

// DropDatabaseRequest defines model for DropDatabaseRequest.
type DropDatabaseRequest struct {
	// Database requests modifying options.
	Options *DatabaseOptions `json:"options,omitempty"`
}

// DropDatabaseResponse defines model for DropDatabaseResponse.
type DropDatabaseResponse struct {
	// A detailed response message.
	Message *string `json:"message,omitempty"`

	// An enum with value set as "dropped".
	Status *string `json:"status,omitempty"`
}

// The Error type defines a logical error model
type Error struct {
	// The status code is a short, machine parsable string, which uniquely identifies the error type. Tigris to HTTP code mapping [here](/reference/http-code)
	Code *ErrorCode `json:"code,omitempty"`

	// A developer-facing descriptive error message
	Message *string `json:"message,omitempty"`
}

// The status code is a short, machine parsable string, which uniquely identifies the error type. Tigris to HTTP code mapping [here](/reference/http-code)
type ErrorCode string

// EventsRequest defines model for EventsRequest.
type EventsRequest struct {
	Collection *string               `json:"collection,omitempty"`
	Db         *string               `json:"db,omitempty"`
	Options    *EventsRequestOptions `json:"options,omitempty"`
}

// EventsRequestOptions defines model for EventsRequestOptions.
type EventsRequestOptions = map[string]interface{}

// EventsResponse defines model for EventsResponse.
type EventsResponse struct {
	Event *StreamEvent `json:"event,omitempty"`
}

// FacetCount defines model for FacetCount.
type FacetCount struct {
	Count *int64  `json:"count,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Additional stats for faceted field
type FacetStats struct {
	// Average of all values in a field. Only available for numeric fields
	Avg *float64 `json:"avg,omitempty"`

	// Total number of values in a field
	Count *int64 `json:"count,omitempty"`

	// Maximum of all values in a field. Only available for numeric fields
	Max *float64 `json:"max,omitempty"`

	// Minimum of all values in a field. Only available for numeric fields
	Min *float64 `json:"min,omitempty"`

	// Sum of all values in a field. Only available for numeric fields
	Sum *float64 `json:"sum,omitempty"`
}

// Requests the access token by specifying grant_type:refresh_token & refresh_token or grant_type:client_credentials & [client_id, client_secret]
type GetAccessTokenRequest struct {
	// case: client_credentials: A valid credentials (client_id, client_secret, audience)
	ClientId     *string                         `json:"client_id,omitempty"`
	ClientSecret *string                         `json:"client_secret,omitempty"`
	GrantType    *GetAccessTokenRequestGrantType `json:"grant_type,omitempty"`

	// case: refresh_token: A valid refresh token
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// GetAccessTokenRequestGrantType defines model for GetAccessTokenRequest.GrantType.
type GetAccessTokenRequestGrantType string

// GetAccessToken returns response containing access_token and optionally refresh_token
type GetAccessTokenResponse struct {
	// An access token.
	AccessToken *string `json:"access_token,omitempty"`

	// Access token expiration timeout in seconds
	ExpiresIn *int32 `json:"expires_in,omitempty"`

	// Refresh token.
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// GetInfoResponse defines model for GetInfoResponse.
type GetInfoResponse struct {
	ServerVersion *string `json:"server_version,omitempty"`
}

// Request user metadata
type GetUserMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// User metadata response
type GetUserMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	UserId      *string                 `json:"userId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// HealthCheckResponse defines model for HealthCheckResponse.
type HealthCheckResponse struct {
	Response *string `json:"response,omitempty"`
}

// InsertRequest defines model for InsertRequest.
type InsertRequest struct {
	// Array of documents to insert. Each document is a JSON object.
	Documents *[]json.RawMessage `json:"documents,omitempty"`

	// additional options for insert requests.
	Options *InsertRequestOptions `json:"options,omitempty"`
}

// additional options for insert requests.
type InsertRequestOptions struct {
	// Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// InsertResponse defines model for InsertResponse.
type InsertResponse struct {
	// an array returns the value of the primary keys.
	Keys *[][]byte `json:"keys,omitempty"`

	// Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// An enum with value set as "inserted"
	Status *string `json:"status,omitempty"`
}

// Request insertion of user metadata
type InsertUserMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// Insertion of user metadata response
type InsertUserMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	UserId      *string                 `json:"userId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// Request listing of all the application those are visible to requesting actor
type ListApplicationsRequest = map[string]interface{}

// ListApplication returns one or more visible application to user
type ListApplicationsResponse struct {
	Applications *[]Application `json:"applications,omitempty"`
}

// ListCollectionsRequest defines model for ListCollectionsRequest.
type ListCollectionsRequest struct {
	// Collection requests modifying options.
	Options *CollectionOptions `json:"options,omitempty"`
}

// ListCollectionsResponse defines model for ListCollectionsResponse.
type ListCollectionsResponse struct {
	// List of the collections info in the database.
	Collections *[]CollectionInfo `json:"collections,omitempty"`

	// Name of the database.
	Db *string `json:"db,omitempty"`
}

// ListDatabasesResponse defines model for ListDatabasesResponse.
type ListDatabasesResponse struct {
	// List of the databases.
	Databases *[]DatabaseInfo `json:"databases,omitempty"`
}

// ListNamespacesResponse defines model for ListNamespacesResponse.
type ListNamespacesResponse struct {
	Namespaces *[]NamespaceInfo `json:"namespaces,omitempty"`
}

// Represents series in timeseries based on input query.
type MetricSeries struct {
	DataPoints *[]DataPoint `json:"dataPoints,omitempty"`
	From       *int64       `json:"from,omitempty"`
	Metric     *string      `json:"metric,omitempty"`
	Scope      *string      `json:"scope,omitempty"`
	To         *int64       `json:"to,omitempty"`
}

// NamespaceInfo defines model for NamespaceInfo.
type NamespaceInfo struct {
	// A unique namespace id.
	Id *int32 `json:"id,omitempty"`

	// A namespace name.
	Name *string `json:"name,omitempty"`
}

// Pagination metadata for SearchResponse
type Page struct {
	// Number representing the current page of results
	Current *int32 `json:"current,omitempty"`

	// Maximum number of results per page
	Size *int32 `json:"size,omitempty"`
}

// PublishRequest defines model for PublishRequest.
type PublishRequest struct {
	Collection *string                   `json:"collection,omitempty"`
	Db         *string                   `json:"db,omitempty"`
	Messages   *[]map[string]interface{} `json:"messages,omitempty"`
	Options    *PublishRequestOptions    `json:"options,omitempty"`
}

// PublishRequestOptions defines model for PublishRequestOptions.
type PublishRequestOptions struct {
	Partition *int32 `json:"partition,omitempty"`
}

// PublishResponse defines model for PublishResponse.
type PublishResponse struct {
	Keys *[][]byte `json:"keys,omitempty"`

	// Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`
	Status   *string           `json:"status,omitempty"`
}

// Requests the time series metrics
type QueryTimeSeriesMetricsRequest struct {
	AdditionalFunctions *[]AdditionalFunction                          `json:"additionalFunctions,omitempty"`
	Collection          *string                                        `json:"collection,omitempty"`
	Db                  *string                                        `json:"db,omitempty"`
	From                *int64                                         `json:"from,omitempty"`
	Function            *QueryTimeSeriesMetricsRequestFunction         `json:"function,omitempty"`
	MetricName          *string                                        `json:"metric_name,omitempty"`
	Quantile            *float32                                       `json:"quantile,omitempty"`
	SpaceAggregatedBy   *[]string                                      `json:"space_aggregated_by,omitempty"`
	SpaceAggregation    *QueryTimeSeriesMetricsRequestSpaceAggregation `json:"space_aggregation,omitempty"`
	TigrisOperation     *QueryTimeSeriesMetricsRequestTigrisOperation  `json:"tigris_operation,omitempty"`
	To                  *int64                                         `json:"to,omitempty"`
}

// QueryTimeSeriesMetricsRequestFunction defines model for QueryTimeSeriesMetricsRequest.Function.
type QueryTimeSeriesMetricsRequestFunction string

// QueryTimeSeriesMetricsRequestSpaceAggregation defines model for QueryTimeSeriesMetricsRequest.SpaceAggregation.
type QueryTimeSeriesMetricsRequestSpaceAggregation string

// QueryTimeSeriesMetricsRequestTigrisOperation defines model for QueryTimeSeriesMetricsRequest.TigrisOperation.
type QueryTimeSeriesMetricsRequestTigrisOperation string

// QueryTimeSeriesMetric responds with this type.
type QueryTimeSeriesMetricsResponse struct {
	From   *int64          `json:"from,omitempty"`
	Query  *string         `json:"query,omitempty"`
	Series *[]MetricSeries `json:"series,omitempty"`
	To     *int64          `json:"to,omitempty"`
}

// ReadRequest defines model for ReadRequest.
type ReadRequest struct {
	// To read specific fields from a document. Default is all.
	Fields json.RawMessage `json:"fields,omitempty"`

	// Returns documents matching this filter. A filter can simply be a key, value pair where a key is the field name and the value would be the value for this field. Tigris also allows complex filtering by passing logical expressions. Logical filters are applied on two or more fields using `$or` and `$and`. A few examples of filters: <li> To read a user document where the id has a value 1: ```{"id": 1 }``` <li> To read all the user documents where the key "id" has a value 1 or 2 or 3: `{"$or": [{"id": 1}, {"id": 2}, {"id": 3}]}` Filter allows setting collation on an individual field level. To set collation for all the fields see options. The detailed documentation of the filter is <a href="https://docs.tigrisdata.com/overview/query#specification-1" title="here">here</a>.
	Filter json.RawMessage `json:"filter,omitempty"`

	// Options that can be used to modify the results, for example "limit" to control the number of documents returned by the server.
	Options *ReadRequestOptions `json:"options,omitempty"`
}

// Options that can be used to modify the results, for example "limit" to control the number of documents returned by the server.
type ReadRequestOptions struct {
	// A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// Limit the number of documents returned by the read operation.
	Limit *int64 `json:"limit,omitempty"`

	// A cursor for use in pagination. The next streams will return documents after this offset.
	Offset *[]byte `json:"offset,omitempty"`

	// Number of documents to skip before starting to return resulting documents.
	Skip *int64 `json:"skip,omitempty"`
}

// ReadResponse defines model for ReadResponse.
type ReadResponse struct {
	// Object containing the collection document.
	Data json.RawMessage `json:"data,omitempty"`

	// Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// An internal key, used for pagination.
	ResumeToken *[]byte `json:"resume_token,omitempty"`
}

// ReplaceRequest defines model for ReplaceRequest.
type ReplaceRequest struct {
	// Array of documents to be replaced. Each document is a JSON object.
	Documents *[]json.RawMessage `json:"documents,omitempty"`

	// Additional options for replace requests.
	Options *ReplaceRequestOptions `json:"options,omitempty"`
}

// Additional options for replace requests.
type ReplaceRequestOptions struct {
	// Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// ReplaceResponse defines model for ReplaceResponse.
type ReplaceResponse struct {
	// an array returns the value of the primary keys.
	Keys *[][]byte `json:"keys,omitempty"`

	// Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// an enum with value set as "replaced"
	Status *string `json:"status,omitempty"`
}

// Has metadata related to the documents stored.
type ResponseMetadata struct {
	// Time at which the document was inserted/replaced. Measured in nano-seconds since the Unix epoch.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Time at which the document was deleted. Measured in nano-seconds since the Unix epoch.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// Time at which the document was updated. Measured in nano-seconds since the Unix epoch.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// Rollback transaction with the given ID
type RollbackTransactionRequest = map[string]interface{}

// RollbackTransactionResponse defines model for RollbackTransactionResponse.
type RollbackTransactionResponse struct {
	// Status of rollback transaction operation.
	Status *string `json:"status,omitempty"`
}

// Rollup function aggregates the slices of metrics returned by original query and lets you operate on the slices using aggregator and constructs the bigger slice of your choice of interval (specified in seconds).
type RollupFunction struct {
	Aggregator *RollupFunctionAggregator `json:"aggregator,omitempty"`
	Interval   *int64                    `json:"interval,omitempty"`
}

// RollupFunctionAggregator defines model for RollupFunction.Aggregator.
type RollupFunctionAggregator string

// Request rotation of an application secret
type RotateApplicationSecretRequest struct {
	Id *string `json:"id,omitempty"`
}

// RotateApplicationRequest returns the new application with rotated secret
type RotateApplicationSecretResponse struct {
	// An user application
	Application *Application `json:"application,omitempty"`
}

// SearchFacet defines model for SearchFacet.
type SearchFacet struct {
	Counts *[]FacetCount `json:"counts,omitempty"`

	// Additional stats for faceted field
	Stats *FacetStats `json:"stats,omitempty"`
}

// SearchHit defines model for SearchHit.
type SearchHit struct {
	// Actual search document
	Data json.RawMessage `json:"data,omitempty"`

	// Contains metadata related to the search hit, has information about document created_at/updated_at as well.
	Metadata *SearchHitMeta `json:"metadata,omitempty"`
}

// Contains metadata related to the search hit, has information about document created_at/updated_at as well.
type SearchHitMeta struct {
	// Time at which the document was inserted/replaced. Measured in nano-seconds since the Unix epoch.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Time at which the document was updated. Measured in nano-seconds since the Unix epoch.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// SearchMetadata defines model for SearchMetadata.
type SearchMetadata struct {
	// Total number of search results across all pages
	Found *int64 `json:"found,omitempty"`

	// Pagination metadata for SearchResponse
	Page *Page `json:"page,omitempty"`

	// Number representing the total pages of results
	TotalPages *int32 `json:"total_pages,omitempty"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	// A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// Array of document field names to exclude from results. `include_fields`, if specified, takes precedence over `exclude_fields`.
	ExcludeFields *[]string `json:"exclude_fields,omitempty"`

	// Facet query to aggregate results on given fields. The field name for the facet search can be passed like this `{"brand": { "size": 10 }}` where the size controls the total facets for this field.
	Facet  json.RawMessage `json:"facet,omitempty"`
	Fields json.RawMessage `json:"fields,omitempty"`

	// Filter stacks on top of query results to further narrow down the results. Similar to `ReadRequest.filter`
	Filter json.RawMessage `json:"filter,omitempty"`

	// Array of document field names to include in results. By default, all fields are included.
	IncludeFields *[]string `json:"include_fields,omitempty"`

	// Optionally can specify the page to retrieve. If page is set then only hits for this page is returned
	Page *int32 `json:"page,omitempty"`

	// Optionally can set the number of hits to be returned per page, default is 20.
	PageSize *int32 `json:"page_size,omitempty"`

	// Query string for searching across text fields
	Q *string `json:"q,omitempty"`

	// Array of fields to project search query against
	SearchFields *[]string `json:"search_fields,omitempty"`

	// Array of fields and corresponding sort orders to order the results `[{ "salary": "$desc" }]`
	Sort json.RawMessage `json:"sort,omitempty"`
}

// Response struct for search
type SearchResponse struct {
	Facets *SearchResponse_Facets `json:"facets,omitempty"`
	Hits   *[]SearchHit           `json:"hits,omitempty"`
	Meta   *SearchMetadata        `json:"meta,omitempty"`
}

// SearchResponse_Facets defines model for SearchResponse.Facets.
type SearchResponse_Facets struct {
	AdditionalProperties map[string]SearchFacet `json:"-"`
}

// Status defines model for Status.
type Status struct {
	// The Error type defines a logical error model
	Error *Error `json:"error,omitempty"`
}

// StreamEvent defines model for StreamEvent.
type StreamEvent struct {
	Collection *string         `json:"collection,omitempty"`
	Data       json.RawMessage `json:"data,omitempty"`
	Key        *[]byte         `json:"key,omitempty"`
	Last       *bool           `json:"last,omitempty"`
	Lkey       *[]byte         `json:"lkey,omitempty"`
	Op         *string         `json:"op,omitempty"`
	Rkey       *[]byte         `json:"rkey,omitempty"`
	TxId       *[]byte         `json:"tx_id,omitempty"`
}

// StreamingEventsResponse defines model for StreamingEventsResponse.
type StreamingEventsResponse struct {
	// The Error type defines a logical error model
	Error  *Error          `json:"error,omitempty"`
	Result *EventsResponse `json:"result,omitempty"`
}

// StreamingReadResponse defines model for StreamingReadResponse.
type StreamingReadResponse struct {
	// The Error type defines a logical error model
	Error  *Error        `json:"error,omitempty"`
	Result *ReadResponse `json:"result,omitempty"`
}

// StreamingSearchResponse defines model for StreamingSearchResponse.
type StreamingSearchResponse struct {
	// The Error type defines a logical error model
	Error *Error `json:"error,omitempty"`

	// Response struct for search
	Result *SearchResponse `json:"result,omitempty"`
}

// StreamingSubscribeResponse defines model for StreamingSubscribeResponse.
type StreamingSubscribeResponse struct {
	// The Error type defines a logical error model
	Error  *Error             `json:"error,omitempty"`
	Result *SubscribeResponse `json:"result,omitempty"`
}

// SubscribeRequest defines model for SubscribeRequest.
type SubscribeRequest struct {
	Collection *string                  `json:"collection,omitempty"`
	Db         *string                  `json:"db,omitempty"`
	Options    *SubscribeRequestOptions `json:"options,omitempty"`
}

// SubscribeRequestOptions defines model for SubscribeRequestOptions.
type SubscribeRequestOptions struct {
	Partitions *[]int32 `json:"partitions,omitempty"`
}

// SubscribeResponse defines model for SubscribeResponse.
type SubscribeResponse struct {
	Message *[]byte `json:"message,omitempty"`
}

// Contains ID which uniquely identifies transaction This context is returned by BeginTransaction request and should be passed in the metadata (headers) of subsequent requests in order to run them in the context of the same transaction.
type TransactionCtx struct {
	// Unique for a single transactional request.
	Id *string `json:"id,omitempty"`

	// Serves as an internal identifier.
	Origin *string `json:"origin,omitempty"`
}

// Options that can be used to modify the transaction semantics.
type TransactionOptions = map[string]interface{}

// Request creation of user application
type UpdateApplicationRequest struct {
	// A new human readable app description
	Description *string `json:"description,omitempty"`

	// application id
	Id *string `json:"id,omitempty"`

	// A new human readable app name
	Name *string `json:"name,omitempty"`
}

// CreateApplication returns created application
type UpdateApplicationResponse struct {
	// An user application
	UpdatedApplication *Application `json:"updated_application,omitempty"`
}

// UpdateRequest defines model for UpdateRequest.
type UpdateRequest struct {
	// Fields contains set of fields with the values which need to be updated. Should be proper JSON object.
	Fields json.RawMessage `json:"fields,omitempty"`

	// Update documents which matching specified filter. A filter can simply be key, value where key is the field name and value would be the value for this field. Or a filter can be logical where two or more fields can be logically joined using $or and $and. A few examples of filter: <li> To update a user document where the id has a value 1: ```{"id": 1 }``` <li> To update all the user documents where the key "id" has a value 1 or 2 or 3: `{"$or": [{"id": 1}, {"id": 2}, {"id": 3}]}`
	Filter json.RawMessage `json:"filter,omitempty"`

	// Additional options for update requests.
	Options *UpdateRequestOptions `json:"options,omitempty"`
}

// Additional options for update requests.
type UpdateRequestOptions struct {
	// A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// UpdateResponse defines model for UpdateResponse.
type UpdateResponse struct {
	// Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// Returns the number of documents modified.
	ModifiedCount *int32 `json:"modified_count,omitempty"`

	// an enum with value set as "updated".
	Status *string `json:"status,omitempty"`
}

// Request update of user metadata
type UpdateUserMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// Update of user metadata response
type UpdateUserMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	UserId      *string                 `json:"userId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// Additional options to modify write requests.
type WriteOptions = map[string]interface{}

// AdminCreateNamespaceJSONBody defines parameters for AdminCreateNamespace.
type AdminCreateNamespaceJSONBody = CreateNamespaceRequest

// UserCreateApplicationJSONBody defines parameters for UserCreateApplication.
type UserCreateApplicationJSONBody = CreateApplicationRequest

// UserDeleteApplicationJSONBody defines parameters for UserDeleteApplication.
type UserDeleteApplicationJSONBody = DeleteApplicationsRequest

// UserListApplicationsJSONBody defines parameters for UserListApplications.
type UserListApplicationsJSONBody = ListApplicationsRequest

// UserRotateApplicationSecretJSONBody defines parameters for UserRotateApplicationSecret.
type UserRotateApplicationSecretJSONBody = RotateApplicationSecretRequest

// UserUpdateApplicationJSONBody defines parameters for UserUpdateApplication.
type UserUpdateApplicationJSONBody = UpdateApplicationRequest

// AuthGetAccessTokenJSONBody defines parameters for AuthGetAccessToken.
type AuthGetAccessTokenJSONBody = GetAccessTokenRequest

// TigrisListCollectionsJSONBody defines parameters for TigrisListCollections.
type TigrisListCollectionsJSONBody = ListCollectionsRequest

// TigrisCreateOrUpdateCollectionJSONBody defines parameters for TigrisCreateOrUpdateCollection.
type TigrisCreateOrUpdateCollectionJSONBody = CreateOrUpdateCollectionRequest

// TigrisDescribeCollectionJSONBody defines parameters for TigrisDescribeCollection.
type TigrisDescribeCollectionJSONBody = DescribeCollectionRequest

// TigrisDeleteJSONBody defines parameters for TigrisDelete.
type TigrisDeleteJSONBody = DeleteRequest

// TigrisInsertJSONBody defines parameters for TigrisInsert.
type TigrisInsertJSONBody = InsertRequest

// TigrisReadJSONBody defines parameters for TigrisRead.
type TigrisReadJSONBody = ReadRequest

// TigrisReplaceJSONBody defines parameters for TigrisReplace.
type TigrisReplaceJSONBody = ReplaceRequest

// TigrisSearchJSONBody defines parameters for TigrisSearch.
type TigrisSearchJSONBody = SearchRequest

// TigrisUpdateJSONBody defines parameters for TigrisUpdate.
type TigrisUpdateJSONBody = UpdateRequest

// TigrisDropCollectionJSONBody defines parameters for TigrisDropCollection.
type TigrisDropCollectionJSONBody = DropCollectionRequest

// TigrisEventsJSONBody defines parameters for TigrisEvents.
type TigrisEventsJSONBody = EventsRequest

// TigrisPublishJSONBody defines parameters for TigrisPublish.
type TigrisPublishJSONBody = PublishRequest

// TigrisSubscribeJSONBody defines parameters for TigrisSubscribe.
type TigrisSubscribeJSONBody = SubscribeRequest

// TigrisCreateDatabaseJSONBody defines parameters for TigrisCreateDatabase.
type TigrisCreateDatabaseJSONBody = CreateDatabaseRequest

// TigrisDescribeDatabaseJSONBody defines parameters for TigrisDescribeDatabase.
type TigrisDescribeDatabaseJSONBody = DescribeDatabaseRequest

// TigrisDropDatabaseJSONBody defines parameters for TigrisDropDatabase.
type TigrisDropDatabaseJSONBody = DropDatabaseRequest

// TigrisBeginTransactionJSONBody defines parameters for TigrisBeginTransaction.
type TigrisBeginTransactionJSONBody = BeginTransactionRequest

// TigrisCommitTransactionJSONBody defines parameters for TigrisCommitTransaction.
type TigrisCommitTransactionJSONBody = CommitTransactionRequest

// TigrisRollbackTransactionJSONBody defines parameters for TigrisRollbackTransaction.
type TigrisRollbackTransactionJSONBody = RollbackTransactionRequest

// ObservabilityQueryTimeSeriesMetricsJSONBody defines parameters for ObservabilityQueryTimeSeriesMetrics.
type ObservabilityQueryTimeSeriesMetricsJSONBody = QueryTimeSeriesMetricsRequest

// UserGetUserMetadataJSONBody defines parameters for UserGetUserMetadata.
type UserGetUserMetadataJSONBody = GetUserMetadataRequest

// UserInsertUserMetadataJSONBody defines parameters for UserInsertUserMetadata.
type UserInsertUserMetadataJSONBody = InsertUserMetadataRequest

// UserUpdateUserMetadataJSONBody defines parameters for UserUpdateUserMetadata.
type UserUpdateUserMetadataJSONBody = UpdateUserMetadataRequest

// AdminCreateNamespaceJSONRequestBody defines body for AdminCreateNamespace for application/json ContentType.
type AdminCreateNamespaceJSONRequestBody = AdminCreateNamespaceJSONBody

// UserCreateApplicationJSONRequestBody defines body for UserCreateApplication for application/json ContentType.
type UserCreateApplicationJSONRequestBody = UserCreateApplicationJSONBody

// UserDeleteApplicationJSONRequestBody defines body for UserDeleteApplication for application/json ContentType.
type UserDeleteApplicationJSONRequestBody = UserDeleteApplicationJSONBody

// UserListApplicationsJSONRequestBody defines body for UserListApplications for application/json ContentType.
type UserListApplicationsJSONRequestBody = UserListApplicationsJSONBody

// UserRotateApplicationSecretJSONRequestBody defines body for UserRotateApplicationSecret for application/json ContentType.
type UserRotateApplicationSecretJSONRequestBody = UserRotateApplicationSecretJSONBody

// UserUpdateApplicationJSONRequestBody defines body for UserUpdateApplication for application/json ContentType.
type UserUpdateApplicationJSONRequestBody = UserUpdateApplicationJSONBody

// AuthGetAccessTokenJSONRequestBody defines body for AuthGetAccessToken for application/json ContentType.
type AuthGetAccessTokenJSONRequestBody = AuthGetAccessTokenJSONBody

// TigrisListCollectionsJSONRequestBody defines body for TigrisListCollections for application/json ContentType.
type TigrisListCollectionsJSONRequestBody = TigrisListCollectionsJSONBody

// TigrisCreateOrUpdateCollectionJSONRequestBody defines body for TigrisCreateOrUpdateCollection for application/json ContentType.
type TigrisCreateOrUpdateCollectionJSONRequestBody = TigrisCreateOrUpdateCollectionJSONBody

// TigrisDescribeCollectionJSONRequestBody defines body for TigrisDescribeCollection for application/json ContentType.
type TigrisDescribeCollectionJSONRequestBody = TigrisDescribeCollectionJSONBody

// TigrisDeleteJSONRequestBody defines body for TigrisDelete for application/json ContentType.
type TigrisDeleteJSONRequestBody = TigrisDeleteJSONBody

// TigrisInsertJSONRequestBody defines body for TigrisInsert for application/json ContentType.
type TigrisInsertJSONRequestBody = TigrisInsertJSONBody

// TigrisReadJSONRequestBody defines body for TigrisRead for application/json ContentType.
type TigrisReadJSONRequestBody = TigrisReadJSONBody

// TigrisReplaceJSONRequestBody defines body for TigrisReplace for application/json ContentType.
type TigrisReplaceJSONRequestBody = TigrisReplaceJSONBody

// TigrisSearchJSONRequestBody defines body for TigrisSearch for application/json ContentType.
type TigrisSearchJSONRequestBody = TigrisSearchJSONBody

// TigrisUpdateJSONRequestBody defines body for TigrisUpdate for application/json ContentType.
type TigrisUpdateJSONRequestBody = TigrisUpdateJSONBody

// TigrisDropCollectionJSONRequestBody defines body for TigrisDropCollection for application/json ContentType.
type TigrisDropCollectionJSONRequestBody = TigrisDropCollectionJSONBody

// TigrisEventsJSONRequestBody defines body for TigrisEvents for application/json ContentType.
type TigrisEventsJSONRequestBody = TigrisEventsJSONBody

// TigrisPublishJSONRequestBody defines body for TigrisPublish for application/json ContentType.
type TigrisPublishJSONRequestBody = TigrisPublishJSONBody

// TigrisSubscribeJSONRequestBody defines body for TigrisSubscribe for application/json ContentType.
type TigrisSubscribeJSONRequestBody = TigrisSubscribeJSONBody

// TigrisCreateDatabaseJSONRequestBody defines body for TigrisCreateDatabase for application/json ContentType.
type TigrisCreateDatabaseJSONRequestBody = TigrisCreateDatabaseJSONBody

// TigrisDescribeDatabaseJSONRequestBody defines body for TigrisDescribeDatabase for application/json ContentType.
type TigrisDescribeDatabaseJSONRequestBody = TigrisDescribeDatabaseJSONBody

// TigrisDropDatabaseJSONRequestBody defines body for TigrisDropDatabase for application/json ContentType.
type TigrisDropDatabaseJSONRequestBody = TigrisDropDatabaseJSONBody

// TigrisBeginTransactionJSONRequestBody defines body for TigrisBeginTransaction for application/json ContentType.
type TigrisBeginTransactionJSONRequestBody = TigrisBeginTransactionJSONBody

// TigrisCommitTransactionJSONRequestBody defines body for TigrisCommitTransaction for application/json ContentType.
type TigrisCommitTransactionJSONRequestBody = TigrisCommitTransactionJSONBody

// TigrisRollbackTransactionJSONRequestBody defines body for TigrisRollbackTransaction for application/json ContentType.
type TigrisRollbackTransactionJSONRequestBody = TigrisRollbackTransactionJSONBody

// ObservabilityQueryTimeSeriesMetricsJSONRequestBody defines body for ObservabilityQueryTimeSeriesMetrics for application/json ContentType.
type ObservabilityQueryTimeSeriesMetricsJSONRequestBody = ObservabilityQueryTimeSeriesMetricsJSONBody

// UserGetUserMetadataJSONRequestBody defines body for UserGetUserMetadata for application/json ContentType.
type UserGetUserMetadataJSONRequestBody = UserGetUserMetadataJSONBody

// UserInsertUserMetadataJSONRequestBody defines body for UserInsertUserMetadata for application/json ContentType.
type UserInsertUserMetadataJSONRequestBody = UserInsertUserMetadataJSONBody

// UserUpdateUserMetadataJSONRequestBody defines body for UserUpdateUserMetadata for application/json ContentType.
type UserUpdateUserMetadataJSONRequestBody = UserUpdateUserMetadataJSONBody

// Getter for additional properties for SearchResponse_Facets. Returns the specified
// element and whether it was found
func (a SearchResponse_Facets) Get(fieldName string) (value SearchFacet, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for SearchResponse_Facets
func (a *SearchResponse_Facets) Set(fieldName string, value SearchFacet) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]SearchFacet)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for SearchResponse_Facets to handle AdditionalProperties
func (a *SearchResponse_Facets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]SearchFacet)
		for fieldName, fieldBuf := range object {
			var fieldVal SearchFacet
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for SearchResponse_Facets to handle AdditionalProperties
func (a SearchResponse_Facets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AdminListNamespaces request
	AdminListNamespaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AdminCreateNamespace request with any body
	AdminCreateNamespaceWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AdminCreateNamespace(ctx context.Context, name string, body AdminCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserCreateApplication request with any body
	UserCreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserCreateApplication(ctx context.Context, body UserCreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserDeleteApplication request with any body
	UserDeleteApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserDeleteApplication(ctx context.Context, body UserDeleteApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserListApplications request with any body
	UserListApplicationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserListApplications(ctx context.Context, body UserListApplicationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserRotateApplicationSecret request with any body
	UserRotateApplicationSecretWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserRotateApplicationSecret(ctx context.Context, body UserRotateApplicationSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateApplication request with any body
	UserUpdateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdateApplication(ctx context.Context, body UserUpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthGetAccessToken request with any body
	AuthGetAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuthGetAccessToken(ctx context.Context, body AuthGetAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisListDatabases request
	TigrisListDatabases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisListCollections request with any body
	TigrisListCollectionsWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisListCollections(ctx context.Context, db string, body TigrisListCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCreateOrUpdateCollection request with any body
	TigrisCreateOrUpdateCollectionWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCreateOrUpdateCollection(ctx context.Context, db string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDescribeCollection request with any body
	TigrisDescribeCollectionWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDescribeCollection(ctx context.Context, db string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDelete request with any body
	TigrisDeleteWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDelete(ctx context.Context, db string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisInsert request with any body
	TigrisInsertWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisInsert(ctx context.Context, db string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisRead request with any body
	TigrisReadWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisRead(ctx context.Context, db string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisReplace request with any body
	TigrisReplaceWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisReplace(ctx context.Context, db string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisSearch request with any body
	TigrisSearchWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisSearch(ctx context.Context, db string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisUpdate request with any body
	TigrisUpdateWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisUpdate(ctx context.Context, db string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDropCollection request with any body
	TigrisDropCollectionWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDropCollection(ctx context.Context, db string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisEvents request with any body
	TigrisEventsWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisEvents(ctx context.Context, db string, collection string, body TigrisEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisPublish request with any body
	TigrisPublishWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisPublish(ctx context.Context, db string, collection string, body TigrisPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisSubscribe request with any body
	TigrisSubscribeWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisSubscribe(ctx context.Context, db string, collection string, body TigrisSubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCreateDatabase request with any body
	TigrisCreateDatabaseWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCreateDatabase(ctx context.Context, db string, body TigrisCreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDescribeDatabase request with any body
	TigrisDescribeDatabaseWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDescribeDatabase(ctx context.Context, db string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDropDatabase request with any body
	TigrisDropDatabaseWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDropDatabase(ctx context.Context, db string, body TigrisDropDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisBeginTransaction request with any body
	TigrisBeginTransactionWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisBeginTransaction(ctx context.Context, db string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCommitTransaction request with any body
	TigrisCommitTransactionWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCommitTransaction(ctx context.Context, db string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisRollbackTransaction request with any body
	TigrisRollbackTransactionWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisRollbackTransaction(ctx context.Context, db string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthAPIHealth request
	HealthAPIHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisGetInfo request
	TigrisGetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservabilityQueryTimeSeriesMetrics request with any body
	ObservabilityQueryTimeSeriesMetricsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObservabilityQueryTimeSeriesMetrics(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserGetUserMetadata request with any body
	UserGetUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserGetUserMetadata(ctx context.Context, metadataKey string, body UserGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserInsertUserMetadata request with any body
	UserInsertUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserInsertUserMetadata(ctx context.Context, metadataKey string, body UserInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdateUserMetadata request with any body
	UserUpdateUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdateUserMetadata(ctx context.Context, metadataKey string, body UserUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AdminListNamespaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminListNamespacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminCreateNamespaceWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminCreateNamespaceRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AdminCreateNamespace(ctx context.Context, name string, body AdminCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAdminCreateNamespaceRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreateApplication(ctx context.Context, body UserCreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserDeleteApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserDeleteApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserDeleteApplication(ctx context.Context, body UserDeleteApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserDeleteApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserListApplicationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserListApplicationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserListApplications(ctx context.Context, body UserListApplicationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserListApplicationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserRotateApplicationSecretWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserRotateApplicationSecretRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserRotateApplicationSecret(ctx context.Context, body UserRotateApplicationSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserRotateApplicationSecretRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateApplicationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateApplicationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateApplication(ctx context.Context, body UserUpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateApplicationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGetAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGetAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthGetAccessToken(ctx context.Context, body AuthGetAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGetAccessTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisListDatabases(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisListDatabasesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisListCollectionsWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisListCollectionsRequestWithBody(c.Server, db, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisListCollections(ctx context.Context, db string, body TigrisListCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisListCollectionsRequest(c.Server, db, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateOrUpdateCollectionWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateOrUpdateCollectionRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateOrUpdateCollection(ctx context.Context, db string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateOrUpdateCollectionRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeCollectionWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeCollectionRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeCollection(ctx context.Context, db string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeCollectionRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDelete(ctx context.Context, db string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisInsertWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisInsertRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisInsert(ctx context.Context, db string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisInsertRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisReadWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReadRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRead(ctx context.Context, db string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReadRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisReplaceWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReplaceRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisReplace(ctx context.Context, db string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReplaceRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisSearchWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisSearchRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisSearch(ctx context.Context, db string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisSearchRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisUpdateWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisUpdateRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisUpdate(ctx context.Context, db string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisUpdateRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDropCollectionWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDropCollectionRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDropCollection(ctx context.Context, db string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDropCollectionRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisEventsWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisEventsRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisEvents(ctx context.Context, db string, collection string, body TigrisEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisEventsRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisPublishWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisPublishRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisPublish(ctx context.Context, db string, collection string, body TigrisPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisPublishRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisSubscribeWithBody(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisSubscribeRequestWithBody(c.Server, db, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisSubscribe(ctx context.Context, db string, collection string, body TigrisSubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisSubscribeRequest(c.Server, db, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateDatabaseWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateDatabaseRequestWithBody(c.Server, db, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateDatabase(ctx context.Context, db string, body TigrisCreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateDatabaseRequest(c.Server, db, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeDatabaseWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeDatabaseRequestWithBody(c.Server, db, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeDatabase(ctx context.Context, db string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeDatabaseRequest(c.Server, db, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDropDatabaseWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDropDatabaseRequestWithBody(c.Server, db, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDropDatabase(ctx context.Context, db string, body TigrisDropDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDropDatabaseRequest(c.Server, db, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisBeginTransactionWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisBeginTransactionRequestWithBody(c.Server, db, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisBeginTransaction(ctx context.Context, db string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisBeginTransactionRequest(c.Server, db, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCommitTransactionWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCommitTransactionRequestWithBody(c.Server, db, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCommitTransaction(ctx context.Context, db string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCommitTransactionRequest(c.Server, db, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRollbackTransactionWithBody(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisRollbackTransactionRequestWithBody(c.Server, db, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRollbackTransaction(ctx context.Context, db string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisRollbackTransactionRequest(c.Server, db, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthAPIHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthAPIHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisGetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisGetInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQueryTimeSeriesMetricsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQueryTimeSeriesMetricsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQueryTimeSeriesMetrics(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQueryTimeSeriesMetricsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGetUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetUserMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserGetUserMetadata(ctx context.Context, metadataKey string, body UserGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserGetUserMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserInsertUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserInsertUserMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserInsertUserMetadata(ctx context.Context, metadataKey string, body UserInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserInsertUserMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateUserMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateUserMetadata(ctx context.Context, metadataKey string, body UserUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateUserMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAdminListNamespacesRequest generates requests for AdminListNamespaces
func NewAdminListNamespacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/admin/namespaces/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAdminCreateNamespaceRequest calls the generic AdminCreateNamespace builder with application/json body
func NewAdminCreateNamespaceRequest(server string, name string, body AdminCreateNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAdminCreateNamespaceRequestWithBody(server, name, "application/json", bodyReader)
}

// NewAdminCreateNamespaceRequestWithBody generates requests for AdminCreateNamespace with any type of body
func NewAdminCreateNamespaceRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/admin/namespaces/%s/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserCreateApplicationRequest calls the generic UserCreateApplication builder with application/json body
func NewUserCreateApplicationRequest(server string, body UserCreateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserCreateApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewUserCreateApplicationRequestWithBody generates requests for UserCreateApplication with any type of body
func NewUserCreateApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/applications/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserDeleteApplicationRequest calls the generic UserDeleteApplication builder with application/json body
func NewUserDeleteApplicationRequest(server string, body UserDeleteApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserDeleteApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewUserDeleteApplicationRequestWithBody generates requests for UserDeleteApplication with any type of body
func NewUserDeleteApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/applications/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserListApplicationsRequest calls the generic UserListApplications builder with application/json body
func NewUserListApplicationsRequest(server string, body UserListApplicationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserListApplicationsRequestWithBody(server, "application/json", bodyReader)
}

// NewUserListApplicationsRequestWithBody generates requests for UserListApplications with any type of body
func NewUserListApplicationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/applications/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserRotateApplicationSecretRequest calls the generic UserRotateApplicationSecret builder with application/json body
func NewUserRotateApplicationSecretRequest(server string, body UserRotateApplicationSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserRotateApplicationSecretRequestWithBody(server, "application/json", bodyReader)
}

// NewUserRotateApplicationSecretRequestWithBody generates requests for UserRotateApplicationSecret with any type of body
func NewUserRotateApplicationSecretRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/applications/rotate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateApplicationRequest calls the generic UserUpdateApplication builder with application/json body
func NewUserUpdateApplicationRequest(server string, body UserUpdateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateApplicationRequestWithBody(server, "application/json", bodyReader)
}

// NewUserUpdateApplicationRequestWithBody generates requests for UserUpdateApplication with any type of body
func NewUserUpdateApplicationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/applications/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuthGetAccessTokenRequest calls the generic AuthGetAccessToken builder with application/json body
func NewAuthGetAccessTokenRequest(server string, body AuthGetAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuthGetAccessTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewAuthGetAccessTokenRequestWithBody generates requests for AuthGetAccessToken with any type of body
func NewAuthGetAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisListDatabasesRequest generates requests for TigrisListDatabases
func NewTigrisListDatabasesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTigrisListCollectionsRequest calls the generic TigrisListCollections builder with application/json body
func NewTigrisListCollectionsRequest(server string, db string, body TigrisListCollectionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisListCollectionsRequestWithBody(server, db, "application/json", bodyReader)
}

// NewTigrisListCollectionsRequestWithBody generates requests for TigrisListCollections with any type of body
func NewTigrisListCollectionsRequestWithBody(server string, db string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisCreateOrUpdateCollectionRequest calls the generic TigrisCreateOrUpdateCollection builder with application/json body
func NewTigrisCreateOrUpdateCollectionRequest(server string, db string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCreateOrUpdateCollectionRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisCreateOrUpdateCollectionRequestWithBody generates requests for TigrisCreateOrUpdateCollection with any type of body
func NewTigrisCreateOrUpdateCollectionRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/createOrUpdate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDescribeCollectionRequest calls the generic TigrisDescribeCollection builder with application/json body
func NewTigrisDescribeCollectionRequest(server string, db string, collection string, body TigrisDescribeCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDescribeCollectionRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisDescribeCollectionRequestWithBody generates requests for TigrisDescribeCollection with any type of body
func NewTigrisDescribeCollectionRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/describe", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDeleteRequest calls the generic TigrisDelete builder with application/json body
func NewTigrisDeleteRequest(server string, db string, collection string, body TigrisDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDeleteRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisDeleteRequestWithBody generates requests for TigrisDelete with any type of body
func NewTigrisDeleteRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/documents/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisInsertRequest calls the generic TigrisInsert builder with application/json body
func NewTigrisInsertRequest(server string, db string, collection string, body TigrisInsertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisInsertRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisInsertRequestWithBody generates requests for TigrisInsert with any type of body
func NewTigrisInsertRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/documents/insert", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisReadRequest calls the generic TigrisRead builder with application/json body
func NewTigrisReadRequest(server string, db string, collection string, body TigrisReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisReadRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisReadRequestWithBody generates requests for TigrisRead with any type of body
func NewTigrisReadRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/documents/read", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisReplaceRequest calls the generic TigrisReplace builder with application/json body
func NewTigrisReplaceRequest(server string, db string, collection string, body TigrisReplaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisReplaceRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisReplaceRequestWithBody generates requests for TigrisReplace with any type of body
func NewTigrisReplaceRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/documents/replace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisSearchRequest calls the generic TigrisSearch builder with application/json body
func NewTigrisSearchRequest(server string, db string, collection string, body TigrisSearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisSearchRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisSearchRequestWithBody generates requests for TigrisSearch with any type of body
func NewTigrisSearchRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/documents/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisUpdateRequest calls the generic TigrisUpdate builder with application/json body
func NewTigrisUpdateRequest(server string, db string, collection string, body TigrisUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisUpdateRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisUpdateRequestWithBody generates requests for TigrisUpdate with any type of body
func NewTigrisUpdateRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/documents/update", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDropCollectionRequest calls the generic TigrisDropCollection builder with application/json body
func NewTigrisDropCollectionRequest(server string, db string, collection string, body TigrisDropCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDropCollectionRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisDropCollectionRequestWithBody generates requests for TigrisDropCollection with any type of body
func NewTigrisDropCollectionRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/drop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisEventsRequest calls the generic TigrisEvents builder with application/json body
func NewTigrisEventsRequest(server string, db string, collection string, body TigrisEventsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisEventsRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisEventsRequestWithBody generates requests for TigrisEvents with any type of body
func NewTigrisEventsRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisPublishRequest calls the generic TigrisPublish builder with application/json body
func NewTigrisPublishRequest(server string, db string, collection string, body TigrisPublishJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisPublishRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisPublishRequestWithBody generates requests for TigrisPublish with any type of body
func NewTigrisPublishRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/messages/publish", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisSubscribeRequest calls the generic TigrisSubscribe builder with application/json body
func NewTigrisSubscribeRequest(server string, db string, collection string, body TigrisSubscribeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisSubscribeRequestWithBody(server, db, collection, "application/json", bodyReader)
}

// NewTigrisSubscribeRequestWithBody generates requests for TigrisSubscribe with any type of body
func NewTigrisSubscribeRequestWithBody(server string, db string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/collections/%s/messages/subscribe", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisCreateDatabaseRequest calls the generic TigrisCreateDatabase builder with application/json body
func NewTigrisCreateDatabaseRequest(server string, db string, body TigrisCreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCreateDatabaseRequestWithBody(server, db, "application/json", bodyReader)
}

// NewTigrisCreateDatabaseRequestWithBody generates requests for TigrisCreateDatabase with any type of body
func NewTigrisCreateDatabaseRequestWithBody(server string, db string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDescribeDatabaseRequest calls the generic TigrisDescribeDatabase builder with application/json body
func NewTigrisDescribeDatabaseRequest(server string, db string, body TigrisDescribeDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDescribeDatabaseRequestWithBody(server, db, "application/json", bodyReader)
}

// NewTigrisDescribeDatabaseRequestWithBody generates requests for TigrisDescribeDatabase with any type of body
func NewTigrisDescribeDatabaseRequestWithBody(server string, db string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/describe", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDropDatabaseRequest calls the generic TigrisDropDatabase builder with application/json body
func NewTigrisDropDatabaseRequest(server string, db string, body TigrisDropDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDropDatabaseRequestWithBody(server, db, "application/json", bodyReader)
}

// NewTigrisDropDatabaseRequestWithBody generates requests for TigrisDropDatabase with any type of body
func NewTigrisDropDatabaseRequestWithBody(server string, db string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/drop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisBeginTransactionRequest calls the generic TigrisBeginTransaction builder with application/json body
func NewTigrisBeginTransactionRequest(server string, db string, body TigrisBeginTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisBeginTransactionRequestWithBody(server, db, "application/json", bodyReader)
}

// NewTigrisBeginTransactionRequestWithBody generates requests for TigrisBeginTransaction with any type of body
func NewTigrisBeginTransactionRequestWithBody(server string, db string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/transactions/begin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisCommitTransactionRequest calls the generic TigrisCommitTransaction builder with application/json body
func NewTigrisCommitTransactionRequest(server string, db string, body TigrisCommitTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCommitTransactionRequestWithBody(server, db, "application/json", bodyReader)
}

// NewTigrisCommitTransactionRequestWithBody generates requests for TigrisCommitTransaction with any type of body
func NewTigrisCommitTransactionRequestWithBody(server string, db string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/transactions/commit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisRollbackTransactionRequest calls the generic TigrisRollbackTransaction builder with application/json body
func NewTigrisRollbackTransactionRequest(server string, db string, body TigrisRollbackTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisRollbackTransactionRequestWithBody(server, db, "application/json", bodyReader)
}

// NewTigrisRollbackTransactionRequestWithBody generates requests for TigrisRollbackTransaction with any type of body
func NewTigrisRollbackTransactionRequestWithBody(server string, db string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "db", runtime.ParamLocationPath, db)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/databases/%s/transactions/rollback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHealthAPIHealthRequest generates requests for HealthAPIHealth
func NewHealthAPIHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTigrisGetInfoRequest generates requests for TigrisGetInfo
func NewTigrisGetInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObservabilityQueryTimeSeriesMetricsRequest calls the generic ObservabilityQueryTimeSeriesMetrics builder with application/json body
func NewObservabilityQueryTimeSeriesMetricsRequest(server string, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewObservabilityQueryTimeSeriesMetricsRequestWithBody(server, "application/json", bodyReader)
}

// NewObservabilityQueryTimeSeriesMetricsRequestWithBody generates requests for ObservabilityQueryTimeSeriesMetrics with any type of body
func NewObservabilityQueryTimeSeriesMetricsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/observability/metrics/timeseries/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserGetUserMetadataRequest calls the generic UserGetUserMetadata builder with application/json body
func NewUserGetUserMetadataRequest(server string, metadataKey string, body UserGetUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserGetUserMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewUserGetUserMetadataRequestWithBody generates requests for UserGetUserMetadata with any type of body
func NewUserGetUserMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/metadata/%s/get", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserInsertUserMetadataRequest calls the generic UserInsertUserMetadata builder with application/json body
func NewUserInsertUserMetadataRequest(server string, metadataKey string, body UserInsertUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserInsertUserMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewUserInsertUserMetadataRequestWithBody generates requests for UserInsertUserMetadata with any type of body
func NewUserInsertUserMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/metadata/%s/insert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserUpdateUserMetadataRequest calls the generic UserUpdateUserMetadata builder with application/json body
func NewUserUpdateUserMetadataRequest(server string, metadataKey string, body UserUpdateUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateUserMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewUserUpdateUserMetadataRequestWithBody generates requests for UserUpdateUserMetadata with any type of body
func NewUserUpdateUserMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/users/metadata/%s/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AdminListNamespaces request
	AdminListNamespacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AdminListNamespacesResponse, error)

	// AdminCreateNamespace request with any body
	AdminCreateNamespaceWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminCreateNamespaceResponse, error)

	AdminCreateNamespaceWithResponse(ctx context.Context, name string, body AdminCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminCreateNamespaceResponse, error)

	// UserCreateApplication request with any body
	UserCreateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateApplicationResponse, error)

	UserCreateApplicationWithResponse(ctx context.Context, body UserCreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateApplicationResponse, error)

	// UserDeleteApplication request with any body
	UserDeleteApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserDeleteApplicationResponse, error)

	UserDeleteApplicationWithResponse(ctx context.Context, body UserDeleteApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UserDeleteApplicationResponse, error)

	// UserListApplications request with any body
	UserListApplicationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserListApplicationsResponse, error)

	UserListApplicationsWithResponse(ctx context.Context, body UserListApplicationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UserListApplicationsResponse, error)

	// UserRotateApplicationSecret request with any body
	UserRotateApplicationSecretWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserRotateApplicationSecretResponse, error)

	UserRotateApplicationSecretWithResponse(ctx context.Context, body UserRotateApplicationSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*UserRotateApplicationSecretResponse, error)

	// UserUpdateApplication request with any body
	UserUpdateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateApplicationResponse, error)

	UserUpdateApplicationWithResponse(ctx context.Context, body UserUpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateApplicationResponse, error)

	// AuthGetAccessToken request with any body
	AuthGetAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGetAccessTokenResponse, error)

	AuthGetAccessTokenWithResponse(ctx context.Context, body AuthGetAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthGetAccessTokenResponse, error)

	// TigrisListDatabases request
	TigrisListDatabasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TigrisListDatabasesResponse, error)

	// TigrisListCollections request with any body
	TigrisListCollectionsWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisListCollectionsResponse, error)

	TigrisListCollectionsWithResponse(ctx context.Context, db string, body TigrisListCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisListCollectionsResponse, error)

	// TigrisCreateOrUpdateCollection request with any body
	TigrisCreateOrUpdateCollectionWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error)

	TigrisCreateOrUpdateCollectionWithResponse(ctx context.Context, db string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error)

	// TigrisDescribeCollection request with any body
	TigrisDescribeCollectionWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error)

	TigrisDescribeCollectionWithResponse(ctx context.Context, db string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error)

	// TigrisDelete request with any body
	TigrisDeleteWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error)

	TigrisDeleteWithResponse(ctx context.Context, db string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error)

	// TigrisInsert request with any body
	TigrisInsertWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error)

	TigrisInsertWithResponse(ctx context.Context, db string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error)

	// TigrisRead request with any body
	TigrisReadWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error)

	TigrisReadWithResponse(ctx context.Context, db string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error)

	// TigrisReplace request with any body
	TigrisReplaceWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error)

	TigrisReplaceWithResponse(ctx context.Context, db string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error)

	// TigrisSearch request with any body
	TigrisSearchWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error)

	TigrisSearchWithResponse(ctx context.Context, db string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error)

	// TigrisUpdate request with any body
	TigrisUpdateWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error)

	TigrisUpdateWithResponse(ctx context.Context, db string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error)

	// TigrisDropCollection request with any body
	TigrisDropCollectionWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error)

	TigrisDropCollectionWithResponse(ctx context.Context, db string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error)

	// TigrisEvents request with any body
	TigrisEventsWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisEventsResponse, error)

	TigrisEventsWithResponse(ctx context.Context, db string, collection string, body TigrisEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisEventsResponse, error)

	// TigrisPublish request with any body
	TigrisPublishWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisPublishResponse, error)

	TigrisPublishWithResponse(ctx context.Context, db string, collection string, body TigrisPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisPublishResponse, error)

	// TigrisSubscribe request with any body
	TigrisSubscribeWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisSubscribeResponse, error)

	TigrisSubscribeWithResponse(ctx context.Context, db string, collection string, body TigrisSubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisSubscribeResponse, error)

	// TigrisCreateDatabase request with any body
	TigrisCreateDatabaseWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateDatabaseResponse, error)

	TigrisCreateDatabaseWithResponse(ctx context.Context, db string, body TigrisCreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateDatabaseResponse, error)

	// TigrisDescribeDatabase request with any body
	TigrisDescribeDatabaseWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error)

	TigrisDescribeDatabaseWithResponse(ctx context.Context, db string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error)

	// TigrisDropDatabase request with any body
	TigrisDropDatabaseWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDropDatabaseResponse, error)

	TigrisDropDatabaseWithResponse(ctx context.Context, db string, body TigrisDropDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDropDatabaseResponse, error)

	// TigrisBeginTransaction request with any body
	TigrisBeginTransactionWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error)

	TigrisBeginTransactionWithResponse(ctx context.Context, db string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error)

	// TigrisCommitTransaction request with any body
	TigrisCommitTransactionWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error)

	TigrisCommitTransactionWithResponse(ctx context.Context, db string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error)

	// TigrisRollbackTransaction request with any body
	TigrisRollbackTransactionWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error)

	TigrisRollbackTransactionWithResponse(ctx context.Context, db string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error)

	// HealthAPIHealth request
	HealthAPIHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthAPIHealthResponse, error)

	// TigrisGetInfo request
	TigrisGetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TigrisGetInfoResponse, error)

	// ObservabilityQueryTimeSeriesMetrics request with any body
	ObservabilityQueryTimeSeriesMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error)

	ObservabilityQueryTimeSeriesMetricsWithResponse(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error)

	// UserGetUserMetadata request with any body
	UserGetUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserGetUserMetadataResponse, error)

	UserGetUserMetadataWithResponse(ctx context.Context, metadataKey string, body UserGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UserGetUserMetadataResponse, error)

	// UserInsertUserMetadata request with any body
	UserInsertUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserInsertUserMetadataResponse, error)

	UserInsertUserMetadataWithResponse(ctx context.Context, metadataKey string, body UserInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UserInsertUserMetadataResponse, error)

	// UserUpdateUserMetadata request with any body
	UserUpdateUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateUserMetadataResponse, error)

	UserUpdateUserMetadataWithResponse(ctx context.Context, metadataKey string, body UserUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateUserMetadataResponse, error)
}

type AdminListNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNamespacesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r AdminListNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminListNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AdminCreateNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateNamespaceResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r AdminCreateNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AdminCreateNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserCreateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateApplicationResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserCreateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserCreateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserDeleteApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteApplicationResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserDeleteApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserDeleteApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserListApplicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListApplicationsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserListApplicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserListApplicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserRotateApplicationSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RotateApplicationSecretResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserRotateApplicationSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserRotateApplicationSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateApplicationResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserUpdateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthGetAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccessTokenResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r AuthGetAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthGetAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisListDatabasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListDatabasesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisListDatabasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisListDatabasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisListCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCollectionsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisListCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisListCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCreateOrUpdateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateOrUpdateCollectionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCreateOrUpdateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCreateOrUpdateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDescribeCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeCollectionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDescribeCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDescribeCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisInsertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsertResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisInsertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisInsertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamingReadResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisReplaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReplaceResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisReplaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisReplaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamingSearchResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDropCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DropCollectionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDropCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDropCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamingEventsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisPublishResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublishResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisPublishResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisPublishResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisSubscribeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamingSubscribeResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisSubscribeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisSubscribeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateDatabaseResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDescribeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeDatabaseResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDescribeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDescribeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDropDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DropDatabaseResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDropDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDropDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisBeginTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BeginTransactionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisBeginTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisBeginTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCommitTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitTransactionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCommitTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCommitTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisRollbackTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RollbackTransactionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisRollbackTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisRollbackTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthAPIHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthCheckResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r HealthAPIHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthAPIHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisGetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInfoResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisGetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisGetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservabilityQueryTimeSeriesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryTimeSeriesMetricsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ObservabilityQueryTimeSeriesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservabilityQueryTimeSeriesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserGetUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserGetUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserGetUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserInsertUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsertUserMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserInsertUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserInsertUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r UserUpdateUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AdminListNamespacesWithResponse request returning *AdminListNamespacesResponse
func (c *ClientWithResponses) AdminListNamespacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AdminListNamespacesResponse, error) {
	rsp, err := c.AdminListNamespaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminListNamespacesResponse(rsp)
}

// AdminCreateNamespaceWithBodyWithResponse request with arbitrary body returning *AdminCreateNamespaceResponse
func (c *ClientWithResponses) AdminCreateNamespaceWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AdminCreateNamespaceResponse, error) {
	rsp, err := c.AdminCreateNamespaceWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminCreateNamespaceResponse(rsp)
}

func (c *ClientWithResponses) AdminCreateNamespaceWithResponse(ctx context.Context, name string, body AdminCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*AdminCreateNamespaceResponse, error) {
	rsp, err := c.AdminCreateNamespace(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAdminCreateNamespaceResponse(rsp)
}

// UserCreateApplicationWithBodyWithResponse request with arbitrary body returning *UserCreateApplicationResponse
func (c *ClientWithResponses) UserCreateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateApplicationResponse, error) {
	rsp, err := c.UserCreateApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateApplicationResponse(rsp)
}

func (c *ClientWithResponses) UserCreateApplicationWithResponse(ctx context.Context, body UserCreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateApplicationResponse, error) {
	rsp, err := c.UserCreateApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateApplicationResponse(rsp)
}

// UserDeleteApplicationWithBodyWithResponse request with arbitrary body returning *UserDeleteApplicationResponse
func (c *ClientWithResponses) UserDeleteApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserDeleteApplicationResponse, error) {
	rsp, err := c.UserDeleteApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserDeleteApplicationResponse(rsp)
}

func (c *ClientWithResponses) UserDeleteApplicationWithResponse(ctx context.Context, body UserDeleteApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UserDeleteApplicationResponse, error) {
	rsp, err := c.UserDeleteApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserDeleteApplicationResponse(rsp)
}

// UserListApplicationsWithBodyWithResponse request with arbitrary body returning *UserListApplicationsResponse
func (c *ClientWithResponses) UserListApplicationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserListApplicationsResponse, error) {
	rsp, err := c.UserListApplicationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserListApplicationsResponse(rsp)
}

func (c *ClientWithResponses) UserListApplicationsWithResponse(ctx context.Context, body UserListApplicationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UserListApplicationsResponse, error) {
	rsp, err := c.UserListApplications(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserListApplicationsResponse(rsp)
}

// UserRotateApplicationSecretWithBodyWithResponse request with arbitrary body returning *UserRotateApplicationSecretResponse
func (c *ClientWithResponses) UserRotateApplicationSecretWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserRotateApplicationSecretResponse, error) {
	rsp, err := c.UserRotateApplicationSecretWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserRotateApplicationSecretResponse(rsp)
}

func (c *ClientWithResponses) UserRotateApplicationSecretWithResponse(ctx context.Context, body UserRotateApplicationSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*UserRotateApplicationSecretResponse, error) {
	rsp, err := c.UserRotateApplicationSecret(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserRotateApplicationSecretResponse(rsp)
}

// UserUpdateApplicationWithBodyWithResponse request with arbitrary body returning *UserUpdateApplicationResponse
func (c *ClientWithResponses) UserUpdateApplicationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateApplicationResponse, error) {
	rsp, err := c.UserUpdateApplicationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateApplicationResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateApplicationWithResponse(ctx context.Context, body UserUpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateApplicationResponse, error) {
	rsp, err := c.UserUpdateApplication(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateApplicationResponse(rsp)
}

// AuthGetAccessTokenWithBodyWithResponse request with arbitrary body returning *AuthGetAccessTokenResponse
func (c *ClientWithResponses) AuthGetAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGetAccessTokenResponse, error) {
	rsp, err := c.AuthGetAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGetAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) AuthGetAccessTokenWithResponse(ctx context.Context, body AuthGetAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AuthGetAccessTokenResponse, error) {
	rsp, err := c.AuthGetAccessToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGetAccessTokenResponse(rsp)
}

// TigrisListDatabasesWithResponse request returning *TigrisListDatabasesResponse
func (c *ClientWithResponses) TigrisListDatabasesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TigrisListDatabasesResponse, error) {
	rsp, err := c.TigrisListDatabases(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisListDatabasesResponse(rsp)
}

// TigrisListCollectionsWithBodyWithResponse request with arbitrary body returning *TigrisListCollectionsResponse
func (c *ClientWithResponses) TigrisListCollectionsWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisListCollectionsResponse, error) {
	rsp, err := c.TigrisListCollectionsWithBody(ctx, db, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisListCollectionsResponse(rsp)
}

func (c *ClientWithResponses) TigrisListCollectionsWithResponse(ctx context.Context, db string, body TigrisListCollectionsJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisListCollectionsResponse, error) {
	rsp, err := c.TigrisListCollections(ctx, db, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisListCollectionsResponse(rsp)
}

// TigrisCreateOrUpdateCollectionWithBodyWithResponse request with arbitrary body returning *TigrisCreateOrUpdateCollectionResponse
func (c *ClientWithResponses) TigrisCreateOrUpdateCollectionWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error) {
	rsp, err := c.TigrisCreateOrUpdateCollectionWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateOrUpdateCollectionResponse(rsp)
}

func (c *ClientWithResponses) TigrisCreateOrUpdateCollectionWithResponse(ctx context.Context, db string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error) {
	rsp, err := c.TigrisCreateOrUpdateCollection(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateOrUpdateCollectionResponse(rsp)
}

// TigrisDescribeCollectionWithBodyWithResponse request with arbitrary body returning *TigrisDescribeCollectionResponse
func (c *ClientWithResponses) TigrisDescribeCollectionWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error) {
	rsp, err := c.TigrisDescribeCollectionWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeCollectionResponse(rsp)
}

func (c *ClientWithResponses) TigrisDescribeCollectionWithResponse(ctx context.Context, db string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error) {
	rsp, err := c.TigrisDescribeCollection(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeCollectionResponse(rsp)
}

// TigrisDeleteWithBodyWithResponse request with arbitrary body returning *TigrisDeleteResponse
func (c *ClientWithResponses) TigrisDeleteWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error) {
	rsp, err := c.TigrisDeleteWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteResponse(rsp)
}

func (c *ClientWithResponses) TigrisDeleteWithResponse(ctx context.Context, db string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error) {
	rsp, err := c.TigrisDelete(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteResponse(rsp)
}

// TigrisInsertWithBodyWithResponse request with arbitrary body returning *TigrisInsertResponse
func (c *ClientWithResponses) TigrisInsertWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error) {
	rsp, err := c.TigrisInsertWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisInsertResponse(rsp)
}

func (c *ClientWithResponses) TigrisInsertWithResponse(ctx context.Context, db string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error) {
	rsp, err := c.TigrisInsert(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisInsertResponse(rsp)
}

// TigrisReadWithBodyWithResponse request with arbitrary body returning *TigrisReadResponse
func (c *ClientWithResponses) TigrisReadWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error) {
	rsp, err := c.TigrisReadWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReadResponse(rsp)
}

func (c *ClientWithResponses) TigrisReadWithResponse(ctx context.Context, db string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error) {
	rsp, err := c.TigrisRead(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReadResponse(rsp)
}

// TigrisReplaceWithBodyWithResponse request with arbitrary body returning *TigrisReplaceResponse
func (c *ClientWithResponses) TigrisReplaceWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error) {
	rsp, err := c.TigrisReplaceWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReplaceResponse(rsp)
}

func (c *ClientWithResponses) TigrisReplaceWithResponse(ctx context.Context, db string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error) {
	rsp, err := c.TigrisReplace(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReplaceResponse(rsp)
}

// TigrisSearchWithBodyWithResponse request with arbitrary body returning *TigrisSearchResponse
func (c *ClientWithResponses) TigrisSearchWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error) {
	rsp, err := c.TigrisSearchWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisSearchResponse(rsp)
}

func (c *ClientWithResponses) TigrisSearchWithResponse(ctx context.Context, db string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error) {
	rsp, err := c.TigrisSearch(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisSearchResponse(rsp)
}

// TigrisUpdateWithBodyWithResponse request with arbitrary body returning *TigrisUpdateResponse
func (c *ClientWithResponses) TigrisUpdateWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error) {
	rsp, err := c.TigrisUpdateWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisUpdateResponse(rsp)
}

func (c *ClientWithResponses) TigrisUpdateWithResponse(ctx context.Context, db string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error) {
	rsp, err := c.TigrisUpdate(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisUpdateResponse(rsp)
}

// TigrisDropCollectionWithBodyWithResponse request with arbitrary body returning *TigrisDropCollectionResponse
func (c *ClientWithResponses) TigrisDropCollectionWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error) {
	rsp, err := c.TigrisDropCollectionWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDropCollectionResponse(rsp)
}

func (c *ClientWithResponses) TigrisDropCollectionWithResponse(ctx context.Context, db string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error) {
	rsp, err := c.TigrisDropCollection(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDropCollectionResponse(rsp)
}

// TigrisEventsWithBodyWithResponse request with arbitrary body returning *TigrisEventsResponse
func (c *ClientWithResponses) TigrisEventsWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisEventsResponse, error) {
	rsp, err := c.TigrisEventsWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisEventsResponse(rsp)
}

func (c *ClientWithResponses) TigrisEventsWithResponse(ctx context.Context, db string, collection string, body TigrisEventsJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisEventsResponse, error) {
	rsp, err := c.TigrisEvents(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisEventsResponse(rsp)
}

// TigrisPublishWithBodyWithResponse request with arbitrary body returning *TigrisPublishResponse
func (c *ClientWithResponses) TigrisPublishWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisPublishResponse, error) {
	rsp, err := c.TigrisPublishWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisPublishResponse(rsp)
}

func (c *ClientWithResponses) TigrisPublishWithResponse(ctx context.Context, db string, collection string, body TigrisPublishJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisPublishResponse, error) {
	rsp, err := c.TigrisPublish(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisPublishResponse(rsp)
}

// TigrisSubscribeWithBodyWithResponse request with arbitrary body returning *TigrisSubscribeResponse
func (c *ClientWithResponses) TigrisSubscribeWithBodyWithResponse(ctx context.Context, db string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisSubscribeResponse, error) {
	rsp, err := c.TigrisSubscribeWithBody(ctx, db, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisSubscribeResponse(rsp)
}

func (c *ClientWithResponses) TigrisSubscribeWithResponse(ctx context.Context, db string, collection string, body TigrisSubscribeJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisSubscribeResponse, error) {
	rsp, err := c.TigrisSubscribe(ctx, db, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisSubscribeResponse(rsp)
}

// TigrisCreateDatabaseWithBodyWithResponse request with arbitrary body returning *TigrisCreateDatabaseResponse
func (c *ClientWithResponses) TigrisCreateDatabaseWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateDatabaseResponse, error) {
	rsp, err := c.TigrisCreateDatabaseWithBody(ctx, db, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) TigrisCreateDatabaseWithResponse(ctx context.Context, db string, body TigrisCreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateDatabaseResponse, error) {
	rsp, err := c.TigrisCreateDatabase(ctx, db, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateDatabaseResponse(rsp)
}

// TigrisDescribeDatabaseWithBodyWithResponse request with arbitrary body returning *TigrisDescribeDatabaseResponse
func (c *ClientWithResponses) TigrisDescribeDatabaseWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error) {
	rsp, err := c.TigrisDescribeDatabaseWithBody(ctx, db, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeDatabaseResponse(rsp)
}

func (c *ClientWithResponses) TigrisDescribeDatabaseWithResponse(ctx context.Context, db string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error) {
	rsp, err := c.TigrisDescribeDatabase(ctx, db, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeDatabaseResponse(rsp)
}

// TigrisDropDatabaseWithBodyWithResponse request with arbitrary body returning *TigrisDropDatabaseResponse
func (c *ClientWithResponses) TigrisDropDatabaseWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDropDatabaseResponse, error) {
	rsp, err := c.TigrisDropDatabaseWithBody(ctx, db, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDropDatabaseResponse(rsp)
}

func (c *ClientWithResponses) TigrisDropDatabaseWithResponse(ctx context.Context, db string, body TigrisDropDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDropDatabaseResponse, error) {
	rsp, err := c.TigrisDropDatabase(ctx, db, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDropDatabaseResponse(rsp)
}

// TigrisBeginTransactionWithBodyWithResponse request with arbitrary body returning *TigrisBeginTransactionResponse
func (c *ClientWithResponses) TigrisBeginTransactionWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error) {
	rsp, err := c.TigrisBeginTransactionWithBody(ctx, db, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisBeginTransactionResponse(rsp)
}

func (c *ClientWithResponses) TigrisBeginTransactionWithResponse(ctx context.Context, db string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error) {
	rsp, err := c.TigrisBeginTransaction(ctx, db, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisBeginTransactionResponse(rsp)
}

// TigrisCommitTransactionWithBodyWithResponse request with arbitrary body returning *TigrisCommitTransactionResponse
func (c *ClientWithResponses) TigrisCommitTransactionWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error) {
	rsp, err := c.TigrisCommitTransactionWithBody(ctx, db, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCommitTransactionResponse(rsp)
}

func (c *ClientWithResponses) TigrisCommitTransactionWithResponse(ctx context.Context, db string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error) {
	rsp, err := c.TigrisCommitTransaction(ctx, db, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCommitTransactionResponse(rsp)
}

// TigrisRollbackTransactionWithBodyWithResponse request with arbitrary body returning *TigrisRollbackTransactionResponse
func (c *ClientWithResponses) TigrisRollbackTransactionWithBodyWithResponse(ctx context.Context, db string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error) {
	rsp, err := c.TigrisRollbackTransactionWithBody(ctx, db, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisRollbackTransactionResponse(rsp)
}

func (c *ClientWithResponses) TigrisRollbackTransactionWithResponse(ctx context.Context, db string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error) {
	rsp, err := c.TigrisRollbackTransaction(ctx, db, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisRollbackTransactionResponse(rsp)
}

// HealthAPIHealthWithResponse request returning *HealthAPIHealthResponse
func (c *ClientWithResponses) HealthAPIHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthAPIHealthResponse, error) {
	rsp, err := c.HealthAPIHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthAPIHealthResponse(rsp)
}

// TigrisGetInfoWithResponse request returning *TigrisGetInfoResponse
func (c *ClientWithResponses) TigrisGetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TigrisGetInfoResponse, error) {
	rsp, err := c.TigrisGetInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisGetInfoResponse(rsp)
}

// ObservabilityQueryTimeSeriesMetricsWithBodyWithResponse request with arbitrary body returning *ObservabilityQueryTimeSeriesMetricsResponse
func (c *ClientWithResponses) ObservabilityQueryTimeSeriesMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error) {
	rsp, err := c.ObservabilityQueryTimeSeriesMetricsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQueryTimeSeriesMetricsResponse(rsp)
}

func (c *ClientWithResponses) ObservabilityQueryTimeSeriesMetricsWithResponse(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error) {
	rsp, err := c.ObservabilityQueryTimeSeriesMetrics(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQueryTimeSeriesMetricsResponse(rsp)
}

// UserGetUserMetadataWithBodyWithResponse request with arbitrary body returning *UserGetUserMetadataResponse
func (c *ClientWithResponses) UserGetUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserGetUserMetadataResponse, error) {
	rsp, err := c.UserGetUserMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) UserGetUserMetadataWithResponse(ctx context.Context, metadataKey string, body UserGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UserGetUserMetadataResponse, error) {
	rsp, err := c.UserGetUserMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserGetUserMetadataResponse(rsp)
}

// UserInsertUserMetadataWithBodyWithResponse request with arbitrary body returning *UserInsertUserMetadataResponse
func (c *ClientWithResponses) UserInsertUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserInsertUserMetadataResponse, error) {
	rsp, err := c.UserInsertUserMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserInsertUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) UserInsertUserMetadataWithResponse(ctx context.Context, metadataKey string, body UserInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UserInsertUserMetadataResponse, error) {
	rsp, err := c.UserInsertUserMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserInsertUserMetadataResponse(rsp)
}

// UserUpdateUserMetadataWithBodyWithResponse request with arbitrary body returning *UserUpdateUserMetadataResponse
func (c *ClientWithResponses) UserUpdateUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateUserMetadataResponse, error) {
	rsp, err := c.UserUpdateUserMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateUserMetadataWithResponse(ctx context.Context, metadataKey string, body UserUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateUserMetadataResponse, error) {
	rsp, err := c.UserUpdateUserMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateUserMetadataResponse(rsp)
}

// ParseAdminListNamespacesResponse parses an HTTP response from a AdminListNamespacesWithResponse call
func ParseAdminListNamespacesResponse(rsp *http.Response) (*AdminListNamespacesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminListNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNamespacesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAdminCreateNamespaceResponse parses an HTTP response from a AdminCreateNamespaceWithResponse call
func ParseAdminCreateNamespaceResponse(rsp *http.Response) (*AdminCreateNamespaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AdminCreateNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateNamespaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserCreateApplicationResponse parses an HTTP response from a UserCreateApplicationWithResponse call
func ParseUserCreateApplicationResponse(rsp *http.Response) (*UserCreateApplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserCreateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateApplicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserDeleteApplicationResponse parses an HTTP response from a UserDeleteApplicationWithResponse call
func ParseUserDeleteApplicationResponse(rsp *http.Response) (*UserDeleteApplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserDeleteApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteApplicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserListApplicationsResponse parses an HTTP response from a UserListApplicationsWithResponse call
func ParseUserListApplicationsResponse(rsp *http.Response) (*UserListApplicationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserListApplicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListApplicationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserRotateApplicationSecretResponse parses an HTTP response from a UserRotateApplicationSecretWithResponse call
func ParseUserRotateApplicationSecretResponse(rsp *http.Response) (*UserRotateApplicationSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserRotateApplicationSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RotateApplicationSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserUpdateApplicationResponse parses an HTTP response from a UserUpdateApplicationWithResponse call
func ParseUserUpdateApplicationResponse(rsp *http.Response) (*UserUpdateApplicationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateApplicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAuthGetAccessTokenResponse parses an HTTP response from a AuthGetAccessTokenWithResponse call
func ParseAuthGetAccessTokenResponse(rsp *http.Response) (*AuthGetAccessTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthGetAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccessTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisListDatabasesResponse parses an HTTP response from a TigrisListDatabasesWithResponse call
func ParseTigrisListDatabasesResponse(rsp *http.Response) (*TigrisListDatabasesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisListDatabasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListDatabasesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisListCollectionsResponse parses an HTTP response from a TigrisListCollectionsWithResponse call
func ParseTigrisListCollectionsResponse(rsp *http.Response) (*TigrisListCollectionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisListCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCollectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCreateOrUpdateCollectionResponse parses an HTTP response from a TigrisCreateOrUpdateCollectionWithResponse call
func ParseTigrisCreateOrUpdateCollectionResponse(rsp *http.Response) (*TigrisCreateOrUpdateCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCreateOrUpdateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateOrUpdateCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDescribeCollectionResponse parses an HTTP response from a TigrisDescribeCollectionWithResponse call
func ParseTigrisDescribeCollectionResponse(rsp *http.Response) (*TigrisDescribeCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDescribeCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDeleteResponse parses an HTTP response from a TigrisDeleteWithResponse call
func ParseTigrisDeleteResponse(rsp *http.Response) (*TigrisDeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisInsertResponse parses an HTTP response from a TigrisInsertWithResponse call
func ParseTigrisInsertResponse(rsp *http.Response) (*TigrisInsertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisInsertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisReadResponse parses an HTTP response from a TigrisReadWithResponse call
func ParseTigrisReadResponse(rsp *http.Response) (*TigrisReadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamingReadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisReplaceResponse parses an HTTP response from a TigrisReplaceWithResponse call
func ParseTigrisReplaceResponse(rsp *http.Response) (*TigrisReplaceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisReplaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReplaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisSearchResponse parses an HTTP response from a TigrisSearchWithResponse call
func ParseTigrisSearchResponse(rsp *http.Response) (*TigrisSearchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamingSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisUpdateResponse parses an HTTP response from a TigrisUpdateWithResponse call
func ParseTigrisUpdateResponse(rsp *http.Response) (*TigrisUpdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDropCollectionResponse parses an HTTP response from a TigrisDropCollectionWithResponse call
func ParseTigrisDropCollectionResponse(rsp *http.Response) (*TigrisDropCollectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDropCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DropCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisEventsResponse parses an HTTP response from a TigrisEventsWithResponse call
func ParseTigrisEventsResponse(rsp *http.Response) (*TigrisEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamingEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisPublishResponse parses an HTTP response from a TigrisPublishWithResponse call
func ParseTigrisPublishResponse(rsp *http.Response) (*TigrisPublishResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisPublishResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublishResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisSubscribeResponse parses an HTTP response from a TigrisSubscribeWithResponse call
func ParseTigrisSubscribeResponse(rsp *http.Response) (*TigrisSubscribeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisSubscribeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamingSubscribeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCreateDatabaseResponse parses an HTTP response from a TigrisCreateDatabaseWithResponse call
func ParseTigrisCreateDatabaseResponse(rsp *http.Response) (*TigrisCreateDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateDatabaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDescribeDatabaseResponse parses an HTTP response from a TigrisDescribeDatabaseWithResponse call
func ParseTigrisDescribeDatabaseResponse(rsp *http.Response) (*TigrisDescribeDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDescribeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeDatabaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDropDatabaseResponse parses an HTTP response from a TigrisDropDatabaseWithResponse call
func ParseTigrisDropDatabaseResponse(rsp *http.Response) (*TigrisDropDatabaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDropDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DropDatabaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisBeginTransactionResponse parses an HTTP response from a TigrisBeginTransactionWithResponse call
func ParseTigrisBeginTransactionResponse(rsp *http.Response) (*TigrisBeginTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisBeginTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BeginTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCommitTransactionResponse parses an HTTP response from a TigrisCommitTransactionWithResponse call
func ParseTigrisCommitTransactionResponse(rsp *http.Response) (*TigrisCommitTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCommitTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisRollbackTransactionResponse parses an HTTP response from a TigrisRollbackTransactionWithResponse call
func ParseTigrisRollbackTransactionResponse(rsp *http.Response) (*TigrisRollbackTransactionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisRollbackTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RollbackTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHealthAPIHealthResponse parses an HTTP response from a HealthAPIHealthWithResponse call
func ParseHealthAPIHealthResponse(rsp *http.Response) (*HealthAPIHealthResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthAPIHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthCheckResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisGetInfoResponse parses an HTTP response from a TigrisGetInfoWithResponse call
func ParseTigrisGetInfoResponse(rsp *http.Response) (*TigrisGetInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisGetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObservabilityQueryTimeSeriesMetricsResponse parses an HTTP response from a ObservabilityQueryTimeSeriesMetricsWithResponse call
func ParseObservabilityQueryTimeSeriesMetricsResponse(rsp *http.Response) (*ObservabilityQueryTimeSeriesMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservabilityQueryTimeSeriesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryTimeSeriesMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserGetUserMetadataResponse parses an HTTP response from a UserGetUserMetadataWithResponse call
func ParseUserGetUserMetadataResponse(rsp *http.Response) (*UserGetUserMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserGetUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserInsertUserMetadataResponse parses an HTTP response from a UserInsertUserMetadataWithResponse call
func ParseUserInsertUserMetadataResponse(rsp *http.Response) (*UserInsertUserMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserInsertUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsertUserMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUserUpdateUserMetadataResponse parses an HTTP response from a UserUpdateUserMetadataWithResponse call
func ParseUserUpdateUserMetadataResponse(rsp *http.Response) (*UserUpdateUserMetadataResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9/W7bOLb4qxDaAe7MwrU7M4sL3AC/PzyJ2/o3adIbJzu7qAuHlmibW1nUkFQSTxFg",
	"H+Tel5snueAhKVESJcvOV72z/xSpxY9D8vDwfJ8vQcjWKUtIIkVw9CUQ4YqsMfw5jCIqKUtw/CZLQvWX",
	"+jUiIuQ01f912qCFaYQkQzhN4w1iCVoTyWko0K8Z4ZugF6ScpYRLSmAGzuI4S9Vf33CyCI6CPw0KaAYG",
	"lMEFtMphuL/vBXKTkuAoYPN/kFAG971gmKYxDXEDkAnKBOEAlW1UBSXkBEsSzbCs9z/W3xCWQS9YML5W",
	"jQKayP/8S5DDQhNJloQrYOxY803zWPNN0VVITpOl6llqW1sGWmVrnCBOcITnMVHrQW4Tz4A0qo/zliSE",
	"AxBhTEkiEY18XRO8Jh2BgKaeIQQJOZFtEKjeppWnf5ZGjYdypb91PhQ7lu9Q7Fi+Q/Fh209kSZNLjhOB",
	"AScvyK8ZER4gJxJziRJyi2TRGtEERVjiORYEiZSEdEFhcjQNovk06NeQk8F4YttFcSA6Nz06gi9SlgjS",
	"BL8LOycy44ko/RayRJI7idDtioYrlCX014zEG0Qjkki1OIHkirhdaiuUd7NQ3u2wwGN551/cMYvjJjqA",
	"QvsR4ThmtwJtWKbolT6FDdKHjtTUmFOh1pvFRPTRCVngLJaIChRiQV4Jkggq6Q3pqe7shnBOI4KohBFD",
	"nCBBJJIrKpA+PNXsP0L6H0iusES3NI4NkVTUMo71BqlNXFASR0LhiPppQWNJuKijhIICNm47tqodIbBp",
	"J2XyUhkxb1bfuTO8JogtAKSiXd93Z9dEYoXd286ygOq97aEoBnz1kM28tUCmjXPr/yH81E/Q30jbWEg1",
	"UFs930giutCR9v0dJwu228Y6sCgi+ug72g7ve2fklmbnBflphJ5rEijQmkV0sVG3yFAtZ03u4Os1lV1I",
	"qG5Zoje3VK4AFZf0hiRofNJxhoLKlQ9ISCwz4aV+MhMK78M6EGoA3HALvLsOD7/DpzSu2HxAwEbAVIvt",
	"/Mujcw4Pfv47bkLT01Nrmj89oWXHurBzZb6w7fq4LGQL8Cfm5XaOb6/H2o7T+lJXp2zC4DURAi+95xUR",
	"iWlMIsRNb2Qae2lN01UYJogk2VpfvRscZwQeOCzQ1O61Zlw6I4F6UkSKw+aN9PGuQ8NdAM5Bd0SjfoVy",
	"//hDV8pdheRfaH/PueZqCxrdjLFJvJnpWeqQjRealWFI8owosqs5E81Pm8fYkn9oVuIRNKuzwDRWDK6+",
	"wupxwIprXMQ0lHrN7y4vPyBDcEMWEfSX1//VR5crgqKC9VrgWLj7OmcsJjhRi+546+qPWgvTMdFrM3xP",
	"xMJsrQbTvJniBAtOCCA1e2FYek1KBMKcIKH4JyzQ/5+cn3mbqVXShERomr1+/WOI0YqTxf+bBispU3E0",
	"GCgO55Xu2Gd8OSh17q/kOp4GSFIZE9WJcDINYCQCf8OYA6x/6Zs5Uv1f89H8Ty1jwRRvrA6JCqQ4WQ0v",
	"ucPrNCZH6PoLQtMAJpsGR2gaqMdpGvTUr84G6m8Oi8AWzh7Coeu7I+wDJ8wgBXaqMb4gpH6kUf4f70Q5",
	"ZcilDo4WjGtctQDqvgp7dCdDHaaB+nDf058VaWmfy2WHG8fWV9T5tMZ3pyRZypX6/v3r1+6ccxzjJNwy",
	"7RUwAWHIskSivIdn6iRbz/NV6UnUrtI15pvZZ7JRrT7qLf2E7q+3s9K7kZmvm4oixhXOapF/GnRbrHqC",
	"PzCaeNm1lBMBSA1kAkuMUtUU6ARdE0E4JR4RDr5JvAYFWAcNBiyo1DZi2Tx2WC997s0rUEyEX0aJ5vWF",
	"2R4Pl0zsSO1ySa2VTyqpsk3NUO8okZyQmHRkTWtNC62IIp8xXqp3MGTJDdkgunAZVXSLBYqgf+Th4fXv",
	"tQk1vuuRFU3TDQsRxPMi3ndZotgqg8BMhnjjpJXl9rFr7sp9WsZmKBuZFa0RaToU94UBZdQay3Clzr5Q",
	"tOkR+mho/tLqGrpO4w2aE/SZbHqGeNyq11P9oF5CrY4hcQT3AeEksq1YFkeqp2qhf9IPj+JYVIc+OucI",
	"u7PNCYrZkoY4NnPIW6bo0ppxYjVA5XbxBv2DAYeQCbWcbxgHEL7BSQRLIbf2hYb3VE92ZN76mOrnHV0y",
	"izxYy5R2vywcK/WAohUWCJu1fH+Erq+vv9gX+Ht0f3193TKuUWaVRhfO8Go79WDladT6f1D//KhYjGnw",
	"DePwThUz3/dQ/p8f3P/8eP+pyyvWmUssoWCrgOZt2WYlMRA41zjKKZVHy+cqM7fxtUZ07QW3nEoy67jW",
	"X1TjTmtsfta7vQJ2hJK+r+Elxy0vudm2zk83DDzvIgg9kgrU95i63a3yv/8AFPUIMl0X3/SsOVyY88Gz",
	"ZiOWFU1yzUzB7FukACIlc+HIj+JfrdrZlQDLAt/+6meQFOlvxDNqroru76uLtue9VUv1ABztNu9+WJbb",
	"xRTa2KcEC8FCqi2WhR2gj07asBTRJIyziFh7QS5sYoFuSRy3YaLoDDaes0zmgJage9gloZKsdyACrmWn",
	"OB/MOd48mCLtz+U3XYFJtgaGsr5tcDMEMhJVrmmx8O19LThLuyjCHpf2Vib9KsXiiLM03UG5qBb1rCrw",
	"8oT/Ens44pxx/8MAn5DqYTSCikG2ogKBj2sWkdhDvKKmt8ZRqlI1nFgxLntojZVgRFCKuQBTjga5t8WK",
	"T3II++iSLrmSjJhW38IUa5ymSkD5qBj+T98OOFkQTpKQDFZSpq9Um++CXqA2Mzj6GJz/HPSC4+HZ8ej0",
	"dHQS9IKrs5/Pzn85C3rB+Oyvw9PxyWx48fbq/ejsMugFJ6Phyen4bDQb/e14NDqBDmfnl7M351dn6u/h",
	"6cVoePL32ehv48nlJOgFH0YX78eTyfj8bHYyOhtDh4vR5Pzq4lgN8m54NbmEH98Mx6ejk9mHi9Hx+dnJ",
	"+HJ8rkAY/nR+ob+fX13Ozt/MLoZnb0cA5fj9h9ORAgs+j88uRxdnw1P4NPzrcHw6/OlUNTwZXg5np+eT",
	"if5ydfludHY5Ph7qbsfnZ29Ox8dqaT8NT2Zvh5ejX4Z/D3rB+9Hlu/OTmVrb8PT0/JfRSfDJoX2we15S",
	"3XINbkisMObVAofqgPIGN/ZQbe9uSHyj7nJHVrqBRd6X+S3N3Uo9vC19eiXbsInAEPV9G1wTyQlew1B+",
	"cN7gkMhjliXeHTM/76IK7HBQMOdEYtkumCoyocXSheoAehIS15VU+GbpGeeGcLwk9lEH8MBOgnMNSBJv",
	"EL7BNAZao+ZJsjXhNDT6Dvdpb9Jr9opNqtA5JnGMdDMFRA2Abj5ia3xXH/s9vqPrgmF5urWtqUcEek+T",
	"55ldKHrcwqg91cw+lH1L5DAMiRCX7DPZ6iih3yUMHZBUPdB8Y126FKVbcpzImZrliJMFJ2I1082m2evX",
	"P/wnKv/IuNtBu0jOQk7gGcSxsL0+mk806hlHypn2ZPxUf5xty/oaQizIEarPcoSGastphNypv22as4dw",
	"FlH1zH7nexdKbb2Ut1gyUDvzOl+M3lyMJu9ml+c/j9R7eHw6Hp1dzo4vRifqGRueTjo9S6UNbtqDUqNi",
	"+eZnfbDdnqYq+jSJouV2uYCW84khSySm2lwN7QyGKGlNv1Sgly2vrkYvnZ5ettJFXC9LSu5SyomY+cjD",
	"0MV6aKiV7ZKuiZJMaYIECVkSiS4+EltP6sI9jH7n0xgnC9bifkX4DeGzG8KFn11oGPVKEG5lza2GDFBH",
	"55Jsr0GF+TPZeG9H9b21cHSCrAn9rlyQcqzbGbbcE2YclbiHrPmU1Wbo1g9a6TuCY7k6XpHwc/PpcudL",
	"h3MdJ4Jw2ay2sgYFz1XgHG/KTgaSIQrj9dEIh6vC2AFyEDhj6JlLGpeter2qdqUj11paWivX6m1Z15H7",
	"rQp6xS1GhUc2D1hgmxDgM9n4FfywfyXTqZarjU7K+Csg1d9/PvONJF3O5ykMFG36AH0C3S0Uegd3Imd6",
	"Ctc59Flomw/SJvI2bgTxEGndKRVyJ8t5TIUEn4NCz+law+WKCQK+YTdUUMU+S2bvrGY4JONBJ0CaDqDS",
	"Mr9pLCG5rdlOXgKNwXHVORlnVjD4d1FRl7xqq1ezaaMdb/9n0tXWZm2iZq1GAjVK3RKhhKYFsxEdrqp9",
	"RyU/uO48rna/aS+sxrVlJ+yoW/Yhb9Z5wSVPpc44k3vxtoCck4/u+JsP2x2a9xDzOAGvr1Z3Me0YVnYT",
	"Q2rlEQL7VZpJHThZf8Mj64/WfSWFC5sHhRacrTvqnnRIp5egipClxPtFsk6j+7azfAJP7CXeHPdQDNXg",
	"DueD/YNXGfsBL2mCyxZAxblNCObh6qLpcQwzzolP+3Wm9V7cYpZ6P4AE6Q4oNao5TkQWy46SoN9yZ5Vh",
	"harNDIpSwmGifX3xP2TzmIrVIyuUjUq7fEtqc+/J0JdBbn1f/E1ri0wxl9Su8WHbuI0df2l2usPt+W9F",
	"+y7pmmhaqumq6KYOVBTVElgThF5naGoB7jvwNfXgeM9W7Ye0OxDjhROZnyvthpcjsC1dgc3s7Pxs1NF4",
	"pLZpZglg7fuvGU4kjcsuyIuYYenVJytaOcPLJSdLJ/C6egmb0aw8QGWNw7++DXrB+/GZ+nf4t6AXTK7e",
	"d1qlBJvlrPCddUc9PQX74PAk6AW/XIwvu23cAx63JhRv4um97Y08FQkbGUmFNtDWMH4HzNIZG7yvfM7Z",
	"dLopJXbIc84P2L0LgqMWR2EwQXhsRRC9mMffWH9btTcI5zqiUsw31v5CWzVDTc7JF0b0KlRTuV+ycRNu",
	"dUnGrlNyiik37rS4xTe50Kd08E82hnwcC2Yj49VJxuTOAKQgnW9QigV4H+ceCXeK5RDa4enU/Ghi1kG4",
	"BZlR87MeF2ftynz9DePXAPP1NziJrpvdmYXPnxkO89G9mfWoL+XLjN5oNDBnIYiUOi+BTV/AEoSViBDR",
	"GxplsOnq9GNyQ+K+gl8Q6TRX520XY/ZeEJLHQxhfNevfZhaKXcc6g5dUNEWoRSwUfU1c1WPfD9l6wG4I",
	"v6HkdgDE5E+loLVX33ePWHtE126HZLQybJ52tVttPuiUDsZdP1PSm2Qm6AS2znDIPTgFg9RoGsR0TaXa",
	"AwgVkZzp4yk46wLhtOZG5wgBN0GwmDyWuzgA4hPiIeS9I0hwX0ox8R3eGLZYCF9+mKESXQTTAXyZgBQN",
	"aS40aXRNyJ1EAhwuhA4y1SA5MOKFQlmdhANmKoHVxO6KzzRtlLGq5gXVGM3JQhE1IRX3niy1Jg9g0UcP",
	"3ja2196uvRoj27QxHgyF3q4hs+Ikm792Xa7YQxh/tRNr0mIGVWvnCY71UwfXSJ2+c+zbD8+/bWncFmW+",
	"s0VprpAdxoy+CrNSeYFbiJqvaddwFbPq57Ms5eD+sUxLbbEvFvO6mpZq89Zme4eFa5iJwc3ehPEXeC8k",
	"4yTq75Q2TYkpCEvjT+qOB1GQ1ko2KG7Te4JFxkmk6H2CE/bK+C4gQZNQc1xXCb1DJGXhqkQPIizJKyXz",
	"+7OqQcDQPkCark8GWluGsy2gma5PBJoXmVgcz3H4uUvaHtt298Q93ln2T93DfYDsmrynkoLQu9osLVIg",
	"5moPTXxETEMtx9h8iC77xDhVb1ysdf0gCMVE6txkGlAC8lMxkJab7CQmEjRkiZA8C40CbE6XS8J1DzXz",
	"hmUchStm/gvP7Q2O0bdFYGzhLPRd/aYXs5V0Teenp1cfZsO3by9Gb4eX5xezydX7oOf53aqj6l+0Fsfz",
	"O+h16r8P//q2k1rGLnF/9QKT5RREE/Cf22r65ayQncpB00WuQ58RoxMiNoDUpDCqdciBdB7HhNyWg9TV",
	"PYVVkKgJ5MfMrKQNH+Co3OAX3V3d5LhY+5SK1g966xDaY7oF3HdUdmXDh6FUMrqAfjkVf0yWOwdJPfRb",
	"oIYmnjxrICM0MwMG+hWVPVB20ERDX4TB5c9TwRUMigeuJfDuEJiIg3qp9Vm7TF9FN8qyJNruRm+O3Jr4",
	"cMiZAGUoWPpENyE/NTbQVkuaagO6YInjWWotdt3MnNBJQ7SjlbN561rNkLurWMgdxKLOmnTSNUnT0eaC",
	"0GkG0Epqs8I+ujYxrmbc6x6iiyLRRQ9J/FkHU4YkIgrD2A3h6LoMzXVJAtoq8SwslS6vAGim4WAkKxig",
	"HHlYYrg+PatW4jg6a5urCca3mGeUaikWgkQopp+JVudcf5kGc44TkxNqCtZqnVYJ3d9fOxpaiLQ2+jXh",
	"oAtMI6qK8G46fnuGe5sDjHZXSBx+hp2RLFWnr7fP7phkaJFxuSIcJZhzdosidpu4KsU+mtA1jTFXba8d",
	"lWVfz9wpJ0YZh/bATTOAImo5XD9tbN62HtALo3TGnNjm0W5ol3o9Kc4LL3ywmJg0viDj46XxqZOckhvS",
	"R+OF/pEKk5yXJIgl8UY9aQ4m2DaWRe/mLqF6zfw+E1UgSVWrCvNbzZKRC6w7Rc/Nf/fD645OLL82WA5t",
	"gmO1WH3FtK8h0HUn/bA/mbdqvx1NzFFLhlLOQP1oLrMRb5aKy5A7Hb5gXG6fUQtB3BhDIecP4xIxHhEO",
	"8MBf7v1B1x+BeOAY841OnfaNmmMaoPtPe6ZFqzjxeIQEE12ihTXnKOrWWqBRZU+FD6UW21lCzVT7AFVY",
	"15mrLljeBiVYtwHaE4BNcmG+Entp46VbY0KhUcO4RVjmzn5Fhn/aSkY/a5flrRrEGAs3AstJYRl3HYKl",
	"XlB51/7yzoSi7aFO13tJk+XWgNkdDk2bB2LZNe7XzNkOYLu95CnAK83YDlydSjw9eJU5twCYzXVGl2eG",
	"sTatH8yi2UvEn1enb7ViNDVudv5r8M9rfu63+yR3OE4nd8AedKFSmqFZvTA+aUsw4ehoL3VuJF1agpZV",
	"ptUKFnn+YcUDiJV1eDFyg/G8zxUb364IVjzBdyDjZnOhOidFyJTqYHgFhngGvdd2FAuRMSVBZl8H7H6n",
	"vIhX2j0Z3DKU8L+MS4Pg2MLiTxEGCmOP0pvwGwIJjrBjTy3y4fZ3PsqHuj645ynIGieShv70mzqL7Eul",
	"x0/I7SMV19mW8bLFwdwPQ/fk+p4tfJrk+rkq7BFVwBr4nZ353phcmZa6KOGqkAhye5NJXqAJT0I0ns5J",
	"oZmbFDQD5q1a8fcW9fW6/p2WdGtaUpNP/tEd+ey4/wJpSUt3pJXn8Lbs6udhduwrz0pql/gUWUnhBaMk",
	"mjWkm7lwbWcexzDbv6O2Zh9HkDx/eX+Xx2G3lAkaD541wNgHZmP+BD98hxhdXEL3Lve0YLPgWpUua30+",
	"QcKMU7mBdKZ6L34imBM+zOQqr/oI6gj4uRhkJWUa3N+DmlhH35VB+9Of0Llx8p0mwLELm35TIMaXOKG/",
	"KW6CsyyJdJa44Yex0f6rvyD9SSpNaYycA1dviGVJ1JdXJAlZ5CTxc4cIGZgitUOmxEmEuZnLyX0HWxPT",
	"kBhc0mxYMExxuCLo1HzoBRmPzbrF0WCwpHKVzcGZufBtNn8O5jGbD9aYJoPT8fHobDLS8SUyJmATBJf6",
	"4YcxurAp8IJekGc5CV73X/e/19SfJDilwVHwY/91/0eFtliu4JQGN98PcLSmyaAIXR3E1HBITMiG2Fv1",
	"2uU9AphC+7soXA2GasRyzGzQyxN1wMQ/vH6tKX0ijdbMYfagGklRLHQbhW2IzgWsqkgVP2t3LVB4P9r8",
	"Rq3omc9GeOj0d9xVOYhsvcZ8YzZUlHdUXzO8FMHRxyI+NfikOnqP7Iv6+35Q1Njxn51myxXzoYSBvD+Y",
	"9ahEESMCJUwickdBg+451kpJI0AmjtdEEq6g7RLXqkRLQMHACiuBEULU9aScRMGR5Blx0yZXX6BPujER",
	"8icWbR7tKBtKR8HRloG7f0KEbiobdSgY7aCZXcM2hHZSP3TE4ornU7+GruqRr8mhwVPijUe78CKY4xPR",
	"Dw13KvlMXPwpqw4glYgfkbRzbVH5pLGoRxdUqhU3eSJUai6i8sy41Fyw5o+IS9uZIv2Gu/q5lsw7fhyr",
	"5t55IhRryjX0zAjWmGnokDg398DFXpil/WCbcYv7XXL3cLCtI1yDu+8T4d0Wf+dnRr9trs6HgoV6HTUq",
	"Z459L5TUmplmlDSakS7PZs1o8ES41WjfeWasajaSHAo+6RXs/2pmcjXIwzD9+POWgAqmnJp2miCRpSnj",
	"UoBdwEmSjD6W8sb2PPmMP9XF1Uyuyhl4nwj1/NmknxnvGnISHwrS+TDCmHxKCZr7aPIAHEGv0O0KMjG7",
	"Cbmp0KZl8NUsf8Iit/xT/ac6zV7uTOzJ3t2cthu8U3OMcG5TJlfF/cnz2XXRw1kewFqfSsnwytdB6wtL",
	"ufeeWilXT/J3UJydu0/2rIrfPAf2JZrfD5y8jF01qdV0jqXqRE7NqrK7iePB0XTSTsbJbYo6AKZcKaxU",
	"GalBcRfNvwa1XUNOzxeQZ3w5Pg8K6csosx/afyn+Y3XStoxzV920g4mMIyzZ2ngDZOmS48iwJ04rE0Sm",
	"+pp6bClnNzSq35dpgkzZvXCFkyUpJxJypsJJhOh6TSKKJYk3IFRBNbZkA5ESkq6JGg3MUiSJdFFmk1IH",
	"wHM8iLALbJ6DE3yYoNRRS810mALSMRmPCXfZm5QIyzdp3zV9/Y+mCVTtLvsrnJwfQ6mjyZF9R9HxxdWJ",
	"tpl5e7wfTSbDt6Oig0Afsvlgks11pwbq01S8exsZKtWEtt4TzHgNVeojPpwc9epehPnOAgD51A3zhe7C",
	"vhLrha9i+gsqo1sKuB+WHhEVrivuZXaopEs7d6aTkalw2UwhXa8QNzi2EkdbLqRKRdV90gYsOQUh1dKK",
	"kqHVe+a73/W6r9tudlPC6Ce4xc1lXb/6K9xcTPjZtf+NhX0P5draJaDjx7+s1hVrBxsT4orbKDty5T7f",
	"+bOjZV7jCK7dcmqcjPHkbLyaAMd+D60p7lHKJvYM7+yu839tl9Yp0v4yZroDvJxwK07y7GiOsJH/9oB7",
	"qRGp+THV1UMECAxt99F1FMMJGsac4GgzugODn14hXYBIYN82O9g0qUgeCOvO2r1G9JGGwV5vgWhE1imT",
	"JAk3ipHX04LJMCmmcueYJrUxIbWozqOWQwLp7tDF6MPp8HgEHmM0ERISKi7Q+GwyurhsIiYaxH8Tk+cj",
	"JuUCVc9MTCq1lg6FmJiL9GTERF2xNr4cR8L/vkM6jTJF6aGiEm6eFLqseAvVVWILBDVhTQ5SmizzNMq5",
	"n55BDMjkJRkQnIjcATVyYtZxJpkSFbRWwzQpJ+s1QSMEJzotmBIZTNzGfFOMl2skbVbPaYKGCSLrVG5s",
	"e0iVKrnODqY2DgiY1U87lFbQyGTbKEss4HRbmIKKBJ0QDDZNSvKMkzP6GhLKDiafaXqNCnKlh7wW5Z8h",
	"sWqzg31+bpBzVe3iVK/8GpLZugNZ64FkpfQQiT+fq9qQPvp7vsVJpINf/MmRp3l6ZIVjsC97Z0feKRuy",
	"7ylQIOz2EJj1Vvb1+VQ33Sf/up4AN+38Mz8A/uj2g3GFUAf+hK8A8FXwEGQtLGWZ0BWJbU19+ztTuK2F",
	"6xTNd1CDsB8/VmMMn5sh6wrA13YdSxmen9tNqZKk+MB4MsaRWcHTXUyT3qaRQdOJKcC25DBa1obvrZlB",
	"dDahMrPWxpoNyynFlGSGJOFr+zNE4qcrrvrrn/qmHhc868ZqVBTDKLIIQUyeVgvllS+KSh8keomCCdMk",
	"52GgpkdK+IJxxcna4v5m2Q5/5rCbVo8FqdhySuaOuo0zsnyRs4Xg87jOYknTmBRBwfvsjgb+wRzTJE+7",
	"9G+e6amJdDmt4ktxTbUUOIdBq80tejIC7fiTZi3upM+lITeuCPsxUVkl4cIzs1Ddpv+67mY598aLOOQe",
	"qBfuo19JztJWWxVnafW+uZqa3HCrLcvq2dVDaRfEqgq8QcujtVLJpgipx0KwkIIVG55x2ujWpiDc152k",
	"q0n4CZ5VtfGHYcsq7e9L2bQqQByabUvdosc3OoPMIVrEHOBCFAcXQypvLaTonCvrTPPNSsiJSN1VRNTK",
	"h+vSQ1rC0UrdFb5Rj7STc2uaONm/EJYShyutCqU6VZrbz2SiRIsYL9Hv//yfGAv5+z//V+er1fCon4xo",
	"Ze5qqboHKKlhSK3+XWSxgmBRBsoKI8QIEHKFE12T3pKTOlPRRG10Qsg6lXkUovHV0wKbDvNleepaUs4D",
	"cRoD51KUY9CjkACrihikugxzMzEwdZq1tRdMFJAx2fyaqzTqPmMNN8GM90e9CpXq4c98F6pFtw/lDlgk",
	"xBbhIHW/33kSLgrKb/0D7oawuUhbnkrbpGS+y3+s3QrjBhISekMqxttmVjWf5I96aWpZdF9MLePJ+nsg",
	"mhkXJ2vqa2z5M6j8pbFynyu1U9qggkO8aPeLAkkOuzmy0F9e/1fuw2RFs4oHU2tAgZXntsl9xmM7n6Oo",
	"W96ShOjriGUqL/RFXfcLIA7TYd/Blu6BTNv98HPVh/ULbHHGd7CcJUtzJTwhf7mixJHAbGhRq/++47Wf",
	"z8V4qZ3Z1Lxqu+2zNfSwEv7XFgfQ9WI+XRTAEzvkv/CFrINxqM74+13KLnrLHP9dlaRXzeEgdvViVlWY",
	"Pa2sLPSTuc7S2I9FJ8cNBWDXO1JeTOXpQn/+8xmT5M9/PkIn25bpanOu7FAhzh5P9fmESsiXvnAlEA5R",
	"AbnXRXP0aGIwJ6YMQJO+EXNpuUJXAVfyma/UHTApz9EQCurjSAwgwawotHZTnb6IJhW1nq7Bn5nkRoJw",
	"imP6G+Sxp4LFuE17Ua3nsKNNXt0+F5Q5UURDIMm+6mtUXfULXaU6GAd2nWABZWx0LpWzso73KmTrNW2J",
	"TRkWMei6aUHiTcR6oeL2Vw1xC4agYz1GHmaC43gKYfUJk7pGgK2cgeYbRBKRgQdSwhBUjMGxMTrb8npl",
	"ZjPKjGzqXpAFpnHGG7lGDdEf7j7Wlv1S0l0djkMT8My1QJePdCVtFfeWKA9fnfeIihDzSFQv6DSpX9Ey",
	"9fB699Yr0/8xLkZL4f9nTwrogeTgEgIaTN3txVoRHOts/UtdgLeMou/g8/DDWP/xlLmj9AzHKxJ+PpTN",
	"NwUQgqOPn8opdW5ITBMiBNLbG6pFOUfh/pqfhC2FsPQVQv5gn/FqGghdI11XUuc3hBsfHbeJKY0rnNDS",
	"oj0ypQN6iMiw6eV+S+RYQfe0mezUFAfo8N58Fs6Jw/blR83mqgGe05jKzWBNJKehGEi6JkrAIUI7aje/",
	"Sv+dQTME/h66CzKj1E7w3J0LyvVe0jWZQKf3eZ+noO/+yV6IxDcBc2Do1nLybqpOiww5xmWCcDGwWqzB",
	"F6dozf3AUBw/rulward2jomwFkXlq1w7ZqrD+FLCviWlQTpZR93SOl8Bw1JZwsvl/PRWMjqkcD0P7lTQ",
	"1yJJOc1sKxpvS/7wWJg8ro1ziMhcX8WLZh84aJS2MaCPjNDbEnJntbJmuc5mJ4Sul0c7RIRurkX3IrEH",
	"B43QNhv4LghdFojKteA+flKnbjoXVdKiNU2C+17xg2pc96y/XLnZvIpicEa3qcu1eWsG4wQvy5Y6NHTd",
	"aVR7cFQGT2FTkrQUp2wgc/03/QDmVpadwSvSN6OhLducK1q9EFZMjwbGws7TAGEeoOGHsACoEslRDqHt",
	"I11nGuTbUtQW5gQRJQ+FOkeHIkIppwqn0GeycUHNg1k8oOp0Jyss0DyjsXxFk2rgrc0TYoTdRZYYQxOV",
	"UL2WJHgekygP9v39n//z3jhK/f7P/61mUjWjqD/Vepyv5C5l6kRtmldzjCZsV+dfQXMmV44XIU6i3OG2",
	"6r2lfdk1dLA4SJMCi3sVcXpDknJhEXTOIx0YTAVaZpjjRBKdQxajvLA7iskNiYvNrTqAORcsV+d49r2C",
	"BIyjJZEa31oVDsXEIORuHdicb7nsnRmhKBLmAF2SYH0IUzI16vKPvLhlip5yFtvELpL4ogzmG3XYMQ2p",
	"jDc6/wtksKlZOEkCZ0ZlKSJxvaYy1ybn6KLtnfl7WzHgVMYOpa6xbilAllCZ5/5hiwXhAi1jNsex20/0",
	"tGF0eDw+QUVdUl2xXsmA0rGZwgY6u13SCDobrp6u5ouZ5+hxy47o3MY4kyuSSFs7ApVKd+aWqOGHsYMO",
	"1SLrooDPLThxcOCkcbZcwkVnCg47H9eZieAnCwpbABA5RCxVhCCTK8bpb3pB356rtxH90H/9HWC4A5X/",
	"zbSXzsboa5UjAp2jgwKuJnL7msocpd4xyAjVaWuLuD8gIcA31JjJ3XbWpQz5DpvkT0YH0rjLt3ijgANV",
	"m71nhRKtAAt+2A7VHAsamh3acWPKOwH/u/90/38BAAD//+BrXSVE6QAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
