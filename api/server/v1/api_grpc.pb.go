// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: server/v1/api.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TigrisClient is the client API for Tigris service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TigrisClient interface {
	// Starts a new transaction and returns a transactional object. All reads/writes performed
	// within a transaction will run with serializable isolation. Tigris offers global transactions,
	// with ACID properties and strict serializability.
	BeginTransaction(ctx context.Context, in *BeginTransactionRequest, opts ...grpc.CallOption) (*BeginTransactionResponse, error)
	// Atomically commit all the changes performed in the context of the transaction. Commit provides all
	// or nothing semantics by ensuring no partial updates are in the project due to a transaction failure.
	CommitTransaction(ctx context.Context, in *CommitTransactionRequest, opts ...grpc.CallOption) (*CommitTransactionResponse, error)
	// Rollback transaction discards all the changes
	// performed in the transaction
	RollbackTransaction(ctx context.Context, in *RollbackTransactionRequest, opts ...grpc.CallOption) (*RollbackTransactionResponse, error)
	// Inserts new documents in the collection and returns an AlreadyExists error if any of the documents
	// in the request already exists. Insert provides idempotency by returning an error if the document
	// already exists. To replace documents, use REPLACE API instead of INSERT.
	Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error)
	// Inserts the documents or replaces the existing documents in the collections.
	Replace(ctx context.Context, in *ReplaceRequest, opts ...grpc.CallOption) (*ReplaceResponse, error)
	// Delete a range of documents in the collection using the condition provided in the filter.
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Update a range of documents in the collection using the condition provided in the filter.
	Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// Reads a range of documents from the collection, or messages from a collection in case of event streaming. Tigris does not require you to
	// index any fields and automatically index all the fields which means you can filter by any field in the document.
	// An empty filter will trigger reading all the documents inside this collection. The API supports pagination that
	// can be used by passing `Limit/Skip` parameters. The `skip` parameter skips the number of documents from the start and
	// the `limit` parameter is used to specify the number of documents to read. You can find more detailed documentation
	// of the Read API <a href="https://docs.tigrisdata.com/overview/query" title="here">here</a>.
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Tigris_ReadClient, error)
	// Searches a collection for the documents matching the query, or messages in case of event streaming. A search can be
	// a term search or a phrase search. Search API allows filtering the result set using filters as documented <a href="https://docs.tigrisdata.com/overview/query#specification-1" title="here">here</a>.
	// You can also perform a faceted search by passing the fields in the facet parameter.
	// You can find more detailed documentation of the Search API with multiple examples <a href="https://docs.tigrisdata.com/overview/search" title="here">here</a>.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (Tigris_SearchClient, error)
	// Imports documents into the collection.
	//
	// It automatically:
	//  * Detects the schema of the documents in the batch
	//  * Evolves the schema as soon as it's backward compatible
	//  * Creates collection with inferred schema (if requested)
	Import(ctx context.Context, in *ImportRequest, opts ...grpc.CallOption) (*ImportResponse, error)
	// Creates a new collection or atomically upgrades the collection to the new schema provided in the request.
	// Schema changes are applied atomically and immediately without any downtime.
	// Tigris Offers two types of collections: <p></p>
	//    <li> `DOCUMENTS`: Offers rich CRUD APIs.
	//    <li> `MESSAGES`: Offers event streaming APIs.
	CreateOrUpdateCollection(ctx context.Context, in *CreateOrUpdateCollectionRequest, opts ...grpc.CallOption) (*CreateOrUpdateCollectionResponse, error)
	// Drops the collection inside this project. This API deletes all of the
	// documents inside this collection and any metadata associated with it.
	DropCollection(ctx context.Context, in *DropCollectionRequest, opts ...grpc.CallOption) (*DropCollectionResponse, error)
	// List returns all the projects.
	ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error)
	// List all the collections present in the project passed in the request.
	ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error)
	// Creates a new project. Returns an AlreadyExists error with a status code 409 if the project already exists.
	CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*CreateProjectResponse, error)
	// Delete Project deletes all the collections in this project along with all of the documents, and associated metadata for these collections.
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*DeleteProjectResponse, error)
	// This API returns information related to the project along with all the collections inside the project.
	// This can be used to retrieve the size of the project or to retrieve schemas, branches and the size of all the collections present in this project.
	DescribeDatabase(ctx context.Context, in *DescribeDatabaseRequest, opts ...grpc.CallOption) (*DescribeDatabaseResponse, error)
	// Creates a new database branch, if not already existing.
	CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*CreateBranchResponse, error)
	// Deletes a database branch, if exists.
	// Throws 400 Bad Request if "main" branch is being deleted
	DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*DeleteBranchResponse, error)
	// Returns the information related to the collection. This can be used to retrieve the schema or size of the collection.
	DescribeCollection(ctx context.Context, in *DescribeCollectionRequest, opts ...grpc.CallOption) (*DescribeCollectionResponse, error)
	// Create an app key.
	CreateAppKey(ctx context.Context, in *CreateAppKeyRequest, opts ...grpc.CallOption) (*CreateAppKeyResponse, error)
	// Update the description of an app key.
	UpdateAppKey(ctx context.Context, in *UpdateAppKeyRequest, opts ...grpc.CallOption) (*UpdateAppKeyResponse, error)
	// Delete an app key.
	DeleteAppKey(ctx context.Context, in *DeleteAppKeyRequest, opts ...grpc.CallOption) (*DeleteAppKeyResponse, error)
	// Lists all app keys visible to requesting actor.
	ListAppKeys(ctx context.Context, in *ListAppKeysRequest, opts ...grpc.CallOption) (*ListAppKeysResponse, error)
	// Endpoint is used to rotate the secret for the app key.
	RotateAppKeySecret(ctx context.Context, in *RotateAppKeyRequest, opts ...grpc.CallOption) (*RotateAppKeyResponse, error)
}

type tigrisClient struct {
	cc grpc.ClientConnInterface
}

func NewTigrisClient(cc grpc.ClientConnInterface) TigrisClient {
	return &tigrisClient{cc}
}

func (c *tigrisClient) BeginTransaction(ctx context.Context, in *BeginTransactionRequest, opts ...grpc.CallOption) (*BeginTransactionResponse, error) {
	out := new(BeginTransactionResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/BeginTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) CommitTransaction(ctx context.Context, in *CommitTransactionRequest, opts ...grpc.CallOption) (*CommitTransactionResponse, error) {
	out := new(CommitTransactionResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/CommitTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) RollbackTransaction(ctx context.Context, in *RollbackTransactionRequest, opts ...grpc.CallOption) (*RollbackTransactionResponse, error) {
	out := new(RollbackTransactionResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/RollbackTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error) {
	out := new(InsertResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/Insert", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) Replace(ctx context.Context, in *ReplaceRequest, opts ...grpc.CallOption) (*ReplaceResponse, error) {
	out := new(ReplaceResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/Replace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) Update(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (Tigris_ReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &Tigris_ServiceDesc.Streams[0], "/tigrisdata.v1.Tigris/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &tigrisReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Tigris_ReadClient interface {
	Recv() (*ReadResponse, error)
	grpc.ClientStream
}

type tigrisReadClient struct {
	grpc.ClientStream
}

func (x *tigrisReadClient) Recv() (*ReadResponse, error) {
	m := new(ReadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tigrisClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (Tigris_SearchClient, error) {
	stream, err := c.cc.NewStream(ctx, &Tigris_ServiceDesc.Streams[1], "/tigrisdata.v1.Tigris/Search", opts...)
	if err != nil {
		return nil, err
	}
	x := &tigrisSearchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Tigris_SearchClient interface {
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type tigrisSearchClient struct {
	grpc.ClientStream
}

func (x *tigrisSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tigrisClient) Import(ctx context.Context, in *ImportRequest, opts ...grpc.CallOption) (*ImportResponse, error) {
	out := new(ImportResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/Import", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) CreateOrUpdateCollection(ctx context.Context, in *CreateOrUpdateCollectionRequest, opts ...grpc.CallOption) (*CreateOrUpdateCollectionResponse, error) {
	out := new(CreateOrUpdateCollectionResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/CreateOrUpdateCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) DropCollection(ctx context.Context, in *DropCollectionRequest, opts ...grpc.CallOption) (*DropCollectionResponse, error) {
	out := new(DropCollectionResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/DropCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error) {
	out := new(ListProjectsResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/ListProjects", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) ListCollections(ctx context.Context, in *ListCollectionsRequest, opts ...grpc.CallOption) (*ListCollectionsResponse, error) {
	out := new(ListCollectionsResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/ListCollections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*CreateProjectResponse, error) {
	out := new(CreateProjectResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/CreateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*DeleteProjectResponse, error) {
	out := new(DeleteProjectResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/DeleteProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) DescribeDatabase(ctx context.Context, in *DescribeDatabaseRequest, opts ...grpc.CallOption) (*DescribeDatabaseResponse, error) {
	out := new(DescribeDatabaseResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/DescribeDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*CreateBranchResponse, error) {
	out := new(CreateBranchResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/CreateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*DeleteBranchResponse, error) {
	out := new(DeleteBranchResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/DeleteBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) DescribeCollection(ctx context.Context, in *DescribeCollectionRequest, opts ...grpc.CallOption) (*DescribeCollectionResponse, error) {
	out := new(DescribeCollectionResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/DescribeCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) CreateAppKey(ctx context.Context, in *CreateAppKeyRequest, opts ...grpc.CallOption) (*CreateAppKeyResponse, error) {
	out := new(CreateAppKeyResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/CreateAppKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) UpdateAppKey(ctx context.Context, in *UpdateAppKeyRequest, opts ...grpc.CallOption) (*UpdateAppKeyResponse, error) {
	out := new(UpdateAppKeyResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/UpdateAppKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) DeleteAppKey(ctx context.Context, in *DeleteAppKeyRequest, opts ...grpc.CallOption) (*DeleteAppKeyResponse, error) {
	out := new(DeleteAppKeyResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/DeleteAppKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) ListAppKeys(ctx context.Context, in *ListAppKeysRequest, opts ...grpc.CallOption) (*ListAppKeysResponse, error) {
	out := new(ListAppKeysResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/ListAppKeys", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tigrisClient) RotateAppKeySecret(ctx context.Context, in *RotateAppKeyRequest, opts ...grpc.CallOption) (*RotateAppKeyResponse, error) {
	out := new(RotateAppKeyResponse)
	err := c.cc.Invoke(ctx, "/tigrisdata.v1.Tigris/RotateAppKeySecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TigrisServer is the server API for Tigris service.
// All implementations should embed UnimplementedTigrisServer
// for forward compatibility
type TigrisServer interface {
	// Starts a new transaction and returns a transactional object. All reads/writes performed
	// within a transaction will run with serializable isolation. Tigris offers global transactions,
	// with ACID properties and strict serializability.
	BeginTransaction(context.Context, *BeginTransactionRequest) (*BeginTransactionResponse, error)
	// Atomically commit all the changes performed in the context of the transaction. Commit provides all
	// or nothing semantics by ensuring no partial updates are in the project due to a transaction failure.
	CommitTransaction(context.Context, *CommitTransactionRequest) (*CommitTransactionResponse, error)
	// Rollback transaction discards all the changes
	// performed in the transaction
	RollbackTransaction(context.Context, *RollbackTransactionRequest) (*RollbackTransactionResponse, error)
	// Inserts new documents in the collection and returns an AlreadyExists error if any of the documents
	// in the request already exists. Insert provides idempotency by returning an error if the document
	// already exists. To replace documents, use REPLACE API instead of INSERT.
	Insert(context.Context, *InsertRequest) (*InsertResponse, error)
	// Inserts the documents or replaces the existing documents in the collections.
	Replace(context.Context, *ReplaceRequest) (*ReplaceResponse, error)
	// Delete a range of documents in the collection using the condition provided in the filter.
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Update a range of documents in the collection using the condition provided in the filter.
	Update(context.Context, *UpdateRequest) (*UpdateResponse, error)
	// Reads a range of documents from the collection, or messages from a collection in case of event streaming. Tigris does not require you to
	// index any fields and automatically index all the fields which means you can filter by any field in the document.
	// An empty filter will trigger reading all the documents inside this collection. The API supports pagination that
	// can be used by passing `Limit/Skip` parameters. The `skip` parameter skips the number of documents from the start and
	// the `limit` parameter is used to specify the number of documents to read. You can find more detailed documentation
	// of the Read API <a href="https://docs.tigrisdata.com/overview/query" title="here">here</a>.
	Read(*ReadRequest, Tigris_ReadServer) error
	// Searches a collection for the documents matching the query, or messages in case of event streaming. A search can be
	// a term search or a phrase search. Search API allows filtering the result set using filters as documented <a href="https://docs.tigrisdata.com/overview/query#specification-1" title="here">here</a>.
	// You can also perform a faceted search by passing the fields in the facet parameter.
	// You can find more detailed documentation of the Search API with multiple examples <a href="https://docs.tigrisdata.com/overview/search" title="here">here</a>.
	Search(*SearchRequest, Tigris_SearchServer) error
	// Imports documents into the collection.
	//
	// It automatically:
	//  * Detects the schema of the documents in the batch
	//  * Evolves the schema as soon as it's backward compatible
	//  * Creates collection with inferred schema (if requested)
	Import(context.Context, *ImportRequest) (*ImportResponse, error)
	// Creates a new collection or atomically upgrades the collection to the new schema provided in the request.
	// Schema changes are applied atomically and immediately without any downtime.
	// Tigris Offers two types of collections: <p></p>
	//    <li> `DOCUMENTS`: Offers rich CRUD APIs.
	//    <li> `MESSAGES`: Offers event streaming APIs.
	CreateOrUpdateCollection(context.Context, *CreateOrUpdateCollectionRequest) (*CreateOrUpdateCollectionResponse, error)
	// Drops the collection inside this project. This API deletes all of the
	// documents inside this collection and any metadata associated with it.
	DropCollection(context.Context, *DropCollectionRequest) (*DropCollectionResponse, error)
	// List returns all the projects.
	ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error)
	// List all the collections present in the project passed in the request.
	ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error)
	// Creates a new project. Returns an AlreadyExists error with a status code 409 if the project already exists.
	CreateProject(context.Context, *CreateProjectRequest) (*CreateProjectResponse, error)
	// Delete Project deletes all the collections in this project along with all of the documents, and associated metadata for these collections.
	DeleteProject(context.Context, *DeleteProjectRequest) (*DeleteProjectResponse, error)
	// This API returns information related to the project along with all the collections inside the project.
	// This can be used to retrieve the size of the project or to retrieve schemas, branches and the size of all the collections present in this project.
	DescribeDatabase(context.Context, *DescribeDatabaseRequest) (*DescribeDatabaseResponse, error)
	// Creates a new database branch, if not already existing.
	CreateBranch(context.Context, *CreateBranchRequest) (*CreateBranchResponse, error)
	// Deletes a database branch, if exists.
	// Throws 400 Bad Request if "main" branch is being deleted
	DeleteBranch(context.Context, *DeleteBranchRequest) (*DeleteBranchResponse, error)
	// Returns the information related to the collection. This can be used to retrieve the schema or size of the collection.
	DescribeCollection(context.Context, *DescribeCollectionRequest) (*DescribeCollectionResponse, error)
	// Create an app key.
	CreateAppKey(context.Context, *CreateAppKeyRequest) (*CreateAppKeyResponse, error)
	// Update the description of an app key.
	UpdateAppKey(context.Context, *UpdateAppKeyRequest) (*UpdateAppKeyResponse, error)
	// Delete an app key.
	DeleteAppKey(context.Context, *DeleteAppKeyRequest) (*DeleteAppKeyResponse, error)
	// Lists all app keys visible to requesting actor.
	ListAppKeys(context.Context, *ListAppKeysRequest) (*ListAppKeysResponse, error)
	// Endpoint is used to rotate the secret for the app key.
	RotateAppKeySecret(context.Context, *RotateAppKeyRequest) (*RotateAppKeyResponse, error)
}

// UnimplementedTigrisServer should be embedded to have forward compatible implementations.
type UnimplementedTigrisServer struct {
}

func (UnimplementedTigrisServer) BeginTransaction(context.Context, *BeginTransactionRequest) (*BeginTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginTransaction not implemented")
}
func (UnimplementedTigrisServer) CommitTransaction(context.Context, *CommitTransactionRequest) (*CommitTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitTransaction not implemented")
}
func (UnimplementedTigrisServer) RollbackTransaction(context.Context, *RollbackTransactionRequest) (*RollbackTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackTransaction not implemented")
}
func (UnimplementedTigrisServer) Insert(context.Context, *InsertRequest) (*InsertResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTigrisServer) Replace(context.Context, *ReplaceRequest) (*ReplaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Replace not implemented")
}
func (UnimplementedTigrisServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTigrisServer) Update(context.Context, *UpdateRequest) (*UpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedTigrisServer) Read(*ReadRequest, Tigris_ReadServer) error {
	return status.Errorf(codes.Unimplemented, "method Read not implemented")
}
func (UnimplementedTigrisServer) Search(*SearchRequest, Tigris_SearchServer) error {
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedTigrisServer) Import(context.Context, *ImportRequest) (*ImportResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Import not implemented")
}
func (UnimplementedTigrisServer) CreateOrUpdateCollection(context.Context, *CreateOrUpdateCollectionRequest) (*CreateOrUpdateCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateCollection not implemented")
}
func (UnimplementedTigrisServer) DropCollection(context.Context, *DropCollectionRequest) (*DropCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropCollection not implemented")
}
func (UnimplementedTigrisServer) ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjects not implemented")
}
func (UnimplementedTigrisServer) ListCollections(context.Context, *ListCollectionsRequest) (*ListCollectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCollections not implemented")
}
func (UnimplementedTigrisServer) CreateProject(context.Context, *CreateProjectRequest) (*CreateProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (UnimplementedTigrisServer) DeleteProject(context.Context, *DeleteProjectRequest) (*DeleteProjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}
func (UnimplementedTigrisServer) DescribeDatabase(context.Context, *DescribeDatabaseRequest) (*DescribeDatabaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeDatabase not implemented")
}
func (UnimplementedTigrisServer) CreateBranch(context.Context, *CreateBranchRequest) (*CreateBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBranch not implemented")
}
func (UnimplementedTigrisServer) DeleteBranch(context.Context, *DeleteBranchRequest) (*DeleteBranchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBranch not implemented")
}
func (UnimplementedTigrisServer) DescribeCollection(context.Context, *DescribeCollectionRequest) (*DescribeCollectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeCollection not implemented")
}
func (UnimplementedTigrisServer) CreateAppKey(context.Context, *CreateAppKeyRequest) (*CreateAppKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAppKey not implemented")
}
func (UnimplementedTigrisServer) UpdateAppKey(context.Context, *UpdateAppKeyRequest) (*UpdateAppKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAppKey not implemented")
}
func (UnimplementedTigrisServer) DeleteAppKey(context.Context, *DeleteAppKeyRequest) (*DeleteAppKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAppKey not implemented")
}
func (UnimplementedTigrisServer) ListAppKeys(context.Context, *ListAppKeysRequest) (*ListAppKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAppKeys not implemented")
}
func (UnimplementedTigrisServer) RotateAppKeySecret(context.Context, *RotateAppKeyRequest) (*RotateAppKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateAppKeySecret not implemented")
}

// UnsafeTigrisServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TigrisServer will
// result in compilation errors.
type UnsafeTigrisServer interface {
	mustEmbedUnimplementedTigrisServer()
}

func RegisterTigrisServer(s grpc.ServiceRegistrar, srv TigrisServer) {
	s.RegisterService(&Tigris_ServiceDesc, srv)
}

func _Tigris_BeginTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).BeginTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/BeginTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).BeginTransaction(ctx, req.(*BeginTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_CommitTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommitTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).CommitTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/CommitTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).CommitTransaction(ctx, req.(*CommitTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_RollbackTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).RollbackTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/RollbackTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).RollbackTransaction(ctx, req.(*RollbackTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/Insert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).Insert(ctx, req.(*InsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_Replace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).Replace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/Replace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).Replace(ctx, req.(*ReplaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).Update(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TigrisServer).Read(m, &tigrisReadServer{stream})
}

type Tigris_ReadServer interface {
	Send(*ReadResponse) error
	grpc.ServerStream
}

type tigrisReadServer struct {
	grpc.ServerStream
}

func (x *tigrisReadServer) Send(m *ReadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Tigris_Search_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SearchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TigrisServer).Search(m, &tigrisSearchServer{stream})
}

type Tigris_SearchServer interface {
	Send(*SearchResponse) error
	grpc.ServerStream
}

type tigrisSearchServer struct {
	grpc.ServerStream
}

func (x *tigrisSearchServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Tigris_Import_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).Import(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/Import",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).Import(ctx, req.(*ImportRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_CreateOrUpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrUpdateCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).CreateOrUpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/CreateOrUpdateCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).CreateOrUpdateCollection(ctx, req.(*CreateOrUpdateCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_DropCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).DropCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/DropCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).DropCollection(ctx, req.(*DropCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).ListProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/ListProjects",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).ListProjects(ctx, req.(*ListProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_ListCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCollectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).ListCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/ListCollections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).ListCollections(ctx, req.(*ListCollectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).CreateProject(ctx, req.(*CreateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/DeleteProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_DescribeDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).DescribeDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/DescribeDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).DescribeDatabase(ctx, req.(*DescribeDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_CreateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).CreateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/CreateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).CreateBranch(ctx, req.(*CreateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_DeleteBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).DeleteBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/DeleteBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).DeleteBranch(ctx, req.(*DeleteBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_DescribeCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeCollectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).DescribeCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/DescribeCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).DescribeCollection(ctx, req.(*DescribeCollectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_CreateAppKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAppKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).CreateAppKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/CreateAppKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).CreateAppKey(ctx, req.(*CreateAppKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_UpdateAppKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAppKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).UpdateAppKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/UpdateAppKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).UpdateAppKey(ctx, req.(*UpdateAppKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_DeleteAppKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAppKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).DeleteAppKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/DeleteAppKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).DeleteAppKey(ctx, req.(*DeleteAppKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_ListAppKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAppKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).ListAppKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/ListAppKeys",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).ListAppKeys(ctx, req.(*ListAppKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tigris_RotateAppKeySecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateAppKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TigrisServer).RotateAppKeySecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tigrisdata.v1.Tigris/RotateAppKeySecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TigrisServer).RotateAppKeySecret(ctx, req.(*RotateAppKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Tigris_ServiceDesc is the grpc.ServiceDesc for Tigris service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tigris_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tigrisdata.v1.Tigris",
	HandlerType: (*TigrisServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BeginTransaction",
			Handler:    _Tigris_BeginTransaction_Handler,
		},
		{
			MethodName: "CommitTransaction",
			Handler:    _Tigris_CommitTransaction_Handler,
		},
		{
			MethodName: "RollbackTransaction",
			Handler:    _Tigris_RollbackTransaction_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Tigris_Insert_Handler,
		},
		{
			MethodName: "Replace",
			Handler:    _Tigris_Replace_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Tigris_Delete_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Tigris_Update_Handler,
		},
		{
			MethodName: "Import",
			Handler:    _Tigris_Import_Handler,
		},
		{
			MethodName: "CreateOrUpdateCollection",
			Handler:    _Tigris_CreateOrUpdateCollection_Handler,
		},
		{
			MethodName: "DropCollection",
			Handler:    _Tigris_DropCollection_Handler,
		},
		{
			MethodName: "ListProjects",
			Handler:    _Tigris_ListProjects_Handler,
		},
		{
			MethodName: "ListCollections",
			Handler:    _Tigris_ListCollections_Handler,
		},
		{
			MethodName: "CreateProject",
			Handler:    _Tigris_CreateProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _Tigris_DeleteProject_Handler,
		},
		{
			MethodName: "DescribeDatabase",
			Handler:    _Tigris_DescribeDatabase_Handler,
		},
		{
			MethodName: "CreateBranch",
			Handler:    _Tigris_CreateBranch_Handler,
		},
		{
			MethodName: "DeleteBranch",
			Handler:    _Tigris_DeleteBranch_Handler,
		},
		{
			MethodName: "DescribeCollection",
			Handler:    _Tigris_DescribeCollection_Handler,
		},
		{
			MethodName: "CreateAppKey",
			Handler:    _Tigris_CreateAppKey_Handler,
		},
		{
			MethodName: "UpdateAppKey",
			Handler:    _Tigris_UpdateAppKey_Handler,
		},
		{
			MethodName: "DeleteAppKey",
			Handler:    _Tigris_DeleteAppKey_Handler,
		},
		{
			MethodName: "ListAppKeys",
			Handler:    _Tigris_ListAppKeys_Handler,
		},
		{
			MethodName: "RotateAppKeySecret",
			Handler:    _Tigris_RotateAppKeySecret_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _Tigris_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Search",
			Handler:       _Tigris_Search_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "server/v1/api.proto",
}
