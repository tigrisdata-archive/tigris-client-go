// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ErrorCode.
const (
	ABORTED            ErrorCode = "ABORTED"
	ALREADYEXISTS      ErrorCode = "ALREADY_EXISTS"
	BADGATEWAY         ErrorCode = "BAD_GATEWAY"
	CANCELLED          ErrorCode = "CANCELLED"
	CONFLICT           ErrorCode = "CONFLICT"
	CONTENTTOOLARGE    ErrorCode = "CONTENT_TOO_LARGE"
	DATALOSS           ErrorCode = "DATA_LOSS"
	DEADLINEEXCEEDED   ErrorCode = "DEADLINE_EXCEEDED"
	FAILEDPRECONDITION ErrorCode = "FAILED_PRECONDITION"
	INTERNAL           ErrorCode = "INTERNAL"
	INVALIDARGUMENT    ErrorCode = "INVALID_ARGUMENT"
	METHODNOTALLOWED   ErrorCode = "METHOD_NOT_ALLOWED"
	NOTFOUND           ErrorCode = "NOT_FOUND"
	OK                 ErrorCode = "OK"
	OUTOFRANGE         ErrorCode = "OUT_OF_RANGE"
	PERMISSIONDENIED   ErrorCode = "PERMISSION_DENIED"
	RESOURCEEXHAUSTED  ErrorCode = "RESOURCE_EXHAUSTED"
	UNAUTHENTICATED    ErrorCode = "UNAUTHENTICATED"
	UNAVAILABLE        ErrorCode = "UNAVAILABLE"
	UNIMPLEMENTED      ErrorCode = "UNIMPLEMENTED"
	UNKNOWN            ErrorCode = "UNKNOWN"
)

// Defines values for GetAccessTokenRequestGrantType.
const (
	CLIENTCREDENTIALS GetAccessTokenRequestGrantType = "CLIENT_CREDENTIALS"
	REFRESHTOKEN      GetAccessTokenRequestGrantType = "REFRESH_TOKEN"
)

// Defines values for QueryTimeSeriesMetricsRequestFunction.
const (
	COUNT QueryTimeSeriesMetricsRequestFunction = "COUNT"
	NONE  QueryTimeSeriesMetricsRequestFunction = "NONE"
	RATE  QueryTimeSeriesMetricsRequestFunction = "RATE"
)

// Defines values for QueryTimeSeriesMetricsRequestSpaceAggregation.
const (
	AVG QueryTimeSeriesMetricsRequestSpaceAggregation = "AVG"
	MAX QueryTimeSeriesMetricsRequestSpaceAggregation = "MAX"
	MIN QueryTimeSeriesMetricsRequestSpaceAggregation = "MIN"
	SUM QueryTimeSeriesMetricsRequestSpaceAggregation = "SUM"
)

// Defines values for QueryTimeSeriesMetricsRequestTigrisOperation.
const (
	ALL      QueryTimeSeriesMetricsRequestTigrisOperation = "ALL"
	METADATA QueryTimeSeriesMetricsRequestTigrisOperation = "METADATA"
	READ     QueryTimeSeriesMetricsRequestTigrisOperation = "READ"
	WRITE    QueryTimeSeriesMetricsRequestTigrisOperation = "WRITE"
)

// Defines values for RollupFunctionAggregator.
const (
	ROLLUPAGGREGATORAVG   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_AVG"
	ROLLUPAGGREGATORCOUNT RollupFunctionAggregator = "ROLLUP_AGGREGATOR_COUNT"
	ROLLUPAGGREGATORMAX   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_MAX"
	ROLLUPAGGREGATORMIN   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_MIN"
	ROLLUPAGGREGATORSUM   RollupFunctionAggregator = "ROLLUP_AGGREGATOR_SUM"
)

// AdditionalFunction Additional function to apply on metrics query
type AdditionalFunction struct {
	// Rollup Rollup function aggregates the slices of metrics returned by original query and lets you operate on the slices using aggregator and constructs the bigger slice of your choice of interval (specified in seconds).
	Rollup *RollupFunction `json:"rollup,omitempty"`
}

// AppKey An user AppKey
type AppKey struct {
	// CreatedAt Created at
	CreatedAt *int64 `json:"created_at,omitempty"`

	// CreatedBy Created by
	CreatedBy *string `json:"created_by,omitempty"`

	// Description A human readable app description
	Description *string `json:"description,omitempty"`

	// Id Generated client id
	Id *string `json:"id,omitempty"`

	// Name A human readable app name
	Name *string `json:"name,omitempty"`

	// Project Project it belongs to
	Project *string `json:"project,omitempty"`

	// Secret Generated app secret
	Secret *string `json:"secret,omitempty"`

	// UpdatedAt Updated at
	UpdatedAt *int64 `json:"updated_at,omitempty"`

	// UpdatedBy Updated by
	UpdatedBy *string `json:"updated_by,omitempty"`
}

// BeginTransactionRequest Start new transaction in project specified by "project".
type BeginTransactionRequest struct {
	// Branch Optionally specify a project branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Options Options that can be used to modify the transaction semantics.
	Options *TransactionOptions `json:"options,omitempty"`
}

// BeginTransactionResponse Start transaction returns transaction context  which uniquely identifies the transaction
type BeginTransactionResponse struct {
	// TxCtx Contains ID which uniquely identifies transaction This context is returned by BeginTransaction request and should be passed in the metadata (headers) of subsequent requests in order to run them in the context of the same transaction.
	TxCtx *TransactionCtx `json:"tx_ctx,omitempty"`
}

// BranchInfo defines model for BranchInfo.
type BranchInfo struct {
	// Branch Branch name
	Branch   *string         `json:"branch,omitempty"`
	Metadata *BranchMetadata `json:"metadata,omitempty"`
}

// BranchMetadata defines model for BranchMetadata.
type BranchMetadata = map[string]interface{}

// CacheMetadata defines model for CacheMetadata.
type CacheMetadata struct {
	// Name Cache name
	Name *string `json:"name,omitempty"`
}

// ChannelMetadata defines model for ChannelMetadata.
type ChannelMetadata struct {
	Channel *string `json:"channel,omitempty"`
}

// Collation A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
type Collation struct {
	Case *string `json:"case,omitempty"`
}

// CollectionDescription defines model for CollectionDescription.
type CollectionDescription struct {
	// Collection Name of the collection.
	Collection *string             `json:"collection,omitempty"`
	Metadata   *CollectionMetadata `json:"metadata,omitempty"`

	// Schema Collections schema
	Schema json.RawMessage `json:"schema,omitempty"`

	// Size Collection size in bytes
	Size *int64 `json:"size,omitempty"`
}

// CollectionInfo defines model for CollectionInfo.
type CollectionInfo struct {
	// Collection Collection name.
	Collection *string             `json:"collection,omitempty"`
	Metadata   *CollectionMetadata `json:"metadata,omitempty"`
}

// CollectionMetadata defines model for CollectionMetadata.
type CollectionMetadata = map[string]interface{}

// CollectionOptions Collection requests modifying options.
type CollectionOptions = map[string]interface{}

// CommitTransactionRequest Commit transaction with the given ID
type CommitTransactionRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`
}

// CommitTransactionResponse defines model for CommitTransactionResponse.
type CommitTransactionResponse struct {
	// Status Status of commit transaction operation.
	Status *string `json:"status,omitempty"`
}

// CreateAppKeyRequest Request creation of user app key
type CreateAppKeyRequest struct {
	// Description A human readable app description
	Description *string `json:"description,omitempty"`

	// Name A human readable app name
	Name *string `json:"name,omitempty"`
}

// CreateAppKeyResponse CreateAppKeyResponse returns created app keys
type CreateAppKeyResponse struct {
	// CreatedAppKey An user AppKey
	CreatedAppKey *AppKey `json:"created_app_key,omitempty"`
}

// CreateBranchRequest defines model for CreateBranchRequest.
type CreateBranchRequest = map[string]interface{}

// CreateBranchResponse defines model for CreateBranchResponse.
type CreateBranchResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "created".
	Status *string `json:"status,omitempty"`
}

// CreateByIdRequest defines model for CreateByIdRequest.
type CreateByIdRequest struct {
	// Document A JSON document that needs to be indexed.
	Document json.RawMessage `json:"document,omitempty"`

	// Id document id.
	Id *string `json:"id,omitempty"`

	// Index index name where to create document.
	Index *string `json:"index,omitempty"`

	// Project Tigris project name.
	Project *string `json:"project,omitempty"`
}

// CreateByIdResponse defines model for CreateByIdResponse.
type CreateByIdResponse struct {
	// Id Returns the id of the created document.
	Id *string `json:"id,omitempty"`
}

// CreateCacheOptions defines model for CreateCacheOptions.
type CreateCacheOptions struct {
	TtlMs *uint64 `json:"ttl_ms,omitempty"`
}

// CreateCacheRequest defines model for CreateCacheRequest.
type CreateCacheRequest struct {
	Options *CreateCacheOptions `json:"options,omitempty"`
}

// CreateCacheResponse defines model for CreateCacheResponse.
type CreateCacheResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "created"
	Status *string `json:"status,omitempty"`
}

// CreateDocumentRequest defines model for CreateDocumentRequest.
type CreateDocumentRequest struct {
	// Documents An array of documents to be created or replaced. Each document is a JSON object.
	Documents *[]json.RawMessage `json:"documents,omitempty"`

	// Index index name where to create documents.
	Index *string `json:"index,omitempty"`

	// Project Tigris project name.
	Project *string `json:"project,omitempty"`
}

// CreateDocumentResponse defines model for CreateDocumentResponse.
type CreateDocumentResponse struct {
	// Status An array of statuses of all the documents received in the request. Order is same as it is received in the request. Each item of this array has an “id” and “error” key. Id is set as document id and error will be null in case of success, otherwise error is set with an error code and message.
	Status *[]DocStatus `json:"status,omitempty"`
}

// CreateNamespaceRequest defines model for CreateNamespaceRequest.
type CreateNamespaceRequest struct {
	// Code Optional: unique id
	Code *uint32 `json:"code,omitempty"`

	// Id Optional: unique string id
	Id *string `json:"id,omitempty"`

	// Name Required: The display name for namespace.
	Name *string `json:"name,omitempty"`
}

// CreateNamespaceResponse defines model for CreateNamespaceResponse.
type CreateNamespaceResponse struct {
	// Message A detailed response message.
	Message   *string        `json:"message,omitempty"`
	Namespace *NamespaceInfo `json:"namespace,omitempty"`

	// Status An enum with value set as "created".
	Status *string `json:"status,omitempty"`
}

// CreateOrReplaceDocumentRequest defines model for CreateOrReplaceDocumentRequest.
type CreateOrReplaceDocumentRequest struct {
	// Documents An array of documents to create. Each document is a JSON object. In case an id is missing then the server will automatically generate it for you and create the document and in case an id is provided in the document and the document already exists then that document will not index and in the response there will be an error corresponding to that document id other documents will succeed.
	Documents *[]json.RawMessage `json:"documents,omitempty"`

	// Index index name where to create documents.
	Index *string `json:"index,omitempty"`

	// Project Project name whose db is under target to insert documents.
	Project *string `json:"project,omitempty"`
}

// CreateOrReplaceDocumentResponse defines model for CreateOrReplaceDocumentResponse.
type CreateOrReplaceDocumentResponse struct {
	// Status An array of statuses of all the documents received in the request. Order is same as it is received in the request. Each item of this array has an “id” and “error” key. Id is set as document id and error will be null in case of success, otherwise error is set with an error code and message.
	Status *[]DocStatus `json:"status,omitempty"`
}

// CreateOrUpdateCollectionRequest defines model for CreateOrUpdateCollectionRequest.
type CreateOrUpdateCollectionRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// OnlyCreate If set to `true` then the update schema request to the collection will fail by returning a conflict with HTTP Status code 409. The default is false.
	OnlyCreate *bool `json:"only_create,omitempty"`

	// Options Collection requests modifying options.
	Options *CollectionOptions `json:"options,omitempty"`

	// Schema The schema specifications are same as JSON schema specification defined <a href="https://json-schema.org/specification.html" title="here">here</a>.<p></p> Schema example: `{  "title": "user",  "description": "Collection of documents with details of users",  "properties": {    "id": {      "description": "A unique identifier for the user",      "type": "integer"    },    "name": {      "description": "Name of the user",      "type": "string",      "maxLength": 128    },    "balance": {      "description": "User account balance",      "type": "number"    }  },  "primary_key": ["id"] }`
	Schema json.RawMessage `json:"schema,omitempty"`
}

// CreateOrUpdateCollectionResponse defines model for CreateOrUpdateCollectionResponse.
type CreateOrUpdateCollectionResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "created" or "updated"
	Status *string `json:"status,omitempty"`
}

// CreateOrUpdateIndexRequest defines model for CreateOrUpdateIndexRequest.
type CreateOrUpdateIndexRequest struct {
	// Name search index name.
	Name *string `json:"name,omitempty"`

	// OnlyCreate If set to `true` then a conflict with HTTP Status code 409 is returned if an index already exists. The default is false.
	OnlyCreate *bool `json:"only_create,omitempty"`

	// Project Tigris project name.
	Project *string `json:"project,omitempty"`

	// Schema schema of the index. The schema specifications are same as JSON schema specification defined <a href="https://json-schema.org/specification.html" title="here">here</a>.<p></p> Schema example: `{  "title": "ecommerce_index",  "description": "an ecommerce store search index",  "properties": {    "name": {      "description": "Name of the product",      "type": "string",      "maxLength": 128    },    "brand": {      "description": "Brand of the product",      "type": "string"    },    "price": {      "description": "Price of the product",      "type": "number"    }  } }`
	Schema json.RawMessage `json:"schema,omitempty"`
}

// CreateOrUpdateIndexResponse defines model for CreateOrUpdateIndexResponse.
type CreateOrUpdateIndexResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "created"
	Status *string `json:"status,omitempty"`
}

// CreateProjectRequest defines model for CreateProjectRequest.
type CreateProjectRequest = map[string]interface{}

// CreateProjectResponse defines model for CreateProjectResponse.
type CreateProjectResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "created".
	Status *string `json:"status,omitempty"`
}

// DataPoint Represents the data point in timeseries.
type DataPoint struct {
	Timestamp *int64   `json:"timestamp,omitempty"`
	Value     *float64 `json:"value,omitempty"`
}

// DatabaseMetadata defines model for DatabaseMetadata.
type DatabaseMetadata = map[string]interface{}

// DelRequest defines model for DelRequest.
type DelRequest = map[string]interface{}

// DelResponse defines model for DelResponse.
type DelResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "deleted" or "not_found"
	Status *string `json:"status,omitempty"`
}

// DeleteAppKeyRequest Request deletion of an app key
type DeleteAppKeyRequest struct {
	// Id app_key id
	Id *string `json:"id,omitempty"`
}

// DeleteAppKeyResponse AppKeys returns the flag to convey if app key was deleted
type DeleteAppKeyResponse struct {
	// Deleted status flag for delete operation
	Deleted *bool `json:"deleted,omitempty"`
}

// DeleteBranchRequest defines model for DeleteBranchRequest.
type DeleteBranchRequest = map[string]interface{}

// DeleteBranchResponse defines model for DeleteBranchResponse.
type DeleteBranchResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "deleted".
	Status *string `json:"status,omitempty"`
}

// DeleteByQueryRequest defines model for DeleteByQueryRequest.
type DeleteByQueryRequest struct {
	// Filter A filter is required to delete matching documents. To delete document by id, you can pass the filter as follows ```{"id": "test"}```
	Filter json.RawMessage `json:"filter,omitempty"`

	// Index The index name of the documents that needs deletion.
	Index *string `json:"index,omitempty"`

	// Project The project name.
	Project *string `json:"project,omitempty"`
}

// DeleteByQueryResponse defines model for DeleteByQueryResponse.
type DeleteByQueryResponse struct {
	// Count The number of documents deleted.
	Count *int32 `json:"count,omitempty"`
}

// DeleteCacheRequest defines model for DeleteCacheRequest.
type DeleteCacheRequest = map[string]interface{}

// DeleteCacheResponse defines model for DeleteCacheResponse.
type DeleteCacheResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "deleted"
	Status *string `json:"status,omitempty"`
}

// DeleteDocumentRequest defines model for DeleteDocumentRequest.
type DeleteDocumentRequest struct {
	// Ids A list of ids
	Ids *[]string `json:"ids,omitempty"`

	// Index The index name of the documents that needs deletion.
	Index *string `json:"index,omitempty"`

	// Project The project name.
	Project *string `json:"project,omitempty"`
}

// DeleteDocumentResponse defines model for DeleteDocumentResponse.
type DeleteDocumentResponse struct {
	// Status An array of statuses of all the documents received in the request. Order is same as it is received in the request. Each item of this array has an “id” and “error” key. Id is set as document id and error will be null in case of success, otherwise error is set with an error code and message.
	Status *[]DocStatus `json:"status,omitempty"`
}

// DeleteIndexRequest defines model for DeleteIndexRequest.
type DeleteIndexRequest struct {
	// Name index name.
	Name *string `json:"name,omitempty"`

	// Project Tigris project name.
	Project *string `json:"project,omitempty"`
}

// DeleteIndexResponse defines model for DeleteIndexResponse.
type DeleteIndexResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "deleted".
	Status *string `json:"status,omitempty"`
}

// DeleteProjectRequest defines model for DeleteProjectRequest.
type DeleteProjectRequest = map[string]interface{}

// DeleteProjectResponse defines model for DeleteProjectResponse.
type DeleteProjectResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "dropped".
	Status *string `json:"status,omitempty"`
}

// DeleteRequest defines model for DeleteRequest.
type DeleteRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Filter Delete documents which matching specified filter. A filter can simply be key, value where key is the field name and value would be the value for this field. Or a filter can be logical where two or more fields can be logically joined using $or and $and. A few examples of filter: <li> To delete a user document where the id has a value 1: ```{"id": 1 }``` <li> To delete all the user documents where the key "id" has a value 1 or 2 or 3: `{"$or": [{"id": 1}, {"id": 2}, {"id": 3}]}`
	Filter json.RawMessage `json:"filter,omitempty"`

	// Options Additional options for deleted requests.
	Options *DeleteRequestOptions `json:"options,omitempty"`
}

// DeleteRequestOptions Additional options for deleted requests.
type DeleteRequestOptions struct {
	// Collation A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// Limit Limit the number of documents to be deleted
	Limit *int64 `json:"limit,omitempty"`

	// WriteOptions Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// DeleteResponse defines model for DeleteResponse.
type DeleteResponse struct {
	// DeletedCount Returns the number of documents deleted.
	DeletedCount *int32 `json:"deleted_count,omitempty"`

	// Metadata Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// Status an enum with value set as "deleted"
	Status *string `json:"status,omitempty"`
}

// DescribeCollectionRequest defines model for DescribeCollectionRequest.
type DescribeCollectionRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Collection Name of the collection.
	Collection *string `json:"collection,omitempty"`

	// Options Collection requests modifying options.
	Options *CollectionOptions `json:"options,omitempty"`

	// Project Project name whose db is under target to get description of its collection.
	Project *string `json:"project,omitempty"`

	// SchemaFormat Return schema in the requested format. Format can be JSON, Go, TypeScript, Java. Default is JSON.
	SchemaFormat *string `json:"schema_format,omitempty"`
}

// DescribeCollectionResponse A detailed description of the collection. The description returns collection metadata and the schema.
type DescribeCollectionResponse struct {
	// Collection Name of the collection.
	Collection *string             `json:"collection,omitempty"`
	Metadata   *CollectionMetadata `json:"metadata,omitempty"`

	// Schema Schema of this collection.
	Schema json.RawMessage `json:"schema,omitempty"`

	// Size The size of this collection in bytes.
	Size *int64 `json:"size,omitempty"`
}

// DescribeDatabaseRequest defines model for DescribeDatabaseRequest.
type DescribeDatabaseRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Project Project name whose db is under target to get description.
	Project *string `json:"project,omitempty"`

	// SchemaFormat Return schema in the requested format. Format can be JSON, Go, TypeScript, Java. Default is JSON.
	SchemaFormat *string `json:"schema_format,omitempty"`
}

// DescribeDatabaseResponse A detailed description of the database and all the associated collections. Description of the collection includes schema details as well.
type DescribeDatabaseResponse struct {
	// Branches List of all the branches in this database
	Branches *[]string `json:"branches,omitempty"`

	// Collections A detailed description about all the collections. The description returns collection metadata and the schema.
	Collections *[]CollectionDescription `json:"collections,omitempty"`
	Metadata    *DatabaseMetadata        `json:"metadata,omitempty"`

	// Size Sum of all the collections sizes present in this database
	Size *int64 `json:"size,omitempty"`
}

// DescribeNamespacesData defines model for DescribeNamespacesData.
type DescribeNamespacesData struct {
	Details *string `json:"details,omitempty"`
}

// DescribeNamespacesResponse defines model for DescribeNamespacesResponse.
type DescribeNamespacesResponse struct {
	Data *DescribeNamespacesData `json:"data,omitempty"`
}

// DocStatus defines model for DocStatus.
type DocStatus struct {
	// Error The Error type defines a logical error model
	Error *Error `json:"error,omitempty"`

	// Id An id of the document.
	Id *string `json:"id,omitempty"`
}

// DropCollectionRequest defines model for DropCollectionRequest.
type DropCollectionRequest struct {
	// Branch Optionally specify a project branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Options Collection requests modifying options.
	Options *CollectionOptions `json:"options,omitempty"`
}

// DropCollectionResponse defines model for DropCollectionResponse.
type DropCollectionResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "dropped".
	Status *string `json:"status,omitempty"`
}

// Error The Error type defines a logical error model
type Error struct {
	// Code The status code is a short, machine parsable string, which uniquely identifies the error type. Tigris to HTTP code mapping [here](/reference/http-code)
	Code *ErrorCode `json:"code,omitempty"`

	// Message A developer-facing descriptive error message
	Message *string `json:"message,omitempty"`
}

// ErrorCode The status code is a short, machine parsable string, which uniquely identifies the error type. Tigris to HTTP code mapping [here](/reference/http-code)
type ErrorCode string

// FacetCount defines model for FacetCount.
type FacetCount struct {
	Count *int64  `json:"count,omitempty"`
	Value *string `json:"value,omitempty"`
}

// FacetStats Additional stats for faceted field
type FacetStats struct {
	// Avg Average of all values in a field. Only available for numeric fields
	Avg *float64 `json:"avg,omitempty"`

	// Count Total number of values in a field
	Count *int64 `json:"count,omitempty"`

	// Max Maximum of all values in a field. Only available for numeric fields
	Max *float64 `json:"max,omitempty"`

	// Min Minimum of all values in a field. Only available for numeric fields
	Min *float64 `json:"min,omitempty"`

	// Sum Sum of all values in a field. Only available for numeric fields
	Sum *float64 `json:"sum,omitempty"`
}

// GetAccessTokenRequest The Request message for the GetAccessToken. The grant type is a required field and based on the grant type the other fields are used as mentioned below.
type GetAccessTokenRequest struct {
	// ClientId Client Id is required when grant type is set as `CLIENT_CREDENTIALS`.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Your Tigris API Key is required when grant type is set as `CLIENT_CREDENTIALS`.
	ClientSecret *string                         `json:"client_secret,omitempty"`
	GrantType    *GetAccessTokenRequestGrantType `json:"grant_type,omitempty"`

	// RefreshToken Refresh token is required when grant type is set as `REFRESH_TOKEN`.
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// GetAccessTokenRequestGrantType defines model for GetAccessTokenRequest.GrantType.
type GetAccessTokenRequestGrantType string

// GetAccessTokenResponse The response of GetAccessToken which contains access_token and optionally refresh_token.
type GetAccessTokenResponse struct {
	// AccessToken An Access Token.
	AccessToken *string `json:"access_token,omitempty"`

	// ExpiresIn Access token expiration timeout in seconds.
	ExpiresIn *int32 `json:"expires_in,omitempty"`

	// RefreshToken The Refresh Token.
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// GetDocumentResponse defines model for GetDocumentResponse.
type GetDocumentResponse struct {
	// Documents An array of documents.
	Documents *[]SearchHit `json:"documents,omitempty"`
}

// GetIndexResponse defines model for GetIndexResponse.
type GetIndexResponse struct {
	Index *IndexInfo `json:"index,omitempty"`
}

// GetInfoResponse defines model for GetInfoResponse.
type GetInfoResponse struct {
	ServerVersion *string `json:"server_version,omitempty"`
}

// GetNamespaceMetadataRequest Request namespace metadata
type GetNamespaceMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// GetNamespaceMetadataResponse Namespace metadata response
type GetNamespaceMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// GetRTChannelResponse defines model for GetRTChannelResponse.
type GetRTChannelResponse struct {
	Channel *string `json:"channel,omitempty"`
}

// GetRTChannelsResponse defines model for GetRTChannelsResponse.
type GetRTChannelsResponse struct {
	Channels *[]ChannelMetadata `json:"channels,omitempty"`
}

// GetResponse defines model for GetResponse.
type GetResponse struct {
	// ExpiresInMs expiration ms
	ExpiresInMs *uint64 `json:"expires_in_ms,omitempty"`

	// Value value
	Value *[]byte `json:"value,omitempty"`
}

// GetSetRequest defines model for GetSetRequest.
type GetSetRequest struct {
	// Value free form byte[] value
	Value *[]byte `json:"value,omitempty"`
}

// GetSetResponse defines model for GetSetResponse.
type GetSetResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// OldValue An old value if exists
	OldValue *[]byte `json:"old_value,omitempty"`

	// Status An enum with value set as "set"
	Status *string `json:"status,omitempty"`
}

// GetUserMetadataRequest Request user metadata
type GetUserMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// GetUserMetadataResponse User metadata response
type GetUserMetadataResponse struct {
	MetadataKey *string `json:"metadataKey,omitempty"`
	NamespaceId *uint32 `json:"namespaceId,omitempty"`
	UserId      *string `json:"userId,omitempty"`
	Value       *[]byte `json:"value,omitempty"`
}

// GroupedSearchHits defines model for GroupedSearchHits.
type GroupedSearchHits struct {
	GroupKeys *[]string    `json:"group_keys,omitempty"`
	Hits      *[]SearchHit `json:"hits,omitempty"`
}

// HealthCheckResponse defines model for HealthCheckResponse.
type HealthCheckResponse struct {
	Response *string `json:"response,omitempty"`
}

// ImportRequest defines model for ImportRequest.
type ImportRequest struct {
	// Autogenerated The list of autogenerated fields of the collection
	Autogenerated *[]string `json:"autogenerated,omitempty"`

	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// CreateCollection Allow to create collection if it doesn't exists
	CreateCollection *bool `json:"create_collection,omitempty"`

	// Documents Array of documents to import. Each document is a JSON object.
	Documents *[]map[string]interface{} `json:"documents,omitempty"`

	// Options additional options for import requests.
	Options *ImportRequestOptions `json:"options,omitempty"`

	// PrimaryKey List of fields which constitutes primary key of the collection If not specified and field with name 'id' is present, it's used as a primary key, further if inferred type is UUID, then it's set as autogenerated.
	PrimaryKey *[]string `json:"primary_key,omitempty"`
}

// ImportRequestOptions additional options for import requests.
type ImportRequestOptions struct {
	// WriteOptions Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// ImportResponse defines model for ImportResponse.
type ImportResponse struct {
	// Keys an array returns the value of the primary keys.
	Keys *[][]byte `json:"keys,omitempty"`

	// Metadata Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// Status An enum with value set as "inserted"
	Status *string `json:"status,omitempty"`
}

// IndexInfo defines model for IndexInfo.
type IndexInfo struct {
	// Name Name of the index.
	Name *string `json:"name,omitempty"`

	// Schema Schema of the index.
	Schema json.RawMessage `json:"schema,omitempty"`
}

// InsertNamespaceMetadataRequest Request insertion of namespace metadata
type InsertNamespaceMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// InsertNamespaceMetadataResponse Insertion of namespace metadata response
type InsertNamespaceMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// InsertRequest defines model for InsertRequest.
type InsertRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Documents Array of documents to insert. Each document is a JSON object.
	Documents *[]json.RawMessage `json:"documents,omitempty"`

	// Options additional options for insert requests.
	Options *InsertRequestOptions `json:"options,omitempty"`
}

// InsertRequestOptions additional options for insert requests.
type InsertRequestOptions struct {
	// WriteOptions Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// InsertResponse defines model for InsertResponse.
type InsertResponse struct {
	// Keys an array returns the value of the primary keys.
	Keys *[][]byte `json:"keys,omitempty"`

	// Metadata Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// Status An enum with value set as "inserted"
	Status *string `json:"status,omitempty"`
}

// InsertUserMetadataRequest Request insertion of user metadata
type InsertUserMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// InsertUserMetadataResponse Insertion of user metadata response
type InsertUserMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	UserId      *string                 `json:"userId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// KeysResponse defines model for KeysResponse.
type KeysResponse struct {
	// Cursor cursor - 0 is the keys scan is finished, non-zero cursor can be passed in next keys request to continue the scan this is useful if streaming breaks and user wants to resume stream
	Cursor *uint64 `json:"cursor,omitempty"`

	// Keys keys
	Keys *[]string `json:"keys,omitempty"`
}

// ListAppKeysResponse ListAppKeysResponse returns one or more visible app keys to user
type ListAppKeysResponse struct {
	AppKeys *[]AppKey `json:"app_keys,omitempty"`
}

// ListBranchesResponse defines model for ListBranchesResponse.
type ListBranchesResponse struct {
	// Branches List of all the branches in this database
	Branches *[]BranchInfo `json:"branches,omitempty"`
}

// ListCachesResponse defines model for ListCachesResponse.
type ListCachesResponse struct {
	// Caches List of caches metadata
	Caches *[]CacheMetadata `json:"caches,omitempty"`
}

// ListCollectionsResponse defines model for ListCollectionsResponse.
type ListCollectionsResponse struct {
	// Collections List of the collections info in the database.
	Collections *[]CollectionInfo `json:"collections,omitempty"`
}

// ListIndexesResponse defines model for ListIndexesResponse.
type ListIndexesResponse struct {
	// Indexes List of indexes.
	Indexes *[]IndexInfo `json:"indexes,omitempty"`
}

// ListNamespacesResponse defines model for ListNamespacesResponse.
type ListNamespacesResponse struct {
	Namespaces *[]NamespaceInfo `json:"namespaces,omitempty"`
}

// ListProjectsResponse defines model for ListProjectsResponse.
type ListProjectsResponse struct {
	// Projects List of the projects.
	Projects *[]ProjectInfo `json:"projects,omitempty"`
}

// ListSubscriptionResponse defines model for ListSubscriptionResponse.
type ListSubscriptionResponse struct {
	Devices *[]string `json:"devices,omitempty"`
}

// Match defines model for Match.
type Match struct {
	Fields *[]MatchField `json:"fields,omitempty"`
	Score  *string       `json:"score,omitempty"`
}

// MatchField defines model for MatchField.
type MatchField struct {
	Name *string `json:"name,omitempty"`
}

// Message defines model for Message.
type Message struct {
	Data *[]byte `json:"data,omitempty"`

	// Id an optional id if idempotency is needed to ensure only a single time message is published during retries. If not specified then server will automatically add an id to message.
	Id       *string `json:"id,omitempty"`
	Name     *string `json:"name,omitempty"`
	Sequence *string `json:"sequence,omitempty"`
}

// MessagesRequest defines model for MessagesRequest.
type MessagesRequest struct {
	Channel  *string    `json:"channel,omitempty"`
	Messages *[]Message `json:"messages,omitempty"`
	Project  *string    `json:"project,omitempty"`
}

// MessagesResponse defines model for MessagesResponse.
type MessagesResponse struct {
	// Ids ids of the published messages
	Ids *[]string `json:"ids,omitempty"`
}

// MetricSeries Represents series in timeseries based on input query.
type MetricSeries struct {
	DataPoints *[]DataPoint `json:"dataPoints,omitempty"`
	From       *int64       `json:"from,omitempty"`
	Metric     *string      `json:"metric,omitempty"`
	Scope      *string      `json:"scope,omitempty"`
	To         *int64       `json:"to,omitempty"`
}

// NamespaceInfo defines model for NamespaceInfo.
type NamespaceInfo struct {
	// Code The unique namespace code.
	Code *int32 `json:"code,omitempty"`

	// Id The namespace unique id.
	Id *string `json:"id,omitempty"`

	// Name The namespace display name.
	Name *string `json:"name,omitempty"`
}

// Page Pagination metadata for SearchResponse
type Page struct {
	// Current Number representing the current page of results
	Current *int32 `json:"current,omitempty"`

	// Size Maximum number of results per page
	Size *int32 `json:"size,omitempty"`
}

// PresenceResponse defines model for PresenceResponse.
type PresenceResponse struct {
	Response *[]byte `json:"response,omitempty"`
}

// ProjectInfo defines model for ProjectInfo.
type ProjectInfo struct {
	Metadata *ProjectMetadata `json:"metadata,omitempty"`

	// Project Project name.
	Project *string `json:"project,omitempty"`
}

// ProjectMetadata defines model for ProjectMetadata.
type ProjectMetadata = map[string]interface{}

// QueryTimeSeriesMetricsRequest Requests the time series metrics
type QueryTimeSeriesMetricsRequest struct {
	AdditionalFunctions *[]AdditionalFunction                          `json:"additionalFunctions,omitempty"`
	Branch              *string                                        `json:"branch,omitempty"`
	Collection          *string                                        `json:"collection,omitempty"`
	Db                  *string                                        `json:"db,omitempty"`
	From                *int64                                         `json:"from,omitempty"`
	Function            *QueryTimeSeriesMetricsRequestFunction         `json:"function,omitempty"`
	MetricName          *string                                        `json:"metric_name,omitempty"`
	Quantile            *float32                                       `json:"quantile,omitempty"`
	SpaceAggregatedBy   *[]string                                      `json:"space_aggregated_by,omitempty"`
	SpaceAggregation    *QueryTimeSeriesMetricsRequestSpaceAggregation `json:"space_aggregation,omitempty"`
	TigrisOperation     *QueryTimeSeriesMetricsRequestTigrisOperation  `json:"tigris_operation,omitempty"`
	To                  *int64                                         `json:"to,omitempty"`
}

// QueryTimeSeriesMetricsRequestFunction defines model for QueryTimeSeriesMetricsRequest.Function.
type QueryTimeSeriesMetricsRequestFunction string

// QueryTimeSeriesMetricsRequestSpaceAggregation defines model for QueryTimeSeriesMetricsRequest.SpaceAggregation.
type QueryTimeSeriesMetricsRequestSpaceAggregation string

// QueryTimeSeriesMetricsRequestTigrisOperation defines model for QueryTimeSeriesMetricsRequest.TigrisOperation.
type QueryTimeSeriesMetricsRequestTigrisOperation string

// QueryTimeSeriesMetricsResponse QueryTimeSeriesMetric responds with this type.
type QueryTimeSeriesMetricsResponse struct {
	From   *int64          `json:"from,omitempty"`
	Query  *string         `json:"query,omitempty"`
	Series *[]MetricSeries `json:"series,omitempty"`
	To     *int64          `json:"to,omitempty"`
}

// QuotaLimitsRequest Request current namespace quota limits
type QuotaLimitsRequest = map[string]interface{}

// QuotaLimitsResponse Contains current quota limits
type QuotaLimitsResponse struct {
	// ReadUnits Number of allowed read units per second
	ReadUnits *int64 `json:"ReadUnits,omitempty"`

	// StorageSize Maximum number of bytes allowed to store
	StorageSize *int64 `json:"StorageSize,omitempty"`

	// WriteUnits Number of allowed write units per second
	WriteUnits *int64 `json:"WriteUnits,omitempty"`
}

// QuotaUsageRequest Request current namespace quota usage
type QuotaUsageRequest = map[string]interface{}

// QuotaUsageResponse Contains current quota usage
type QuotaUsageResponse struct {
	// ReadUnits Number of read units used per second
	ReadUnits *int64 `json:"ReadUnits,omitempty"`

	// ReadUnitsThrottled Number of read units throttled per second. Units which was rejected with "resource exhausted error".
	ReadUnitsThrottled *int64 `json:"ReadUnitsThrottled,omitempty"`

	// StorageSize Number of bytes stored
	StorageSize *int64 `json:"StorageSize,omitempty"`

	// StorageSizeThrottled Number of bytes throttled. Number of bytes which were attempted to write in excess of quota and were rejected.
	StorageSizeThrottled *int64 `json:"StorageSizeThrottled,omitempty"`

	// WriteUnits Number of write units used per second
	WriteUnits *int64 `json:"WriteUnits,omitempty"`

	// WriteUnitsThrottled Number of write units throttled per second. Units which was rejected with "resource exhausted error".
	WriteUnitsThrottled *int64 `json:"WriteUnitsThrottled,omitempty"`
}

// ReadMessagesResponse defines model for ReadMessagesResponse.
type ReadMessagesResponse struct {
	Message *Message `json:"message,omitempty"`
}

// ReadRequest defines model for ReadRequest.
type ReadRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Fields To read specific fields from a document. Default is all.
	Fields json.RawMessage `json:"fields,omitempty"`

	// Filter Returns documents matching this filter. A filter can simply be a key, value pair where a key is the field name and the value would be the value for this field. Tigris also allows complex filtering by passing logical expressions. Logical filters are applied on two or more fields using `$or` and `$and`. A few examples of filters: <li> To read a user document where the id has a value 1: ```{"id": 1 }``` <li> To read all the user documents where the key "id" has a value 1 or 2 or 3: `{"$or": [{"id": 1}, {"id": 2}, {"id": 3}]}` Filter allows setting collation on an individual field level. To set collation for all the fields see options. The detailed documentation of the filter is <a href="https://docs.tigrisdata.com/overview/query#specification-1" title="here">here</a>.
	Filter json.RawMessage `json:"filter,omitempty"`

	// Options Options that can be used to modify the results, for example "limit" to control the number of documents returned by the server.
	Options *ReadRequestOptions `json:"options,omitempty"`

	// Sort Array of fields and corresponding sort orders to order the results. Ex: 1 `[{ "salary": "$desc" }]`, Ex: 2  `[{ "salary": "$asc"}]`
	Sort *[]byte `json:"sort,omitempty"`
}

// ReadRequestOptions Options that can be used to modify the results, for example "limit" to control the number of documents returned by the server.
type ReadRequestOptions struct {
	// Collation A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// Limit Limit the number of documents returned by the read operation.
	Limit *int64 `json:"limit,omitempty"`

	// Offset A cursor for use in pagination. The next streams will return documents after this offset.
	Offset *[]byte `json:"offset,omitempty"`

	// Skip Number of documents to skip before starting to return resulting documents.
	Skip *int64 `json:"skip,omitempty"`
}

// ReadResponse defines model for ReadResponse.
type ReadResponse struct {
	// Data Object containing the collection document.
	Data json.RawMessage `json:"data,omitempty"`

	// Metadata Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// ResumeToken An internal key, used for pagination.
	ResumeToken *[]byte `json:"resume_token,omitempty"`
}

// ReplaceRequest defines model for ReplaceRequest.
type ReplaceRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Documents Array of documents to be replaced. Each document is a JSON object.
	Documents *[]json.RawMessage `json:"documents,omitempty"`

	// Options Additional options for replace requests.
	Options *ReplaceRequestOptions `json:"options,omitempty"`
}

// ReplaceRequestOptions Additional options for replace requests.
type ReplaceRequestOptions struct {
	// WriteOptions Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// ReplaceResponse defines model for ReplaceResponse.
type ReplaceResponse struct {
	// Keys an array returns the value of the primary keys.
	Keys *[][]byte `json:"keys,omitempty"`

	// Metadata Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// Status an enum with value set as "replaced"
	Status *string `json:"status,omitempty"`
}

// ResponseMetadata Has metadata related to the documents stored.
type ResponseMetadata struct {
	// CreatedAt Time at which the document was inserted/replaced. Measured in nano-seconds since the Unix epoch.
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DeletedAt Time at which the document was deleted. Measured in nano-seconds since the Unix epoch.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// UpdatedAt Time at which the document was updated. Measured in nano-seconds since the Unix epoch.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// RollbackTransactionRequest Rollback transaction with the given ID
type RollbackTransactionRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`
}

// RollbackTransactionResponse defines model for RollbackTransactionResponse.
type RollbackTransactionResponse struct {
	// Status Status of rollback transaction operation.
	Status *string `json:"status,omitempty"`
}

// RollupFunction Rollup function aggregates the slices of metrics returned by original query and lets you operate on the slices using aggregator and constructs the bigger slice of your choice of interval (specified in seconds).
type RollupFunction struct {
	Aggregator *RollupFunctionAggregator `json:"aggregator,omitempty"`
	Interval   *int64                    `json:"interval,omitempty"`
}

// RollupFunctionAggregator defines model for RollupFunction.Aggregator.
type RollupFunctionAggregator string

// RotateAppKeyRequest Request rotation of an app key secret
type RotateAppKeyRequest struct {
	// Id app key id
	Id *string `json:"id,omitempty"`

	// Project project name
	Project *string `json:"project,omitempty"`
}

// RotateAppKeyResponse RotateAppKeyResponse returns the new app key with rotated secret
type RotateAppKeyResponse struct {
	// AppKey An user AppKey
	AppKey *AppKey `json:"app_key,omitempty"`
}

// SearchFacet defines model for SearchFacet.
type SearchFacet struct {
	Counts *[]FacetCount `json:"counts,omitempty"`

	// Stats Additional stats for faceted field
	Stats *FacetStats `json:"stats,omitempty"`
}

// SearchHit defines model for SearchHit.
type SearchHit struct {
	// Data Actual search document
	Data json.RawMessage `json:"data,omitempty"`

	// Metadata Contains metadata related to the search hit, has information about document created_at/updated_at as well.
	Metadata *SearchHitMeta `json:"metadata,omitempty"`
}

// SearchHitMeta Contains metadata related to the search hit, has information about document created_at/updated_at as well.
type SearchHitMeta struct {
	// CreatedAt Time at which the document was inserted/replaced. Measured in nano-seconds since the Unix epoch.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Match     *Match     `json:"match,omitempty"`

	// UpdatedAt Time at which the document was updated. Measured in nano-seconds since the Unix epoch.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// SearchIndexRequest defines model for SearchIndexRequest.
type SearchIndexRequest struct {
	// Collation A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// ExcludeFields Array of document field names to exclude from results. `include_fields`, if specified, takes precedence over `exclude_fields`.
	ExcludeFields *[]string `json:"exclude_fields,omitempty"`

	// Facet Facet query to aggregate results on given fields. The field name for the facet search can be passed like this `{"brand": { "size": 10 }}` where the size controls the total facets for this field.
	Facet json.RawMessage `json:"facet,omitempty"`

	// Filter Filter stacks on top of query results to further narrow down the results. Similar to `ReadRequest.filter`
	Filter json.RawMessage `json:"filter,omitempty"`

	// GroupBy Group by can be used to group search results. For example, to group by city field the syntax would be: `{ "fields": ["city"]}`. Optionally a grouping limit can be set. By default it is 3 per group.
	GroupBy *[]byte `json:"group_by,omitempty"`

	// IncludeFields Array of document field names to include in results. By default, all fields are included.
	IncludeFields *[]string `json:"include_fields,omitempty"`

	// Index The index name to search documents from.
	Index *string `json:"index,omitempty"`

	// Page Optionally can specify the page to retrieve. If page is set then only hits for this page is returned
	Page *int32 `json:"page,omitempty"`

	// PageSize Optionally can set the number of hits to be returned per page, default is 20.
	PageSize *int32 `json:"page_size,omitempty"`

	// Project Project name whose db is under target to search documents from.
	Project *string `json:"project,omitempty"`

	// Q Query string for searching across text fields
	Q *string `json:"q,omitempty"`

	// SearchFields Array of fields to project search query against
	SearchFields *[]string `json:"search_fields,omitempty"`

	// Sort Array of fields and corresponding sort orders to order the results `[{ "salary": "$desc" }]`
	Sort json.RawMessage `json:"sort,omitempty"`
}

// SearchIndexResponse defines model for SearchIndexResponse.
type SearchIndexResponse struct {
	Facets *map[string]SearchFacet `json:"facets,omitempty"`

	// Group Group is returned when group_by is used in the search request. In this case the above hits will be empty and hits are returned by the group keys.
	Group *[]GroupedSearchHits `json:"group,omitempty"`
	Hits  *[]SearchHit         `json:"hits,omitempty"`
	Meta  *SearchMetadata      `json:"meta,omitempty"`
}

// SearchMetadata defines model for SearchMetadata.
type SearchMetadata struct {
	// Found Total number of search results across all pages
	Found         *int64    `json:"found,omitempty"`
	MatchedFields *[]string `json:"matched_fields,omitempty"`

	// Page Pagination metadata for SearchResponse
	Page *Page `json:"page,omitempty"`

	// TotalPages Number representing the total pages of results
	TotalPages *int32 `json:"total_pages,omitempty"`
}

// SearchRequest defines model for SearchRequest.
type SearchRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Collation A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// ExcludeFields Array of document field names to exclude from results. `include_fields`, if specified, takes precedence over `exclude_fields`.
	ExcludeFields *[]string `json:"exclude_fields,omitempty"`

	// Facet Facet query to aggregate results on given fields. The field name for the facet search can be passed like this `{"brand": { "size": 10 }}` where the size controls the total facets for this field.
	Facet  json.RawMessage `json:"facet,omitempty"`
	Fields json.RawMessage `json:"fields,omitempty"`

	// Filter Filter stacks on top of query results to further narrow down the results. Similar to `ReadRequest.filter`
	Filter json.RawMessage `json:"filter,omitempty"`

	// IncludeFields Array of document field names to include in results. By default, all fields are included.
	IncludeFields *[]string `json:"include_fields,omitempty"`

	// Page Optionally can specify the page to retrieve. If page is set then only hits for this page is returned
	Page *int32 `json:"page,omitempty"`

	// PageSize Optionally can set the number of hits to be returned per page, default is 20.
	PageSize *int32 `json:"page_size,omitempty"`

	// Q Query string for searching across text fields
	Q *string `json:"q,omitempty"`

	// SearchFields Array of fields to project search query against
	SearchFields *[]string `json:"search_fields,omitempty"`

	// Sort Array of fields and corresponding sort orders to order the results `[{ "salary": "$desc" }]`
	Sort json.RawMessage `json:"sort,omitempty"`
}

// SearchResponse Response struct for search
type SearchResponse struct {
	Facets *map[string]SearchFacet `json:"facets,omitempty"`
	Hits   *[]SearchHit            `json:"hits,omitempty"`
	Meta   *SearchMetadata         `json:"meta,omitempty"`
}

// SetRequest defines model for SetRequest.
type SetRequest struct {
	// Ex optional - ttl specific to this key in second
	Ex *uint64 `json:"ex,omitempty"`

	// Nx set only if the key doesn't exist
	Nx *bool `json:"nx,omitempty"`

	// Px optional - ttl specific to this key in millisecond
	Px *uint64 `json:"px,omitempty"`

	// Value free form byte[] value
	Value *[]byte `json:"value,omitempty"`

	// Xx set only if the key exist
	Xx *bool `json:"xx,omitempty"`
}

// SetResponse defines model for SetResponse.
type SetResponse struct {
	// Message A detailed response message.
	Message *string `json:"message,omitempty"`

	// Status An enum with value set as "set"
	Status *string `json:"status,omitempty"`
}

// Status defines model for Status.
type Status struct {
	// Error The Error type defines a logical error model
	Error *Error `json:"error,omitempty"`
}

// StreamingReadResponse defines model for StreamingReadResponse.
type StreamingReadResponse struct {
	// Error The Error type defines a logical error model
	Error  *Error        `json:"error,omitempty"`
	Result *ReadResponse `json:"result,omitempty"`
}

// StreamingSearchResponse defines model for StreamingSearchResponse.
type StreamingSearchResponse struct {
	// Error The Error type defines a logical error model
	Error *Error `json:"error,omitempty"`

	// Result Response struct for search
	Result *SearchResponse `json:"result,omitempty"`
}

// TransactionCtx Contains ID which uniquely identifies transaction This context is returned by BeginTransaction request and should be passed in the metadata (headers) of subsequent requests in order to run them in the context of the same transaction.
type TransactionCtx struct {
	// Id Unique for a single transactional request.
	Id *string `json:"id,omitempty"`

	// Origin Serves as an internal identifier.
	Origin *string `json:"origin,omitempty"`
}

// TransactionOptions Options that can be used to modify the transaction semantics.
type TransactionOptions = map[string]interface{}

// UpdateAppKeyRequest To update the description of the app key
type UpdateAppKeyRequest struct {
	// Description A new human readable app description
	Description *string `json:"description,omitempty"`

	// Id app key id - this is not allowed to update
	Id *string `json:"id,omitempty"`

	// Name A new human readable app name
	Name *string `json:"name,omitempty"`
}

// UpdateAppKeyResponse Returns response for updating the app key description
type UpdateAppKeyResponse struct {
	// UpdatedAppKey An user AppKey
	UpdatedAppKey *AppKey `json:"updated_app_key,omitempty"`
}

// UpdateDocumentRequest defines model for UpdateDocumentRequest.
type UpdateDocumentRequest struct {
	// Documents An array of documents. Each document should have "id" present which will be used by Tigris for updating the document.
	Documents *[]json.RawMessage `json:"documents,omitempty"`

	// Index Index name where to create documents.
	Index *string `json:"index,omitempty"`

	// Project Project name whose db is under target to insert documents.
	Project *string `json:"project,omitempty"`
}

// UpdateDocumentResponse defines model for UpdateDocumentResponse.
type UpdateDocumentResponse struct {
	// Status An array of statuses of all the documents received in the request. Order is same as it is received in the request. Each item of this array has an “id” and “error” key. Id is set as document id and error will be null in case of success, otherwise error is set with an error code and message.
	Status *[]DocStatus `json:"status,omitempty"`
}

// UpdateNamespaceMetadataRequest Request update of namespace metadata
type UpdateNamespaceMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// UpdateNamespaceMetadataResponse Update of namespace metadata response
type UpdateNamespaceMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// UpdateRequest defines model for UpdateRequest.
type UpdateRequest struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `json:"branch,omitempty"`

	// Fields Fields contains set of fields with the values which need to be updated. Should be proper JSON object.
	Fields json.RawMessage `json:"fields,omitempty"`

	// Filter Update documents which matching specified filter. A filter can simply be key, value where key is the field name and value would be the value for this field. Or a filter can be logical where two or more fields can be logically joined using $or and $and. A few examples of filter: <li> To update a user document where the id has a value 1: ```{"id": 1 }``` <li> To update all the user documents where the key "id" has a value 1 or 2 or 3: `{"$or": [{"id": 1}, {"id": 2}, {"id": 3}]}`
	Filter json.RawMessage `json:"filter,omitempty"`

	// Options Additional options for update requests.
	Options *UpdateRequestOptions `json:"options,omitempty"`
}

// UpdateRequestOptions Additional options for update requests.
type UpdateRequestOptions struct {
	// Collation A collation allows you to specify string comparison rules. Default is case-sensitive, to override it you can set this option to 'ci' that will apply to all the text fields in the filters.
	Collation *Collation `json:"collation,omitempty"`

	// Limit Limit the number of documents to be updated
	Limit *int64 `json:"limit,omitempty"`

	// WriteOptions Additional options to modify write requests.
	WriteOptions *WriteOptions `json:"write_options,omitempty"`
}

// UpdateResponse defines model for UpdateResponse.
type UpdateResponse struct {
	// Metadata Has metadata related to the documents stored.
	Metadata *ResponseMetadata `json:"metadata,omitempty"`

	// ModifiedCount Returns the number of documents modified.
	ModifiedCount *int32 `json:"modified_count,omitempty"`

	// Status an enum with value set as "updated".
	Status *string `json:"status,omitempty"`
}

// UpdateUserMetadataRequest Request update of user metadata
type UpdateUserMetadataRequest struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// UpdateUserMetadataResponse Update of user metadata response
type UpdateUserMetadataResponse struct {
	MetadataKey *string                 `json:"metadataKey,omitempty"`
	NamespaceId *uint32                 `json:"namespaceId,omitempty"`
	UserId      *string                 `json:"userId,omitempty"`
	Value       *map[string]interface{} `json:"value,omitempty"`
}

// WriteOptions Additional options to modify write requests.
type WriteOptions = map[string]interface{}

// CacheKeysParams defines parameters for CacheKeys.
type CacheKeysParams struct {
	// Cursor optional - cursor - skip this argument if no cursor is associated
	Cursor *uint64 `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Count optional - count of keys to return a stream response line.
	Count *int64 `form:"count,omitempty" json:"count,omitempty"`

	// Pattern optional key pattern
	Pattern *string `form:"pattern,omitempty" json:"pattern,omitempty"`
}

// TigrisListCollectionsParams defines parameters for TigrisListCollections.
type TigrisListCollectionsParams struct {
	// Branch Optionally specify a database branch name to perform operation on
	Branch *string `form:"branch,omitempty" json:"branch,omitempty"`
}

// RealtimeReadMessagesParams defines parameters for RealtimeReadMessages.
type RealtimeReadMessagesParams struct {
	SessionId *string `form:"session_id,omitempty" json:"session_id,omitempty"`
	SocketId  *string `form:"socket_id,omitempty" json:"socket_id,omitempty"`
	Event     *string `form:"event,omitempty" json:"event,omitempty"`
	Start     *string `form:"start,omitempty" json:"start,omitempty"`
	End       *string `form:"end,omitempty" json:"end,omitempty"`
	Limit     *int64  `form:"limit,omitempty" json:"limit,omitempty"`
}

// RealtimeListSubscriptionsParams defines parameters for RealtimeListSubscriptions.
type RealtimeListSubscriptionsParams struct {
	PageSize *int32 `form:"page_size,omitempty" json:"page_size,omitempty"`
	Page     *int32 `form:"page,omitempty" json:"page,omitempty"`
}

// SearchListIndexesParams defines parameters for SearchListIndexes.
type SearchListIndexesParams struct {
	// FilterType An index can be either managed by user explicitly then the type is set as "user" or the index is backed by Tigris collection. In case it is backed by Tigris collection the type is "tigris".
	FilterType *string `form:"filter.type,omitempty" json:"filter.type,omitempty"`

	// FilterCollection Applicable only in case index is backed by Tigris collection.
	FilterCollection *string `form:"filter.collection,omitempty" json:"filter.collection,omitempty"`

	// FilterBranch Applicable only in case index is backed by Tigris collection. This is the database branch for the above collection. For primary database it can be omitted or "main" can be passed.
	FilterBranch *string `form:"filter.branch,omitempty" json:"filter.branch,omitempty"`
}

// SearchGetParams defines parameters for SearchGet.
type SearchGetParams struct {
	// Ids document id.
	Ids *[]string `form:"ids,omitempty" json:"ids,omitempty"`
}

// ManagementGetNamespaceMetadataJSONRequestBody defines body for ManagementGetNamespaceMetadata for application/json ContentType.
type ManagementGetNamespaceMetadataJSONRequestBody = GetNamespaceMetadataRequest

// ManagementInsertNamespaceMetadataJSONRequestBody defines body for ManagementInsertNamespaceMetadata for application/json ContentType.
type ManagementInsertNamespaceMetadataJSONRequestBody = InsertNamespaceMetadataRequest

// ManagementUpdateNamespaceMetadataJSONRequestBody defines body for ManagementUpdateNamespaceMetadata for application/json ContentType.
type ManagementUpdateNamespaceMetadataJSONRequestBody = UpdateNamespaceMetadataRequest

// ManagementCreateNamespaceJSONRequestBody defines body for ManagementCreateNamespace for application/json ContentType.
type ManagementCreateNamespaceJSONRequestBody = CreateNamespaceRequest

// ManagementGetUserMetadataJSONRequestBody defines body for ManagementGetUserMetadata for application/json ContentType.
type ManagementGetUserMetadataJSONRequestBody = GetUserMetadataRequest

// ManagementInsertUserMetadataJSONRequestBody defines body for ManagementInsertUserMetadata for application/json ContentType.
type ManagementInsertUserMetadataJSONRequestBody = InsertUserMetadataRequest

// ManagementUpdateUserMetadataJSONRequestBody defines body for ManagementUpdateUserMetadata for application/json ContentType.
type ManagementUpdateUserMetadataJSONRequestBody = UpdateUserMetadataRequest

// ObservabilityQueryTimeSeriesMetricsJSONRequestBody defines body for ObservabilityQueryTimeSeriesMetrics for application/json ContentType.
type ObservabilityQueryTimeSeriesMetricsJSONRequestBody = QueryTimeSeriesMetricsRequest

// ObservabilityQuotaLimitsJSONRequestBody defines body for ObservabilityQuotaLimits for application/json ContentType.
type ObservabilityQuotaLimitsJSONRequestBody = QuotaLimitsRequest

// ObservabilityQuotaUsageJSONRequestBody defines body for ObservabilityQuotaUsage for application/json ContentType.
type ObservabilityQuotaUsageJSONRequestBody = QuotaUsageRequest

// TigrisCreateAppKeyJSONRequestBody defines body for TigrisCreateAppKey for application/json ContentType.
type TigrisCreateAppKeyJSONRequestBody = CreateAppKeyRequest

// TigrisDeleteAppKeyJSONRequestBody defines body for TigrisDeleteAppKey for application/json ContentType.
type TigrisDeleteAppKeyJSONRequestBody = DeleteAppKeyRequest

// TigrisRotateAppKeySecretJSONRequestBody defines body for TigrisRotateAppKeySecret for application/json ContentType.
type TigrisRotateAppKeySecretJSONRequestBody = RotateAppKeyRequest

// TigrisUpdateAppKeyJSONRequestBody defines body for TigrisUpdateAppKey for application/json ContentType.
type TigrisUpdateAppKeyJSONRequestBody = UpdateAppKeyRequest

// CacheCreateCacheJSONRequestBody defines body for CacheCreateCache for application/json ContentType.
type CacheCreateCacheJSONRequestBody = CreateCacheRequest

// CacheDeleteCacheJSONRequestBody defines body for CacheDeleteCache for application/json ContentType.
type CacheDeleteCacheJSONRequestBody = DeleteCacheRequest

// CacheDelJSONRequestBody defines body for CacheDel for application/json ContentType.
type CacheDelJSONRequestBody = DelRequest

// CacheGetSetJSONRequestBody defines body for CacheGetSet for application/json ContentType.
type CacheGetSetJSONRequestBody = GetSetRequest

// CacheSetJSONRequestBody defines body for CacheSet for application/json ContentType.
type CacheSetJSONRequestBody = SetRequest

// TigrisCreateProjectJSONRequestBody defines body for TigrisCreateProject for application/json ContentType.
type TigrisCreateProjectJSONRequestBody = CreateProjectRequest

// TigrisCreateBranchJSONRequestBody defines body for TigrisCreateBranch for application/json ContentType.
type TigrisCreateBranchJSONRequestBody = CreateBranchRequest

// TigrisDeleteBranchJSONRequestBody defines body for TigrisDeleteBranch for application/json ContentType.
type TigrisDeleteBranchJSONRequestBody = DeleteBranchRequest

// TigrisCreateOrUpdateCollectionJSONRequestBody defines body for TigrisCreateOrUpdateCollection for application/json ContentType.
type TigrisCreateOrUpdateCollectionJSONRequestBody = CreateOrUpdateCollectionRequest

// TigrisDescribeCollectionJSONRequestBody defines body for TigrisDescribeCollection for application/json ContentType.
type TigrisDescribeCollectionJSONRequestBody = DescribeCollectionRequest

// TigrisDeleteJSONRequestBody defines body for TigrisDelete for application/json ContentType.
type TigrisDeleteJSONRequestBody = DeleteRequest

// TigrisImportJSONRequestBody defines body for TigrisImport for application/json ContentType.
type TigrisImportJSONRequestBody = ImportRequest

// TigrisInsertJSONRequestBody defines body for TigrisInsert for application/json ContentType.
type TigrisInsertJSONRequestBody = InsertRequest

// TigrisReadJSONRequestBody defines body for TigrisRead for application/json ContentType.
type TigrisReadJSONRequestBody = ReadRequest

// TigrisReplaceJSONRequestBody defines body for TigrisReplace for application/json ContentType.
type TigrisReplaceJSONRequestBody = ReplaceRequest

// TigrisSearchJSONRequestBody defines body for TigrisSearch for application/json ContentType.
type TigrisSearchJSONRequestBody = SearchRequest

// TigrisUpdateJSONRequestBody defines body for TigrisUpdate for application/json ContentType.
type TigrisUpdateJSONRequestBody = UpdateRequest

// TigrisDropCollectionJSONRequestBody defines body for TigrisDropCollection for application/json ContentType.
type TigrisDropCollectionJSONRequestBody = DropCollectionRequest

// TigrisDescribeDatabaseJSONRequestBody defines body for TigrisDescribeDatabase for application/json ContentType.
type TigrisDescribeDatabaseJSONRequestBody = DescribeDatabaseRequest

// TigrisBeginTransactionJSONRequestBody defines body for TigrisBeginTransaction for application/json ContentType.
type TigrisBeginTransactionJSONRequestBody = BeginTransactionRequest

// TigrisCommitTransactionJSONRequestBody defines body for TigrisCommitTransaction for application/json ContentType.
type TigrisCommitTransactionJSONRequestBody = CommitTransactionRequest

// TigrisRollbackTransactionJSONRequestBody defines body for TigrisRollbackTransaction for application/json ContentType.
type TigrisRollbackTransactionJSONRequestBody = RollbackTransactionRequest

// TigrisDeleteProjectJSONRequestBody defines body for TigrisDeleteProject for application/json ContentType.
type TigrisDeleteProjectJSONRequestBody = DeleteProjectRequest

// RealtimeMessagesJSONRequestBody defines body for RealtimeMessages for application/json ContentType.
type RealtimeMessagesJSONRequestBody = MessagesRequest

// SearchDeleteJSONRequestBody defines body for SearchDelete for application/json ContentType.
type SearchDeleteJSONRequestBody = DeleteDocumentRequest

// SearchUpdateJSONRequestBody defines body for SearchUpdate for application/json ContentType.
type SearchUpdateJSONRequestBody = UpdateDocumentRequest

// SearchCreateJSONRequestBody defines body for SearchCreate for application/json ContentType.
type SearchCreateJSONRequestBody = CreateDocumentRequest

// SearchCreateOrReplaceJSONRequestBody defines body for SearchCreateOrReplace for application/json ContentType.
type SearchCreateOrReplaceJSONRequestBody = CreateOrReplaceDocumentRequest

// SearchDeleteByQueryJSONRequestBody defines body for SearchDeleteByQuery for application/json ContentType.
type SearchDeleteByQueryJSONRequestBody = DeleteByQueryRequest

// SearchSearchJSONRequestBody defines body for SearchSearch for application/json ContentType.
type SearchSearchJSONRequestBody = SearchIndexRequest

// SearchCreateByIdJSONRequestBody defines body for SearchCreateById for application/json ContentType.
type SearchCreateByIdJSONRequestBody = CreateByIdRequest

// SearchDeleteIndexJSONRequestBody defines body for SearchDeleteIndex for application/json ContentType.
type SearchDeleteIndexJSONRequestBody = DeleteIndexRequest

// SearchCreateOrUpdateIndexJSONRequestBody defines body for SearchCreateOrUpdateIndex for application/json ContentType.
type SearchCreateOrUpdateIndexJSONRequestBody = CreateOrUpdateIndexRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AuthGetAccessToken request with any body
	AuthGetAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthAPIHealth request
	HealthAPIHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementGetNamespaceMetadata request with any body
	ManagementGetNamespaceMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagementGetNamespaceMetadata(ctx context.Context, metadataKey string, body ManagementGetNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementInsertNamespaceMetadata request with any body
	ManagementInsertNamespaceMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagementInsertNamespaceMetadata(ctx context.Context, metadataKey string, body ManagementInsertNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementUpdateNamespaceMetadata request with any body
	ManagementUpdateNamespaceMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagementUpdateNamespaceMetadata(ctx context.Context, metadataKey string, body ManagementUpdateNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementCreateNamespace request with any body
	ManagementCreateNamespaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagementCreateNamespace(ctx context.Context, body ManagementCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementDescribeNamespaces request
	ManagementDescribeNamespaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementListNamespaces request
	ManagementListNamespaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementGetUserMetadata request with any body
	ManagementGetUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagementGetUserMetadata(ctx context.Context, metadataKey string, body ManagementGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementInsertUserMetadata request with any body
	ManagementInsertUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagementInsertUserMetadata(ctx context.Context, metadataKey string, body ManagementInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManagementUpdateUserMetadata request with any body
	ManagementUpdateUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManagementUpdateUserMetadata(ctx context.Context, metadataKey string, body ManagementUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservabilityGetInfo request
	ObservabilityGetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservabilityQueryTimeSeriesMetrics request with any body
	ObservabilityQueryTimeSeriesMetricsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObservabilityQueryTimeSeriesMetrics(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservabilityQuotaLimits request with any body
	ObservabilityQuotaLimitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObservabilityQuotaLimits(ctx context.Context, body ObservabilityQuotaLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ObservabilityQuotaUsage request with any body
	ObservabilityQuotaUsageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ObservabilityQuotaUsage(ctx context.Context, body ObservabilityQuotaUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisListProjects request
	TigrisListProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisListAppKeys request
	TigrisListAppKeys(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCreateAppKey request with any body
	TigrisCreateAppKeyWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCreateAppKey(ctx context.Context, project string, body TigrisCreateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDeleteAppKey request with any body
	TigrisDeleteAppKeyWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDeleteAppKey(ctx context.Context, project string, body TigrisDeleteAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisRotateAppKeySecret request with any body
	TigrisRotateAppKeySecretWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisRotateAppKeySecret(ctx context.Context, project string, body TigrisRotateAppKeySecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisUpdateAppKey request with any body
	TigrisUpdateAppKeyWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisUpdateAppKey(ctx context.Context, project string, body TigrisUpdateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheListCaches request
	CacheListCaches(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheCreateCache request with any body
	CacheCreateCacheWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CacheCreateCache(ctx context.Context, project string, name string, body CacheCreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheDeleteCache request with any body
	CacheDeleteCacheWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CacheDeleteCache(ctx context.Context, project string, name string, body CacheDeleteCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheKeys request
	CacheKeys(ctx context.Context, project string, name string, params *CacheKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheDel request with any body
	CacheDelWithBody(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CacheDel(ctx context.Context, project string, name string, key string, body CacheDelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheGet request
	CacheGet(ctx context.Context, project string, name string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheGetSet request with any body
	CacheGetSetWithBody(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CacheGetSet(ctx context.Context, project string, name string, key string, body CacheGetSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CacheSet request with any body
	CacheSetWithBody(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CacheSet(ctx context.Context, project string, name string, key string, body CacheSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCreateProject request with any body
	TigrisCreateProjectWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCreateProject(ctx context.Context, project string, body TigrisCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisListBranches request
	TigrisListBranches(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCreateBranch request with any body
	TigrisCreateBranchWithBody(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCreateBranch(ctx context.Context, project string, branch string, body TigrisCreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDeleteBranch request with any body
	TigrisDeleteBranchWithBody(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDeleteBranch(ctx context.Context, project string, branch string, body TigrisDeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisListCollections request
	TigrisListCollections(ctx context.Context, project string, params *TigrisListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCreateOrUpdateCollection request with any body
	TigrisCreateOrUpdateCollectionWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCreateOrUpdateCollection(ctx context.Context, project string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDescribeCollection request with any body
	TigrisDescribeCollectionWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDescribeCollection(ctx context.Context, project string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDelete request with any body
	TigrisDeleteWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDelete(ctx context.Context, project string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisImport request with any body
	TigrisImportWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisImport(ctx context.Context, project string, collection string, body TigrisImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisInsert request with any body
	TigrisInsertWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisInsert(ctx context.Context, project string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisRead request with any body
	TigrisReadWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisRead(ctx context.Context, project string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisReplace request with any body
	TigrisReplaceWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisReplace(ctx context.Context, project string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisSearch request with any body
	TigrisSearchWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisSearch(ctx context.Context, project string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisUpdate request with any body
	TigrisUpdateWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisUpdate(ctx context.Context, project string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDropCollection request with any body
	TigrisDropCollectionWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDropCollection(ctx context.Context, project string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDescribeDatabase request with any body
	TigrisDescribeDatabaseWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDescribeDatabase(ctx context.Context, project string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisBeginTransaction request with any body
	TigrisBeginTransactionWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisBeginTransaction(ctx context.Context, project string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisCommitTransaction request with any body
	TigrisCommitTransactionWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisCommitTransaction(ctx context.Context, project string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisRollbackTransaction request with any body
	TigrisRollbackTransactionWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisRollbackTransaction(ctx context.Context, project string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TigrisDeleteProject request with any body
	TigrisDeleteProjectWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TigrisDeleteProject(ctx context.Context, project string, body TigrisDeleteProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RealtimeGetRTChannels request
	RealtimeGetRTChannels(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RealtimeGetRTChannel request
	RealtimeGetRTChannel(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RealtimeReadMessages request
	RealtimeReadMessages(ctx context.Context, project string, channel string, params *RealtimeReadMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RealtimeMessages request with any body
	RealtimeMessagesWithBody(ctx context.Context, project string, channel string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RealtimeMessages(ctx context.Context, project string, channel string, body RealtimeMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RealtimePresence request
	RealtimePresence(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RealtimeListSubscriptions request
	RealtimeListSubscriptions(ctx context.Context, project string, channel string, params *RealtimeListSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchListIndexes request
	SearchListIndexes(ctx context.Context, project string, params *SearchListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDelete request with any body
	SearchDeleteWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDelete(ctx context.Context, project string, index string, body SearchDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGet request
	SearchGet(ctx context.Context, project string, index string, params *SearchGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchUpdate request with any body
	SearchUpdateWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchUpdate(ctx context.Context, project string, index string, body SearchUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCreate request with any body
	SearchCreateWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchCreate(ctx context.Context, project string, index string, body SearchCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCreateOrReplace request with any body
	SearchCreateOrReplaceWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchCreateOrReplace(ctx context.Context, project string, index string, body SearchCreateOrReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDeleteByQuery request with any body
	SearchDeleteByQueryWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDeleteByQuery(ctx context.Context, project string, index string, body SearchDeleteByQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchSearch request with any body
	SearchSearchWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchSearch(ctx context.Context, project string, index string, body SearchSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCreateById request with any body
	SearchCreateByIdWithBody(ctx context.Context, project string, index string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchCreateById(ctx context.Context, project string, index string, id string, body SearchCreateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDeleteIndex request with any body
	SearchDeleteIndexWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDeleteIndex(ctx context.Context, project string, name string, body SearchDeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchGetIndex request
	SearchGetIndex(ctx context.Context, project string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCreateOrUpdateIndex request with any body
	SearchCreateOrUpdateIndexWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchCreateOrUpdateIndex(ctx context.Context, project string, name string, body SearchCreateOrUpdateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AuthGetAccessTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthGetAccessTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthAPIHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthAPIHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementGetNamespaceMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementGetNamespaceMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementGetNamespaceMetadata(ctx context.Context, metadataKey string, body ManagementGetNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementGetNamespaceMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementInsertNamespaceMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementInsertNamespaceMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementInsertNamespaceMetadata(ctx context.Context, metadataKey string, body ManagementInsertNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementInsertNamespaceMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementUpdateNamespaceMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementUpdateNamespaceMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementUpdateNamespaceMetadata(ctx context.Context, metadataKey string, body ManagementUpdateNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementUpdateNamespaceMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementCreateNamespaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementCreateNamespaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementCreateNamespace(ctx context.Context, body ManagementCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementCreateNamespaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementDescribeNamespaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementDescribeNamespacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementListNamespaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementListNamespacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementGetUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementGetUserMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementGetUserMetadata(ctx context.Context, metadataKey string, body ManagementGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementGetUserMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementInsertUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementInsertUserMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementInsertUserMetadata(ctx context.Context, metadataKey string, body ManagementInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementInsertUserMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementUpdateUserMetadataWithBody(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementUpdateUserMetadataRequestWithBody(c.Server, metadataKey, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManagementUpdateUserMetadata(ctx context.Context, metadataKey string, body ManagementUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManagementUpdateUserMetadataRequest(c.Server, metadataKey, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityGetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityGetInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQueryTimeSeriesMetricsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQueryTimeSeriesMetricsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQueryTimeSeriesMetrics(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQueryTimeSeriesMetricsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQuotaLimitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQuotaLimitsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQuotaLimits(ctx context.Context, body ObservabilityQuotaLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQuotaLimitsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQuotaUsageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQuotaUsageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ObservabilityQuotaUsage(ctx context.Context, body ObservabilityQuotaUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewObservabilityQuotaUsageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisListProjects(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisListProjectsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisListAppKeys(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisListAppKeysRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateAppKeyWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateAppKeyRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateAppKey(ctx context.Context, project string, body TigrisCreateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateAppKeyRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteAppKeyWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteAppKeyRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteAppKey(ctx context.Context, project string, body TigrisDeleteAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteAppKeyRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRotateAppKeySecretWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisRotateAppKeySecretRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRotateAppKeySecret(ctx context.Context, project string, body TigrisRotateAppKeySecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisRotateAppKeySecretRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisUpdateAppKeyWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisUpdateAppKeyRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisUpdateAppKey(ctx context.Context, project string, body TigrisUpdateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisUpdateAppKeyRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheListCaches(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheListCachesRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheCreateCacheWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheCreateCacheRequestWithBody(c.Server, project, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheCreateCache(ctx context.Context, project string, name string, body CacheCreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheCreateCacheRequest(c.Server, project, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheDeleteCacheWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheDeleteCacheRequestWithBody(c.Server, project, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheDeleteCache(ctx context.Context, project string, name string, body CacheDeleteCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheDeleteCacheRequest(c.Server, project, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheKeys(ctx context.Context, project string, name string, params *CacheKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheKeysRequest(c.Server, project, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheDelWithBody(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheDelRequestWithBody(c.Server, project, name, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheDel(ctx context.Context, project string, name string, key string, body CacheDelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheDelRequest(c.Server, project, name, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheGet(ctx context.Context, project string, name string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheGetRequest(c.Server, project, name, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheGetSetWithBody(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheGetSetRequestWithBody(c.Server, project, name, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheGetSet(ctx context.Context, project string, name string, key string, body CacheGetSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheGetSetRequest(c.Server, project, name, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheSetWithBody(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheSetRequestWithBody(c.Server, project, name, key, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CacheSet(ctx context.Context, project string, name string, key string, body CacheSetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCacheSetRequest(c.Server, project, name, key, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateProjectWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateProjectRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateProject(ctx context.Context, project string, body TigrisCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateProjectRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisListBranches(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisListBranchesRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateBranchWithBody(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateBranchRequestWithBody(c.Server, project, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateBranch(ctx context.Context, project string, branch string, body TigrisCreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateBranchRequest(c.Server, project, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteBranchWithBody(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteBranchRequestWithBody(c.Server, project, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteBranch(ctx context.Context, project string, branch string, body TigrisDeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteBranchRequest(c.Server, project, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisListCollections(ctx context.Context, project string, params *TigrisListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisListCollectionsRequest(c.Server, project, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateOrUpdateCollectionWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateOrUpdateCollectionRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCreateOrUpdateCollection(ctx context.Context, project string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCreateOrUpdateCollectionRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeCollectionWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeCollectionRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeCollection(ctx context.Context, project string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeCollectionRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDelete(ctx context.Context, project string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisImportWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisImportRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisImport(ctx context.Context, project string, collection string, body TigrisImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisImportRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisInsertWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisInsertRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisInsert(ctx context.Context, project string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisInsertRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisReadWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReadRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRead(ctx context.Context, project string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReadRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisReplaceWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReplaceRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisReplace(ctx context.Context, project string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisReplaceRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisSearchWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisSearchRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisSearch(ctx context.Context, project string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisSearchRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisUpdateWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisUpdateRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisUpdate(ctx context.Context, project string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisUpdateRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDropCollectionWithBody(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDropCollectionRequestWithBody(c.Server, project, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDropCollection(ctx context.Context, project string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDropCollectionRequest(c.Server, project, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeDatabaseWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeDatabaseRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDescribeDatabase(ctx context.Context, project string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDescribeDatabaseRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisBeginTransactionWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisBeginTransactionRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisBeginTransaction(ctx context.Context, project string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisBeginTransactionRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCommitTransactionWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCommitTransactionRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisCommitTransaction(ctx context.Context, project string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisCommitTransactionRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRollbackTransactionWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisRollbackTransactionRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisRollbackTransaction(ctx context.Context, project string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisRollbackTransactionRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteProjectWithBody(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteProjectRequestWithBody(c.Server, project, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TigrisDeleteProject(ctx context.Context, project string, body TigrisDeleteProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTigrisDeleteProjectRequest(c.Server, project, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RealtimeGetRTChannels(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRealtimeGetRTChannelsRequest(c.Server, project)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RealtimeGetRTChannel(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRealtimeGetRTChannelRequest(c.Server, project, channel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RealtimeReadMessages(ctx context.Context, project string, channel string, params *RealtimeReadMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRealtimeReadMessagesRequest(c.Server, project, channel, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RealtimeMessagesWithBody(ctx context.Context, project string, channel string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRealtimeMessagesRequestWithBody(c.Server, project, channel, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RealtimeMessages(ctx context.Context, project string, channel string, body RealtimeMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRealtimeMessagesRequest(c.Server, project, channel, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RealtimePresence(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRealtimePresenceRequest(c.Server, project, channel)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RealtimeListSubscriptions(ctx context.Context, project string, channel string, params *RealtimeListSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRealtimeListSubscriptionsRequest(c.Server, project, channel, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchListIndexes(ctx context.Context, project string, params *SearchListIndexesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchListIndexesRequest(c.Server, project, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeleteWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeleteRequestWithBody(c.Server, project, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDelete(ctx context.Context, project string, index string, body SearchDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeleteRequest(c.Server, project, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGet(ctx context.Context, project string, index string, params *SearchGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGetRequest(c.Server, project, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUpdateWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUpdateRequestWithBody(c.Server, project, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchUpdate(ctx context.Context, project string, index string, body SearchUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchUpdateRequest(c.Server, project, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreateWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateRequestWithBody(c.Server, project, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreate(ctx context.Context, project string, index string, body SearchCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateRequest(c.Server, project, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreateOrReplaceWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateOrReplaceRequestWithBody(c.Server, project, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreateOrReplace(ctx context.Context, project string, index string, body SearchCreateOrReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateOrReplaceRequest(c.Server, project, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeleteByQueryWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeleteByQueryRequestWithBody(c.Server, project, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeleteByQuery(ctx context.Context, project string, index string, body SearchDeleteByQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeleteByQueryRequest(c.Server, project, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchSearchWithBody(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchSearchRequestWithBody(c.Server, project, index, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchSearch(ctx context.Context, project string, index string, body SearchSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchSearchRequest(c.Server, project, index, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreateByIdWithBody(ctx context.Context, project string, index string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateByIdRequestWithBody(c.Server, project, index, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreateById(ctx context.Context, project string, index string, id string, body SearchCreateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateByIdRequest(c.Server, project, index, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeleteIndexWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeleteIndexRequestWithBody(c.Server, project, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDeleteIndex(ctx context.Context, project string, name string, body SearchDeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDeleteIndexRequest(c.Server, project, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchGetIndex(ctx context.Context, project string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchGetIndexRequest(c.Server, project, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreateOrUpdateIndexWithBody(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateOrUpdateIndexRequestWithBody(c.Server, project, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCreateOrUpdateIndex(ctx context.Context, project string, name string, body SearchCreateOrUpdateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCreateOrUpdateIndexRequest(c.Server, project, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAuthGetAccessTokenRequestWithBody generates requests for AuthGetAccessToken with any type of body
func NewAuthGetAccessTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/auth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewHealthAPIHealthRequest generates requests for HealthAPIHealth
func NewHealthAPIHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManagementGetNamespaceMetadataRequest calls the generic ManagementGetNamespaceMetadata builder with application/json body
func NewManagementGetNamespaceMetadataRequest(server string, metadataKey string, body ManagementGetNamespaceMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagementGetNamespaceMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewManagementGetNamespaceMetadataRequestWithBody generates requests for ManagementGetNamespaceMetadata with any type of body
func NewManagementGetNamespaceMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/namespace/metadata/%s/get", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagementInsertNamespaceMetadataRequest calls the generic ManagementInsertNamespaceMetadata builder with application/json body
func NewManagementInsertNamespaceMetadataRequest(server string, metadataKey string, body ManagementInsertNamespaceMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagementInsertNamespaceMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewManagementInsertNamespaceMetadataRequestWithBody generates requests for ManagementInsertNamespaceMetadata with any type of body
func NewManagementInsertNamespaceMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/namespace/metadata/%s/insert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagementUpdateNamespaceMetadataRequest calls the generic ManagementUpdateNamespaceMetadata builder with application/json body
func NewManagementUpdateNamespaceMetadataRequest(server string, metadataKey string, body ManagementUpdateNamespaceMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagementUpdateNamespaceMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewManagementUpdateNamespaceMetadataRequestWithBody generates requests for ManagementUpdateNamespaceMetadata with any type of body
func NewManagementUpdateNamespaceMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/namespace/metadata/%s/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagementCreateNamespaceRequest calls the generic ManagementCreateNamespace builder with application/json body
func NewManagementCreateNamespaceRequest(server string, body ManagementCreateNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagementCreateNamespaceRequestWithBody(server, "application/json", bodyReader)
}

// NewManagementCreateNamespaceRequestWithBody generates requests for ManagementCreateNamespace with any type of body
func NewManagementCreateNamespaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/namespaces/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagementDescribeNamespacesRequest generates requests for ManagementDescribeNamespaces
func NewManagementDescribeNamespacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/namespaces/describe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManagementListNamespacesRequest generates requests for ManagementListNamespaces
func NewManagementListNamespacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/namespaces/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManagementGetUserMetadataRequest calls the generic ManagementGetUserMetadata builder with application/json body
func NewManagementGetUserMetadataRequest(server string, metadataKey string, body ManagementGetUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagementGetUserMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewManagementGetUserMetadataRequestWithBody generates requests for ManagementGetUserMetadata with any type of body
func NewManagementGetUserMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/users/metadata/%s/get", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagementInsertUserMetadataRequest calls the generic ManagementInsertUserMetadata builder with application/json body
func NewManagementInsertUserMetadataRequest(server string, metadataKey string, body ManagementInsertUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagementInsertUserMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewManagementInsertUserMetadataRequestWithBody generates requests for ManagementInsertUserMetadata with any type of body
func NewManagementInsertUserMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/users/metadata/%s/insert", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewManagementUpdateUserMetadataRequest calls the generic ManagementUpdateUserMetadata builder with application/json body
func NewManagementUpdateUserMetadataRequest(server string, metadataKey string, body ManagementUpdateUserMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManagementUpdateUserMetadataRequestWithBody(server, metadataKey, "application/json", bodyReader)
}

// NewManagementUpdateUserMetadataRequestWithBody generates requests for ManagementUpdateUserMetadata with any type of body
func NewManagementUpdateUserMetadataRequestWithBody(server string, metadataKey string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "metadataKey", runtime.ParamLocationPath, metadataKey)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/management/users/metadata/%s/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewObservabilityGetInfoRequest generates requests for ObservabilityGetInfo
func NewObservabilityGetInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/observability/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewObservabilityQueryTimeSeriesMetricsRequest calls the generic ObservabilityQueryTimeSeriesMetrics builder with application/json body
func NewObservabilityQueryTimeSeriesMetricsRequest(server string, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewObservabilityQueryTimeSeriesMetricsRequestWithBody(server, "application/json", bodyReader)
}

// NewObservabilityQueryTimeSeriesMetricsRequestWithBody generates requests for ObservabilityQueryTimeSeriesMetrics with any type of body
func NewObservabilityQueryTimeSeriesMetricsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/observability/metrics/timeseries/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewObservabilityQuotaLimitsRequest calls the generic ObservabilityQuotaLimits builder with application/json body
func NewObservabilityQuotaLimitsRequest(server string, body ObservabilityQuotaLimitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewObservabilityQuotaLimitsRequestWithBody(server, "application/json", bodyReader)
}

// NewObservabilityQuotaLimitsRequestWithBody generates requests for ObservabilityQuotaLimits with any type of body
func NewObservabilityQuotaLimitsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/observability/quota/limits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewObservabilityQuotaUsageRequest calls the generic ObservabilityQuotaUsage builder with application/json body
func NewObservabilityQuotaUsageRequest(server string, body ObservabilityQuotaUsageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewObservabilityQuotaUsageRequestWithBody(server, "application/json", bodyReader)
}

// NewObservabilityQuotaUsageRequestWithBody generates requests for ObservabilityQuotaUsage with any type of body
func NewObservabilityQuotaUsageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/observability/quota/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisListProjectsRequest generates requests for TigrisListProjects
func NewTigrisListProjectsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTigrisListAppKeysRequest generates requests for TigrisListAppKeys
func NewTigrisListAppKeysRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/apps/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTigrisCreateAppKeyRequest calls the generic TigrisCreateAppKey builder with application/json body
func NewTigrisCreateAppKeyRequest(server string, project string, body TigrisCreateAppKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCreateAppKeyRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisCreateAppKeyRequestWithBody generates requests for TigrisCreateAppKey with any type of body
func NewTigrisCreateAppKeyRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/apps/keys/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDeleteAppKeyRequest calls the generic TigrisDeleteAppKey builder with application/json body
func NewTigrisDeleteAppKeyRequest(server string, project string, body TigrisDeleteAppKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDeleteAppKeyRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisDeleteAppKeyRequestWithBody generates requests for TigrisDeleteAppKey with any type of body
func NewTigrisDeleteAppKeyRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/apps/keys/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisRotateAppKeySecretRequest calls the generic TigrisRotateAppKeySecret builder with application/json body
func NewTigrisRotateAppKeySecretRequest(server string, project string, body TigrisRotateAppKeySecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisRotateAppKeySecretRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisRotateAppKeySecretRequestWithBody generates requests for TigrisRotateAppKeySecret with any type of body
func NewTigrisRotateAppKeySecretRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/apps/keys/rotate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisUpdateAppKeyRequest calls the generic TigrisUpdateAppKey builder with application/json body
func NewTigrisUpdateAppKeyRequest(server string, project string, body TigrisUpdateAppKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisUpdateAppKeyRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisUpdateAppKeyRequestWithBody generates requests for TigrisUpdateAppKey with any type of body
func NewTigrisUpdateAppKeyRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/apps/keys/update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCacheListCachesRequest generates requests for CacheListCaches
func NewCacheListCachesRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCacheCreateCacheRequest calls the generic CacheCreateCache builder with application/json body
func NewCacheCreateCacheRequest(server string, project string, name string, body CacheCreateCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCacheCreateCacheRequestWithBody(server, project, name, "application/json", bodyReader)
}

// NewCacheCreateCacheRequestWithBody generates requests for CacheCreateCache with any type of body
func NewCacheCreateCacheRequestWithBody(server string, project string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/%s/create", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCacheDeleteCacheRequest calls the generic CacheDeleteCache builder with application/json body
func NewCacheDeleteCacheRequest(server string, project string, name string, body CacheDeleteCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCacheDeleteCacheRequestWithBody(server, project, name, "application/json", bodyReader)
}

// NewCacheDeleteCacheRequestWithBody generates requests for CacheDeleteCache with any type of body
func NewCacheDeleteCacheRequestWithBody(server string, project string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/%s/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCacheKeysRequest generates requests for CacheKeys
func NewCacheKeysRequest(server string, project string, name string, params *CacheKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pattern != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pattern", runtime.ParamLocationQuery, *params.Pattern); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCacheDelRequest calls the generic CacheDel builder with application/json body
func NewCacheDelRequest(server string, project string, name string, key string, body CacheDelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCacheDelRequestWithBody(server, project, name, key, "application/json", bodyReader)
}

// NewCacheDelRequestWithBody generates requests for CacheDel with any type of body
func NewCacheDelRequestWithBody(server string, project string, name string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/%s/%s/delete", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCacheGetRequest generates requests for CacheGet
func NewCacheGetRequest(server string, project string, name string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/%s/%s/get", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCacheGetSetRequest calls the generic CacheGetSet builder with application/json body
func NewCacheGetSetRequest(server string, project string, name string, key string, body CacheGetSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCacheGetSetRequestWithBody(server, project, name, key, "application/json", bodyReader)
}

// NewCacheGetSetRequestWithBody generates requests for CacheGetSet with any type of body
func NewCacheGetSetRequestWithBody(server string, project string, name string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/%s/%s/getset", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCacheSetRequest calls the generic CacheSet builder with application/json body
func NewCacheSetRequest(server string, project string, name string, key string, body CacheSetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCacheSetRequestWithBody(server, project, name, key, "application/json", bodyReader)
}

// NewCacheSetRequestWithBody generates requests for CacheSet with any type of body
func NewCacheSetRequestWithBody(server string, project string, name string, key string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/caches/%s/%s/set", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisCreateProjectRequest calls the generic TigrisCreateProject builder with application/json body
func NewTigrisCreateProjectRequest(server string, project string, body TigrisCreateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCreateProjectRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisCreateProjectRequestWithBody generates requests for TigrisCreateProject with any type of body
func NewTigrisCreateProjectRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisListBranchesRequest generates requests for TigrisListBranches
func NewTigrisListBranchesRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/branches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTigrisCreateBranchRequest calls the generic TigrisCreateBranch builder with application/json body
func NewTigrisCreateBranchRequest(server string, project string, branch string, body TigrisCreateBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCreateBranchRequestWithBody(server, project, branch, "application/json", bodyReader)
}

// NewTigrisCreateBranchRequestWithBody generates requests for TigrisCreateBranch with any type of body
func NewTigrisCreateBranchRequestWithBody(server string, project string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/branches/%s/create", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDeleteBranchRequest calls the generic TigrisDeleteBranch builder with application/json body
func NewTigrisDeleteBranchRequest(server string, project string, branch string, body TigrisDeleteBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDeleteBranchRequestWithBody(server, project, branch, "application/json", bodyReader)
}

// NewTigrisDeleteBranchRequestWithBody generates requests for TigrisDeleteBranch with any type of body
func NewTigrisDeleteBranchRequestWithBody(server string, project string, branch string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/branches/%s/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisListCollectionsRequest generates requests for TigrisListCollections
func NewTigrisListCollectionsRequest(server string, project string, params *TigrisListCollectionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTigrisCreateOrUpdateCollectionRequest calls the generic TigrisCreateOrUpdateCollection builder with application/json body
func NewTigrisCreateOrUpdateCollectionRequest(server string, project string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCreateOrUpdateCollectionRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisCreateOrUpdateCollectionRequestWithBody generates requests for TigrisCreateOrUpdateCollection with any type of body
func NewTigrisCreateOrUpdateCollectionRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/createOrUpdate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDescribeCollectionRequest calls the generic TigrisDescribeCollection builder with application/json body
func NewTigrisDescribeCollectionRequest(server string, project string, collection string, body TigrisDescribeCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDescribeCollectionRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisDescribeCollectionRequestWithBody generates requests for TigrisDescribeCollection with any type of body
func NewTigrisDescribeCollectionRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/describe", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDeleteRequest calls the generic TigrisDelete builder with application/json body
func NewTigrisDeleteRequest(server string, project string, collection string, body TigrisDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDeleteRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisDeleteRequestWithBody generates requests for TigrisDelete with any type of body
func NewTigrisDeleteRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/documents/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisImportRequest calls the generic TigrisImport builder with application/json body
func NewTigrisImportRequest(server string, project string, collection string, body TigrisImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisImportRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisImportRequestWithBody generates requests for TigrisImport with any type of body
func NewTigrisImportRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/documents/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisInsertRequest calls the generic TigrisInsert builder with application/json body
func NewTigrisInsertRequest(server string, project string, collection string, body TigrisInsertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisInsertRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisInsertRequestWithBody generates requests for TigrisInsert with any type of body
func NewTigrisInsertRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/documents/insert", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisReadRequest calls the generic TigrisRead builder with application/json body
func NewTigrisReadRequest(server string, project string, collection string, body TigrisReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisReadRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisReadRequestWithBody generates requests for TigrisRead with any type of body
func NewTigrisReadRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/documents/read", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisReplaceRequest calls the generic TigrisReplace builder with application/json body
func NewTigrisReplaceRequest(server string, project string, collection string, body TigrisReplaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisReplaceRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisReplaceRequestWithBody generates requests for TigrisReplace with any type of body
func NewTigrisReplaceRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/documents/replace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisSearchRequest calls the generic TigrisSearch builder with application/json body
func NewTigrisSearchRequest(server string, project string, collection string, body TigrisSearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisSearchRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisSearchRequestWithBody generates requests for TigrisSearch with any type of body
func NewTigrisSearchRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/documents/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisUpdateRequest calls the generic TigrisUpdate builder with application/json body
func NewTigrisUpdateRequest(server string, project string, collection string, body TigrisUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisUpdateRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisUpdateRequestWithBody generates requests for TigrisUpdate with any type of body
func NewTigrisUpdateRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/documents/update", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDropCollectionRequest calls the generic TigrisDropCollection builder with application/json body
func NewTigrisDropCollectionRequest(server string, project string, collection string, body TigrisDropCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDropCollectionRequestWithBody(server, project, collection, "application/json", bodyReader)
}

// NewTigrisDropCollectionRequestWithBody generates requests for TigrisDropCollection with any type of body
func NewTigrisDropCollectionRequestWithBody(server string, project string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/collections/%s/drop", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDescribeDatabaseRequest calls the generic TigrisDescribeDatabase builder with application/json body
func NewTigrisDescribeDatabaseRequest(server string, project string, body TigrisDescribeDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDescribeDatabaseRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisDescribeDatabaseRequestWithBody generates requests for TigrisDescribeDatabase with any type of body
func NewTigrisDescribeDatabaseRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/describe", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisBeginTransactionRequest calls the generic TigrisBeginTransaction builder with application/json body
func NewTigrisBeginTransactionRequest(server string, project string, body TigrisBeginTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisBeginTransactionRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisBeginTransactionRequestWithBody generates requests for TigrisBeginTransaction with any type of body
func NewTigrisBeginTransactionRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/transactions/begin", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisCommitTransactionRequest calls the generic TigrisCommitTransaction builder with application/json body
func NewTigrisCommitTransactionRequest(server string, project string, body TigrisCommitTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisCommitTransactionRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisCommitTransactionRequestWithBody generates requests for TigrisCommitTransaction with any type of body
func NewTigrisCommitTransactionRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/transactions/commit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisRollbackTransactionRequest calls the generic TigrisRollbackTransaction builder with application/json body
func NewTigrisRollbackTransactionRequest(server string, project string, body TigrisRollbackTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisRollbackTransactionRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisRollbackTransactionRequestWithBody generates requests for TigrisRollbackTransaction with any type of body
func NewTigrisRollbackTransactionRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/database/transactions/rollback", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTigrisDeleteProjectRequest calls the generic TigrisDeleteProject builder with application/json body
func NewTigrisDeleteProjectRequest(server string, project string, body TigrisDeleteProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTigrisDeleteProjectRequestWithBody(server, project, "application/json", bodyReader)
}

// NewTigrisDeleteProjectRequestWithBody generates requests for TigrisDeleteProject with any type of body
func NewTigrisDeleteProjectRequestWithBody(server string, project string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/delete", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRealtimeGetRTChannelsRequest generates requests for RealtimeGetRTChannels
func NewRealtimeGetRTChannelsRequest(server string, project string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/realtime/channels", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRealtimeGetRTChannelRequest generates requests for RealtimeGetRTChannel
func NewRealtimeGetRTChannelRequest(server string, project string, channel string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel", runtime.ParamLocationPath, channel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/realtime/channels/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRealtimeReadMessagesRequest generates requests for RealtimeReadMessages
func NewRealtimeReadMessagesRequest(server string, project string, channel string, params *RealtimeReadMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel", runtime.ParamLocationPath, channel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/realtime/channels/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SessionId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, *params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SocketId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "socket_id", runtime.ParamLocationQuery, *params.SocketId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Event != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Start != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.End != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRealtimeMessagesRequest calls the generic RealtimeMessages builder with application/json body
func NewRealtimeMessagesRequest(server string, project string, channel string, body RealtimeMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRealtimeMessagesRequestWithBody(server, project, channel, "application/json", bodyReader)
}

// NewRealtimeMessagesRequestWithBody generates requests for RealtimeMessages with any type of body
func NewRealtimeMessagesRequestWithBody(server string, project string, channel string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel", runtime.ParamLocationPath, channel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/realtime/channels/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRealtimePresenceRequest generates requests for RealtimePresence
func NewRealtimePresenceRequest(server string, project string, channel string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel", runtime.ParamLocationPath, channel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/realtime/channels/%s/presence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRealtimeListSubscriptionsRequest generates requests for RealtimeListSubscriptions
func NewRealtimeListSubscriptionsRequest(server string, project string, channel string, params *RealtimeListSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "channel", runtime.ParamLocationPath, channel)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/realtime/channels/%s/subscriptions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PageSize != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchListIndexesRequest generates requests for SearchListIndexes
func NewSearchListIndexesRequest(server string, project string, params *SearchListIndexesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.FilterType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.type", runtime.ParamLocationQuery, *params.FilterType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterCollection != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.collection", runtime.ParamLocationQuery, *params.FilterCollection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.FilterBranch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter.branch", runtime.ParamLocationQuery, *params.FilterBranch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchDeleteRequest calls the generic SearchDelete builder with application/json body
func NewSearchDeleteRequest(server string, project string, index string, body SearchDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDeleteRequestWithBody(server, project, index, "application/json", bodyReader)
}

// NewSearchDeleteRequestWithBody generates requests for SearchDelete with any type of body
func NewSearchDeleteRequestWithBody(server string, project string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchGetRequest generates requests for SearchGet
func NewSearchGetRequest(server string, project string, index string, params *SearchGetParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Ids != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchUpdateRequest calls the generic SearchUpdate builder with application/json body
func NewSearchUpdateRequest(server string, project string, index string, body SearchUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchUpdateRequestWithBody(server, project, index, "application/json", bodyReader)
}

// NewSearchUpdateRequestWithBody generates requests for SearchUpdate with any type of body
func NewSearchUpdateRequestWithBody(server string, project string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchCreateRequest calls the generic SearchCreate builder with application/json body
func NewSearchCreateRequest(server string, project string, index string, body SearchCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchCreateRequestWithBody(server, project, index, "application/json", bodyReader)
}

// NewSearchCreateRequestWithBody generates requests for SearchCreate with any type of body
func NewSearchCreateRequestWithBody(server string, project string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchCreateOrReplaceRequest calls the generic SearchCreateOrReplace builder with application/json body
func NewSearchCreateOrReplaceRequest(server string, project string, index string, body SearchCreateOrReplaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchCreateOrReplaceRequestWithBody(server, project, index, "application/json", bodyReader)
}

// NewSearchCreateOrReplaceRequestWithBody generates requests for SearchCreateOrReplace with any type of body
func NewSearchCreateOrReplaceRequestWithBody(server string, project string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDeleteByQueryRequest calls the generic SearchDeleteByQuery builder with application/json body
func NewSearchDeleteByQueryRequest(server string, project string, index string, body SearchDeleteByQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDeleteByQueryRequestWithBody(server, project, index, "application/json", bodyReader)
}

// NewSearchDeleteByQueryRequestWithBody generates requests for SearchDeleteByQuery with any type of body
func NewSearchDeleteByQueryRequestWithBody(server string, project string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents/deleteByQuery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchSearchRequest calls the generic SearchSearch builder with application/json body
func NewSearchSearchRequest(server string, project string, index string, body SearchSearchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchSearchRequestWithBody(server, project, index, "application/json", bodyReader)
}

// NewSearchSearchRequestWithBody generates requests for SearchSearch with any type of body
func NewSearchSearchRequestWithBody(server string, project string, index string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchCreateByIdRequest calls the generic SearchCreateById builder with application/json body
func NewSearchCreateByIdRequest(server string, project string, index string, id string, body SearchCreateByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchCreateByIdRequestWithBody(server, project, index, id, "application/json", bodyReader)
}

// NewSearchCreateByIdRequestWithBody generates requests for SearchCreateById with any type of body
func NewSearchCreateByIdRequestWithBody(server string, project string, index string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s/documents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDeleteIndexRequest calls the generic SearchDeleteIndex builder with application/json body
func NewSearchDeleteIndexRequest(server string, project string, name string, body SearchDeleteIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDeleteIndexRequestWithBody(server, project, name, "application/json", bodyReader)
}

// NewSearchDeleteIndexRequestWithBody generates requests for SearchDeleteIndex with any type of body
func NewSearchDeleteIndexRequestWithBody(server string, project string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchGetIndexRequest generates requests for SearchGetIndex
func NewSearchGetIndexRequest(server string, project string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchCreateOrUpdateIndexRequest calls the generic SearchCreateOrUpdateIndex builder with application/json body
func NewSearchCreateOrUpdateIndexRequest(server string, project string, name string, body SearchCreateOrUpdateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchCreateOrUpdateIndexRequestWithBody(server, project, name, "application/json", bodyReader)
}

// NewSearchCreateOrUpdateIndexRequestWithBody generates requests for SearchCreateOrUpdateIndex with any type of body
func NewSearchCreateOrUpdateIndexRequestWithBody(server string, project string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project", runtime.ParamLocationPath, project)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/search/indexes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AuthGetAccessToken request with any body
	AuthGetAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGetAccessTokenResponse, error)

	// HealthAPIHealth request
	HealthAPIHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthAPIHealthResponse, error)

	// ManagementGetNamespaceMetadata request with any body
	ManagementGetNamespaceMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementGetNamespaceMetadataResponse, error)

	ManagementGetNamespaceMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementGetNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementGetNamespaceMetadataResponse, error)

	// ManagementInsertNamespaceMetadata request with any body
	ManagementInsertNamespaceMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementInsertNamespaceMetadataResponse, error)

	ManagementInsertNamespaceMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementInsertNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementInsertNamespaceMetadataResponse, error)

	// ManagementUpdateNamespaceMetadata request with any body
	ManagementUpdateNamespaceMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementUpdateNamespaceMetadataResponse, error)

	ManagementUpdateNamespaceMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementUpdateNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementUpdateNamespaceMetadataResponse, error)

	// ManagementCreateNamespace request with any body
	ManagementCreateNamespaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementCreateNamespaceResponse, error)

	ManagementCreateNamespaceWithResponse(ctx context.Context, body ManagementCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementCreateNamespaceResponse, error)

	// ManagementDescribeNamespaces request
	ManagementDescribeNamespacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ManagementDescribeNamespacesResponse, error)

	// ManagementListNamespaces request
	ManagementListNamespacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ManagementListNamespacesResponse, error)

	// ManagementGetUserMetadata request with any body
	ManagementGetUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementGetUserMetadataResponse, error)

	ManagementGetUserMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementGetUserMetadataResponse, error)

	// ManagementInsertUserMetadata request with any body
	ManagementInsertUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementInsertUserMetadataResponse, error)

	ManagementInsertUserMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementInsertUserMetadataResponse, error)

	// ManagementUpdateUserMetadata request with any body
	ManagementUpdateUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementUpdateUserMetadataResponse, error)

	ManagementUpdateUserMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementUpdateUserMetadataResponse, error)

	// ObservabilityGetInfo request
	ObservabilityGetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ObservabilityGetInfoResponse, error)

	// ObservabilityQueryTimeSeriesMetrics request with any body
	ObservabilityQueryTimeSeriesMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error)

	ObservabilityQueryTimeSeriesMetricsWithResponse(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error)

	// ObservabilityQuotaLimits request with any body
	ObservabilityQuotaLimitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQuotaLimitsResponse, error)

	ObservabilityQuotaLimitsWithResponse(ctx context.Context, body ObservabilityQuotaLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQuotaLimitsResponse, error)

	// ObservabilityQuotaUsage request with any body
	ObservabilityQuotaUsageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQuotaUsageResponse, error)

	ObservabilityQuotaUsageWithResponse(ctx context.Context, body ObservabilityQuotaUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQuotaUsageResponse, error)

	// TigrisListProjects request
	TigrisListProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TigrisListProjectsResponse, error)

	// TigrisListAppKeys request
	TigrisListAppKeysWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*TigrisListAppKeysResponse, error)

	// TigrisCreateAppKey request with any body
	TigrisCreateAppKeyWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateAppKeyResponse, error)

	TigrisCreateAppKeyWithResponse(ctx context.Context, project string, body TigrisCreateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateAppKeyResponse, error)

	// TigrisDeleteAppKey request with any body
	TigrisDeleteAppKeyWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteAppKeyResponse, error)

	TigrisDeleteAppKeyWithResponse(ctx context.Context, project string, body TigrisDeleteAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteAppKeyResponse, error)

	// TigrisRotateAppKeySecret request with any body
	TigrisRotateAppKeySecretWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisRotateAppKeySecretResponse, error)

	TigrisRotateAppKeySecretWithResponse(ctx context.Context, project string, body TigrisRotateAppKeySecretJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisRotateAppKeySecretResponse, error)

	// TigrisUpdateAppKey request with any body
	TigrisUpdateAppKeyWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisUpdateAppKeyResponse, error)

	TigrisUpdateAppKeyWithResponse(ctx context.Context, project string, body TigrisUpdateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisUpdateAppKeyResponse, error)

	// CacheListCaches request
	CacheListCachesWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*CacheListCachesResponse, error)

	// CacheCreateCache request with any body
	CacheCreateCacheWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheCreateCacheResponse, error)

	CacheCreateCacheWithResponse(ctx context.Context, project string, name string, body CacheCreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheCreateCacheResponse, error)

	// CacheDeleteCache request with any body
	CacheDeleteCacheWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheDeleteCacheResponse, error)

	CacheDeleteCacheWithResponse(ctx context.Context, project string, name string, body CacheDeleteCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheDeleteCacheResponse, error)

	// CacheKeys request
	CacheKeysWithResponse(ctx context.Context, project string, name string, params *CacheKeysParams, reqEditors ...RequestEditorFn) (*CacheKeysResponse, error)

	// CacheDel request with any body
	CacheDelWithBodyWithResponse(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheDelResponse, error)

	CacheDelWithResponse(ctx context.Context, project string, name string, key string, body CacheDelJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheDelResponse, error)

	// CacheGet request
	CacheGetWithResponse(ctx context.Context, project string, name string, key string, reqEditors ...RequestEditorFn) (*CacheGetResponse, error)

	// CacheGetSet request with any body
	CacheGetSetWithBodyWithResponse(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheGetSetResponse, error)

	CacheGetSetWithResponse(ctx context.Context, project string, name string, key string, body CacheGetSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheGetSetResponse, error)

	// CacheSet request with any body
	CacheSetWithBodyWithResponse(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheSetResponse, error)

	CacheSetWithResponse(ctx context.Context, project string, name string, key string, body CacheSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheSetResponse, error)

	// TigrisCreateProject request with any body
	TigrisCreateProjectWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateProjectResponse, error)

	TigrisCreateProjectWithResponse(ctx context.Context, project string, body TigrisCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateProjectResponse, error)

	// TigrisListBranches request
	TigrisListBranchesWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*TigrisListBranchesResponse, error)

	// TigrisCreateBranch request with any body
	TigrisCreateBranchWithBodyWithResponse(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateBranchResponse, error)

	TigrisCreateBranchWithResponse(ctx context.Context, project string, branch string, body TigrisCreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateBranchResponse, error)

	// TigrisDeleteBranch request with any body
	TigrisDeleteBranchWithBodyWithResponse(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteBranchResponse, error)

	TigrisDeleteBranchWithResponse(ctx context.Context, project string, branch string, body TigrisDeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteBranchResponse, error)

	// TigrisListCollections request
	TigrisListCollectionsWithResponse(ctx context.Context, project string, params *TigrisListCollectionsParams, reqEditors ...RequestEditorFn) (*TigrisListCollectionsResponse, error)

	// TigrisCreateOrUpdateCollection request with any body
	TigrisCreateOrUpdateCollectionWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error)

	TigrisCreateOrUpdateCollectionWithResponse(ctx context.Context, project string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error)

	// TigrisDescribeCollection request with any body
	TigrisDescribeCollectionWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error)

	TigrisDescribeCollectionWithResponse(ctx context.Context, project string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error)

	// TigrisDelete request with any body
	TigrisDeleteWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error)

	TigrisDeleteWithResponse(ctx context.Context, project string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error)

	// TigrisImport request with any body
	TigrisImportWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisImportResponse, error)

	TigrisImportWithResponse(ctx context.Context, project string, collection string, body TigrisImportJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisImportResponse, error)

	// TigrisInsert request with any body
	TigrisInsertWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error)

	TigrisInsertWithResponse(ctx context.Context, project string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error)

	// TigrisRead request with any body
	TigrisReadWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error)

	TigrisReadWithResponse(ctx context.Context, project string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error)

	// TigrisReplace request with any body
	TigrisReplaceWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error)

	TigrisReplaceWithResponse(ctx context.Context, project string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error)

	// TigrisSearch request with any body
	TigrisSearchWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error)

	TigrisSearchWithResponse(ctx context.Context, project string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error)

	// TigrisUpdate request with any body
	TigrisUpdateWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error)

	TigrisUpdateWithResponse(ctx context.Context, project string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error)

	// TigrisDropCollection request with any body
	TigrisDropCollectionWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error)

	TigrisDropCollectionWithResponse(ctx context.Context, project string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error)

	// TigrisDescribeDatabase request with any body
	TigrisDescribeDatabaseWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error)

	TigrisDescribeDatabaseWithResponse(ctx context.Context, project string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error)

	// TigrisBeginTransaction request with any body
	TigrisBeginTransactionWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error)

	TigrisBeginTransactionWithResponse(ctx context.Context, project string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error)

	// TigrisCommitTransaction request with any body
	TigrisCommitTransactionWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error)

	TigrisCommitTransactionWithResponse(ctx context.Context, project string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error)

	// TigrisRollbackTransaction request with any body
	TigrisRollbackTransactionWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error)

	TigrisRollbackTransactionWithResponse(ctx context.Context, project string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error)

	// TigrisDeleteProject request with any body
	TigrisDeleteProjectWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteProjectResponse, error)

	TigrisDeleteProjectWithResponse(ctx context.Context, project string, body TigrisDeleteProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteProjectResponse, error)

	// RealtimeGetRTChannels request
	RealtimeGetRTChannelsWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*RealtimeGetRTChannelsResponse, error)

	// RealtimeGetRTChannel request
	RealtimeGetRTChannelWithResponse(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*RealtimeGetRTChannelResponse, error)

	// RealtimeReadMessages request
	RealtimeReadMessagesWithResponse(ctx context.Context, project string, channel string, params *RealtimeReadMessagesParams, reqEditors ...RequestEditorFn) (*RealtimeReadMessagesResponse, error)

	// RealtimeMessages request with any body
	RealtimeMessagesWithBodyWithResponse(ctx context.Context, project string, channel string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RealtimeMessagesResponse, error)

	RealtimeMessagesWithResponse(ctx context.Context, project string, channel string, body RealtimeMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*RealtimeMessagesResponse, error)

	// RealtimePresence request
	RealtimePresenceWithResponse(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*RealtimePresenceResponse, error)

	// RealtimeListSubscriptions request
	RealtimeListSubscriptionsWithResponse(ctx context.Context, project string, channel string, params *RealtimeListSubscriptionsParams, reqEditors ...RequestEditorFn) (*RealtimeListSubscriptionsResponse, error)

	// SearchListIndexes request
	SearchListIndexesWithResponse(ctx context.Context, project string, params *SearchListIndexesParams, reqEditors ...RequestEditorFn) (*SearchListIndexesResponse, error)

	// SearchDelete request with any body
	SearchDeleteWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeleteResponse, error)

	SearchDeleteWithResponse(ctx context.Context, project string, index string, body SearchDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDeleteResponse, error)

	// SearchGet request
	SearchGetWithResponse(ctx context.Context, project string, index string, params *SearchGetParams, reqEditors ...RequestEditorFn) (*SearchGetResponse, error)

	// SearchUpdate request with any body
	SearchUpdateWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUpdateResponse, error)

	SearchUpdateWithResponse(ctx context.Context, project string, index string, body SearchUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUpdateResponse, error)

	// SearchCreate request with any body
	SearchCreateWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateResponse, error)

	SearchCreateWithResponse(ctx context.Context, project string, index string, body SearchCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateResponse, error)

	// SearchCreateOrReplace request with any body
	SearchCreateOrReplaceWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateOrReplaceResponse, error)

	SearchCreateOrReplaceWithResponse(ctx context.Context, project string, index string, body SearchCreateOrReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateOrReplaceResponse, error)

	// SearchDeleteByQuery request with any body
	SearchDeleteByQueryWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeleteByQueryResponse, error)

	SearchDeleteByQueryWithResponse(ctx context.Context, project string, index string, body SearchDeleteByQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDeleteByQueryResponse, error)

	// SearchSearch request with any body
	SearchSearchWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchSearchResponse, error)

	SearchSearchWithResponse(ctx context.Context, project string, index string, body SearchSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchSearchResponse, error)

	// SearchCreateById request with any body
	SearchCreateByIdWithBodyWithResponse(ctx context.Context, project string, index string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateByIdResponse, error)

	SearchCreateByIdWithResponse(ctx context.Context, project string, index string, id string, body SearchCreateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateByIdResponse, error)

	// SearchDeleteIndex request with any body
	SearchDeleteIndexWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeleteIndexResponse, error)

	SearchDeleteIndexWithResponse(ctx context.Context, project string, name string, body SearchDeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDeleteIndexResponse, error)

	// SearchGetIndex request
	SearchGetIndexWithResponse(ctx context.Context, project string, name string, reqEditors ...RequestEditorFn) (*SearchGetIndexResponse, error)

	// SearchCreateOrUpdateIndex request with any body
	SearchCreateOrUpdateIndexWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateOrUpdateIndexResponse, error)

	SearchCreateOrUpdateIndexWithResponse(ctx context.Context, project string, name string, body SearchCreateOrUpdateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateOrUpdateIndexResponse, error)
}

type AuthGetAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccessTokenResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r AuthGetAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthGetAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthAPIHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HealthCheckResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r HealthAPIHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthAPIHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementGetNamespaceMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNamespaceMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementGetNamespaceMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementGetNamespaceMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementInsertNamespaceMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsertNamespaceMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementInsertNamespaceMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementInsertNamespaceMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementUpdateNamespaceMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateNamespaceMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementUpdateNamespaceMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementUpdateNamespaceMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementCreateNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateNamespaceResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementCreateNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementCreateNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementDescribeNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeNamespacesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementDescribeNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementDescribeNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementListNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListNamespacesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementListNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementListNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementGetUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementGetUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementGetUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementInsertUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsertUserMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementInsertUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementInsertUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManagementUpdateUserMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserMetadataResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ManagementUpdateUserMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManagementUpdateUserMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservabilityGetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInfoResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ObservabilityGetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservabilityGetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservabilityQueryTimeSeriesMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryTimeSeriesMetricsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ObservabilityQueryTimeSeriesMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservabilityQueryTimeSeriesMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservabilityQuotaLimitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuotaLimitsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ObservabilityQuotaLimitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservabilityQuotaLimitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ObservabilityQuotaUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QuotaUsageResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r ObservabilityQuotaUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ObservabilityQuotaUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListProjectsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisListAppKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAppKeysResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisListAppKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisListAppKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCreateAppKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateAppKeyResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCreateAppKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCreateAppKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDeleteAppKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteAppKeyResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDeleteAppKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDeleteAppKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisRotateAppKeySecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RotateAppKeyResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisRotateAppKeySecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisRotateAppKeySecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisUpdateAppKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateAppKeyResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisUpdateAppKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisUpdateAppKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheListCachesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCachesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheListCachesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheListCachesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheCreateCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateCacheResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheCreateCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheCreateCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheDeleteCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteCacheResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheDeleteCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheDeleteCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeysResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheDelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DelResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheDelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheDelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheGetSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSetResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheGetSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheGetSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CacheSetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SetResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r CacheSetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CacheSetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCreateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateProjectResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCreateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCreateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisListBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBranchesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisListBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisListBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCreateBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateBranchResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCreateBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCreateBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDeleteBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteBranchResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDeleteBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDeleteBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisListCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCollectionsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisListCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisListCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCreateOrUpdateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateOrUpdateCollectionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCreateOrUpdateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCreateOrUpdateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDescribeCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeCollectionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDescribeCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDescribeCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ImportResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisInsertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InsertResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisInsertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisInsertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamingReadResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisReplaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReplaceResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisReplaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisReplaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StreamingSearchResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDropCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DropCollectionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDropCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDropCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDescribeDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DescribeDatabaseResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDescribeDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDescribeDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisBeginTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BeginTransactionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisBeginTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisBeginTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisCommitTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitTransactionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisCommitTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisCommitTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisRollbackTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RollbackTransactionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisRollbackTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisRollbackTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TigrisDeleteProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteProjectResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r TigrisDeleteProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TigrisDeleteProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RealtimeGetRTChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRTChannelsResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r RealtimeGetRTChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RealtimeGetRTChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RealtimeGetRTChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRTChannelResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r RealtimeGetRTChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RealtimeGetRTChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RealtimeReadMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReadMessagesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r RealtimeReadMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RealtimeReadMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RealtimeMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MessagesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r RealtimeMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RealtimeMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RealtimePresenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PresenceResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r RealtimePresenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RealtimePresenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RealtimeListSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSubscriptionResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r RealtimeListSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RealtimeListSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchListIndexesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIndexesResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchListIndexesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchListIndexesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteDocumentResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDocumentResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateDocumentResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateDocumentResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCreateOrReplaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateOrReplaceDocumentResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchCreateOrReplaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCreateOrReplaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDeleteByQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteByQueryResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchDeleteByQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDeleteByQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchIndexResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCreateByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateByIdResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchCreateByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCreateByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteIndexResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchDeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchGetIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetIndexResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchGetIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchGetIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCreateOrUpdateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateOrUpdateIndexResponse
	JSONDefault  *Status
}

// Status returns HTTPResponse.Status
func (r SearchCreateOrUpdateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCreateOrUpdateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AuthGetAccessTokenWithBodyWithResponse request with arbitrary body returning *AuthGetAccessTokenResponse
func (c *ClientWithResponses) AuthGetAccessTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuthGetAccessTokenResponse, error) {
	rsp, err := c.AuthGetAccessTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthGetAccessTokenResponse(rsp)
}

// HealthAPIHealthWithResponse request returning *HealthAPIHealthResponse
func (c *ClientWithResponses) HealthAPIHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthAPIHealthResponse, error) {
	rsp, err := c.HealthAPIHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthAPIHealthResponse(rsp)
}

// ManagementGetNamespaceMetadataWithBodyWithResponse request with arbitrary body returning *ManagementGetNamespaceMetadataResponse
func (c *ClientWithResponses) ManagementGetNamespaceMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementGetNamespaceMetadataResponse, error) {
	rsp, err := c.ManagementGetNamespaceMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementGetNamespaceMetadataResponse(rsp)
}

func (c *ClientWithResponses) ManagementGetNamespaceMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementGetNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementGetNamespaceMetadataResponse, error) {
	rsp, err := c.ManagementGetNamespaceMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementGetNamespaceMetadataResponse(rsp)
}

// ManagementInsertNamespaceMetadataWithBodyWithResponse request with arbitrary body returning *ManagementInsertNamespaceMetadataResponse
func (c *ClientWithResponses) ManagementInsertNamespaceMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementInsertNamespaceMetadataResponse, error) {
	rsp, err := c.ManagementInsertNamespaceMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementInsertNamespaceMetadataResponse(rsp)
}

func (c *ClientWithResponses) ManagementInsertNamespaceMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementInsertNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementInsertNamespaceMetadataResponse, error) {
	rsp, err := c.ManagementInsertNamespaceMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementInsertNamespaceMetadataResponse(rsp)
}

// ManagementUpdateNamespaceMetadataWithBodyWithResponse request with arbitrary body returning *ManagementUpdateNamespaceMetadataResponse
func (c *ClientWithResponses) ManagementUpdateNamespaceMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementUpdateNamespaceMetadataResponse, error) {
	rsp, err := c.ManagementUpdateNamespaceMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementUpdateNamespaceMetadataResponse(rsp)
}

func (c *ClientWithResponses) ManagementUpdateNamespaceMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementUpdateNamespaceMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementUpdateNamespaceMetadataResponse, error) {
	rsp, err := c.ManagementUpdateNamespaceMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementUpdateNamespaceMetadataResponse(rsp)
}

// ManagementCreateNamespaceWithBodyWithResponse request with arbitrary body returning *ManagementCreateNamespaceResponse
func (c *ClientWithResponses) ManagementCreateNamespaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementCreateNamespaceResponse, error) {
	rsp, err := c.ManagementCreateNamespaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementCreateNamespaceResponse(rsp)
}

func (c *ClientWithResponses) ManagementCreateNamespaceWithResponse(ctx context.Context, body ManagementCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementCreateNamespaceResponse, error) {
	rsp, err := c.ManagementCreateNamespace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementCreateNamespaceResponse(rsp)
}

// ManagementDescribeNamespacesWithResponse request returning *ManagementDescribeNamespacesResponse
func (c *ClientWithResponses) ManagementDescribeNamespacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ManagementDescribeNamespacesResponse, error) {
	rsp, err := c.ManagementDescribeNamespaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementDescribeNamespacesResponse(rsp)
}

// ManagementListNamespacesWithResponse request returning *ManagementListNamespacesResponse
func (c *ClientWithResponses) ManagementListNamespacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ManagementListNamespacesResponse, error) {
	rsp, err := c.ManagementListNamespaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementListNamespacesResponse(rsp)
}

// ManagementGetUserMetadataWithBodyWithResponse request with arbitrary body returning *ManagementGetUserMetadataResponse
func (c *ClientWithResponses) ManagementGetUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementGetUserMetadataResponse, error) {
	rsp, err := c.ManagementGetUserMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementGetUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) ManagementGetUserMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementGetUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementGetUserMetadataResponse, error) {
	rsp, err := c.ManagementGetUserMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementGetUserMetadataResponse(rsp)
}

// ManagementInsertUserMetadataWithBodyWithResponse request with arbitrary body returning *ManagementInsertUserMetadataResponse
func (c *ClientWithResponses) ManagementInsertUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementInsertUserMetadataResponse, error) {
	rsp, err := c.ManagementInsertUserMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementInsertUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) ManagementInsertUserMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementInsertUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementInsertUserMetadataResponse, error) {
	rsp, err := c.ManagementInsertUserMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementInsertUserMetadataResponse(rsp)
}

// ManagementUpdateUserMetadataWithBodyWithResponse request with arbitrary body returning *ManagementUpdateUserMetadataResponse
func (c *ClientWithResponses) ManagementUpdateUserMetadataWithBodyWithResponse(ctx context.Context, metadataKey string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManagementUpdateUserMetadataResponse, error) {
	rsp, err := c.ManagementUpdateUserMetadataWithBody(ctx, metadataKey, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementUpdateUserMetadataResponse(rsp)
}

func (c *ClientWithResponses) ManagementUpdateUserMetadataWithResponse(ctx context.Context, metadataKey string, body ManagementUpdateUserMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*ManagementUpdateUserMetadataResponse, error) {
	rsp, err := c.ManagementUpdateUserMetadata(ctx, metadataKey, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseManagementUpdateUserMetadataResponse(rsp)
}

// ObservabilityGetInfoWithResponse request returning *ObservabilityGetInfoResponse
func (c *ClientWithResponses) ObservabilityGetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ObservabilityGetInfoResponse, error) {
	rsp, err := c.ObservabilityGetInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityGetInfoResponse(rsp)
}

// ObservabilityQueryTimeSeriesMetricsWithBodyWithResponse request with arbitrary body returning *ObservabilityQueryTimeSeriesMetricsResponse
func (c *ClientWithResponses) ObservabilityQueryTimeSeriesMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error) {
	rsp, err := c.ObservabilityQueryTimeSeriesMetricsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQueryTimeSeriesMetricsResponse(rsp)
}

func (c *ClientWithResponses) ObservabilityQueryTimeSeriesMetricsWithResponse(ctx context.Context, body ObservabilityQueryTimeSeriesMetricsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQueryTimeSeriesMetricsResponse, error) {
	rsp, err := c.ObservabilityQueryTimeSeriesMetrics(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQueryTimeSeriesMetricsResponse(rsp)
}

// ObservabilityQuotaLimitsWithBodyWithResponse request with arbitrary body returning *ObservabilityQuotaLimitsResponse
func (c *ClientWithResponses) ObservabilityQuotaLimitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQuotaLimitsResponse, error) {
	rsp, err := c.ObservabilityQuotaLimitsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQuotaLimitsResponse(rsp)
}

func (c *ClientWithResponses) ObservabilityQuotaLimitsWithResponse(ctx context.Context, body ObservabilityQuotaLimitsJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQuotaLimitsResponse, error) {
	rsp, err := c.ObservabilityQuotaLimits(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQuotaLimitsResponse(rsp)
}

// ObservabilityQuotaUsageWithBodyWithResponse request with arbitrary body returning *ObservabilityQuotaUsageResponse
func (c *ClientWithResponses) ObservabilityQuotaUsageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ObservabilityQuotaUsageResponse, error) {
	rsp, err := c.ObservabilityQuotaUsageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQuotaUsageResponse(rsp)
}

func (c *ClientWithResponses) ObservabilityQuotaUsageWithResponse(ctx context.Context, body ObservabilityQuotaUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*ObservabilityQuotaUsageResponse, error) {
	rsp, err := c.ObservabilityQuotaUsage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseObservabilityQuotaUsageResponse(rsp)
}

// TigrisListProjectsWithResponse request returning *TigrisListProjectsResponse
func (c *ClientWithResponses) TigrisListProjectsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TigrisListProjectsResponse, error) {
	rsp, err := c.TigrisListProjects(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisListProjectsResponse(rsp)
}

// TigrisListAppKeysWithResponse request returning *TigrisListAppKeysResponse
func (c *ClientWithResponses) TigrisListAppKeysWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*TigrisListAppKeysResponse, error) {
	rsp, err := c.TigrisListAppKeys(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisListAppKeysResponse(rsp)
}

// TigrisCreateAppKeyWithBodyWithResponse request with arbitrary body returning *TigrisCreateAppKeyResponse
func (c *ClientWithResponses) TigrisCreateAppKeyWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateAppKeyResponse, error) {
	rsp, err := c.TigrisCreateAppKeyWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateAppKeyResponse(rsp)
}

func (c *ClientWithResponses) TigrisCreateAppKeyWithResponse(ctx context.Context, project string, body TigrisCreateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateAppKeyResponse, error) {
	rsp, err := c.TigrisCreateAppKey(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateAppKeyResponse(rsp)
}

// TigrisDeleteAppKeyWithBodyWithResponse request with arbitrary body returning *TigrisDeleteAppKeyResponse
func (c *ClientWithResponses) TigrisDeleteAppKeyWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteAppKeyResponse, error) {
	rsp, err := c.TigrisDeleteAppKeyWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteAppKeyResponse(rsp)
}

func (c *ClientWithResponses) TigrisDeleteAppKeyWithResponse(ctx context.Context, project string, body TigrisDeleteAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteAppKeyResponse, error) {
	rsp, err := c.TigrisDeleteAppKey(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteAppKeyResponse(rsp)
}

// TigrisRotateAppKeySecretWithBodyWithResponse request with arbitrary body returning *TigrisRotateAppKeySecretResponse
func (c *ClientWithResponses) TigrisRotateAppKeySecretWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisRotateAppKeySecretResponse, error) {
	rsp, err := c.TigrisRotateAppKeySecretWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisRotateAppKeySecretResponse(rsp)
}

func (c *ClientWithResponses) TigrisRotateAppKeySecretWithResponse(ctx context.Context, project string, body TigrisRotateAppKeySecretJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisRotateAppKeySecretResponse, error) {
	rsp, err := c.TigrisRotateAppKeySecret(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisRotateAppKeySecretResponse(rsp)
}

// TigrisUpdateAppKeyWithBodyWithResponse request with arbitrary body returning *TigrisUpdateAppKeyResponse
func (c *ClientWithResponses) TigrisUpdateAppKeyWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisUpdateAppKeyResponse, error) {
	rsp, err := c.TigrisUpdateAppKeyWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisUpdateAppKeyResponse(rsp)
}

func (c *ClientWithResponses) TigrisUpdateAppKeyWithResponse(ctx context.Context, project string, body TigrisUpdateAppKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisUpdateAppKeyResponse, error) {
	rsp, err := c.TigrisUpdateAppKey(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisUpdateAppKeyResponse(rsp)
}

// CacheListCachesWithResponse request returning *CacheListCachesResponse
func (c *ClientWithResponses) CacheListCachesWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*CacheListCachesResponse, error) {
	rsp, err := c.CacheListCaches(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheListCachesResponse(rsp)
}

// CacheCreateCacheWithBodyWithResponse request with arbitrary body returning *CacheCreateCacheResponse
func (c *ClientWithResponses) CacheCreateCacheWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheCreateCacheResponse, error) {
	rsp, err := c.CacheCreateCacheWithBody(ctx, project, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheCreateCacheResponse(rsp)
}

func (c *ClientWithResponses) CacheCreateCacheWithResponse(ctx context.Context, project string, name string, body CacheCreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheCreateCacheResponse, error) {
	rsp, err := c.CacheCreateCache(ctx, project, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheCreateCacheResponse(rsp)
}

// CacheDeleteCacheWithBodyWithResponse request with arbitrary body returning *CacheDeleteCacheResponse
func (c *ClientWithResponses) CacheDeleteCacheWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheDeleteCacheResponse, error) {
	rsp, err := c.CacheDeleteCacheWithBody(ctx, project, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheDeleteCacheResponse(rsp)
}

func (c *ClientWithResponses) CacheDeleteCacheWithResponse(ctx context.Context, project string, name string, body CacheDeleteCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheDeleteCacheResponse, error) {
	rsp, err := c.CacheDeleteCache(ctx, project, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheDeleteCacheResponse(rsp)
}

// CacheKeysWithResponse request returning *CacheKeysResponse
func (c *ClientWithResponses) CacheKeysWithResponse(ctx context.Context, project string, name string, params *CacheKeysParams, reqEditors ...RequestEditorFn) (*CacheKeysResponse, error) {
	rsp, err := c.CacheKeys(ctx, project, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheKeysResponse(rsp)
}

// CacheDelWithBodyWithResponse request with arbitrary body returning *CacheDelResponse
func (c *ClientWithResponses) CacheDelWithBodyWithResponse(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheDelResponse, error) {
	rsp, err := c.CacheDelWithBody(ctx, project, name, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheDelResponse(rsp)
}

func (c *ClientWithResponses) CacheDelWithResponse(ctx context.Context, project string, name string, key string, body CacheDelJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheDelResponse, error) {
	rsp, err := c.CacheDel(ctx, project, name, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheDelResponse(rsp)
}

// CacheGetWithResponse request returning *CacheGetResponse
func (c *ClientWithResponses) CacheGetWithResponse(ctx context.Context, project string, name string, key string, reqEditors ...RequestEditorFn) (*CacheGetResponse, error) {
	rsp, err := c.CacheGet(ctx, project, name, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheGetResponse(rsp)
}

// CacheGetSetWithBodyWithResponse request with arbitrary body returning *CacheGetSetResponse
func (c *ClientWithResponses) CacheGetSetWithBodyWithResponse(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheGetSetResponse, error) {
	rsp, err := c.CacheGetSetWithBody(ctx, project, name, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheGetSetResponse(rsp)
}

func (c *ClientWithResponses) CacheGetSetWithResponse(ctx context.Context, project string, name string, key string, body CacheGetSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheGetSetResponse, error) {
	rsp, err := c.CacheGetSet(ctx, project, name, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheGetSetResponse(rsp)
}

// CacheSetWithBodyWithResponse request with arbitrary body returning *CacheSetResponse
func (c *ClientWithResponses) CacheSetWithBodyWithResponse(ctx context.Context, project string, name string, key string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CacheSetResponse, error) {
	rsp, err := c.CacheSetWithBody(ctx, project, name, key, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheSetResponse(rsp)
}

func (c *ClientWithResponses) CacheSetWithResponse(ctx context.Context, project string, name string, key string, body CacheSetJSONRequestBody, reqEditors ...RequestEditorFn) (*CacheSetResponse, error) {
	rsp, err := c.CacheSet(ctx, project, name, key, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCacheSetResponse(rsp)
}

// TigrisCreateProjectWithBodyWithResponse request with arbitrary body returning *TigrisCreateProjectResponse
func (c *ClientWithResponses) TigrisCreateProjectWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateProjectResponse, error) {
	rsp, err := c.TigrisCreateProjectWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateProjectResponse(rsp)
}

func (c *ClientWithResponses) TigrisCreateProjectWithResponse(ctx context.Context, project string, body TigrisCreateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateProjectResponse, error) {
	rsp, err := c.TigrisCreateProject(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateProjectResponse(rsp)
}

// TigrisListBranchesWithResponse request returning *TigrisListBranchesResponse
func (c *ClientWithResponses) TigrisListBranchesWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*TigrisListBranchesResponse, error) {
	rsp, err := c.TigrisListBranches(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisListBranchesResponse(rsp)
}

// TigrisCreateBranchWithBodyWithResponse request with arbitrary body returning *TigrisCreateBranchResponse
func (c *ClientWithResponses) TigrisCreateBranchWithBodyWithResponse(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateBranchResponse, error) {
	rsp, err := c.TigrisCreateBranchWithBody(ctx, project, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateBranchResponse(rsp)
}

func (c *ClientWithResponses) TigrisCreateBranchWithResponse(ctx context.Context, project string, branch string, body TigrisCreateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateBranchResponse, error) {
	rsp, err := c.TigrisCreateBranch(ctx, project, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateBranchResponse(rsp)
}

// TigrisDeleteBranchWithBodyWithResponse request with arbitrary body returning *TigrisDeleteBranchResponse
func (c *ClientWithResponses) TigrisDeleteBranchWithBodyWithResponse(ctx context.Context, project string, branch string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteBranchResponse, error) {
	rsp, err := c.TigrisDeleteBranchWithBody(ctx, project, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteBranchResponse(rsp)
}

func (c *ClientWithResponses) TigrisDeleteBranchWithResponse(ctx context.Context, project string, branch string, body TigrisDeleteBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteBranchResponse, error) {
	rsp, err := c.TigrisDeleteBranch(ctx, project, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteBranchResponse(rsp)
}

// TigrisListCollectionsWithResponse request returning *TigrisListCollectionsResponse
func (c *ClientWithResponses) TigrisListCollectionsWithResponse(ctx context.Context, project string, params *TigrisListCollectionsParams, reqEditors ...RequestEditorFn) (*TigrisListCollectionsResponse, error) {
	rsp, err := c.TigrisListCollections(ctx, project, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisListCollectionsResponse(rsp)
}

// TigrisCreateOrUpdateCollectionWithBodyWithResponse request with arbitrary body returning *TigrisCreateOrUpdateCollectionResponse
func (c *ClientWithResponses) TigrisCreateOrUpdateCollectionWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error) {
	rsp, err := c.TigrisCreateOrUpdateCollectionWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateOrUpdateCollectionResponse(rsp)
}

func (c *ClientWithResponses) TigrisCreateOrUpdateCollectionWithResponse(ctx context.Context, project string, collection string, body TigrisCreateOrUpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCreateOrUpdateCollectionResponse, error) {
	rsp, err := c.TigrisCreateOrUpdateCollection(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCreateOrUpdateCollectionResponse(rsp)
}

// TigrisDescribeCollectionWithBodyWithResponse request with arbitrary body returning *TigrisDescribeCollectionResponse
func (c *ClientWithResponses) TigrisDescribeCollectionWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error) {
	rsp, err := c.TigrisDescribeCollectionWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeCollectionResponse(rsp)
}

func (c *ClientWithResponses) TigrisDescribeCollectionWithResponse(ctx context.Context, project string, collection string, body TigrisDescribeCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeCollectionResponse, error) {
	rsp, err := c.TigrisDescribeCollection(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeCollectionResponse(rsp)
}

// TigrisDeleteWithBodyWithResponse request with arbitrary body returning *TigrisDeleteResponse
func (c *ClientWithResponses) TigrisDeleteWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error) {
	rsp, err := c.TigrisDeleteWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteResponse(rsp)
}

func (c *ClientWithResponses) TigrisDeleteWithResponse(ctx context.Context, project string, collection string, body TigrisDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteResponse, error) {
	rsp, err := c.TigrisDelete(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteResponse(rsp)
}

// TigrisImportWithBodyWithResponse request with arbitrary body returning *TigrisImportResponse
func (c *ClientWithResponses) TigrisImportWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisImportResponse, error) {
	rsp, err := c.TigrisImportWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisImportResponse(rsp)
}

func (c *ClientWithResponses) TigrisImportWithResponse(ctx context.Context, project string, collection string, body TigrisImportJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisImportResponse, error) {
	rsp, err := c.TigrisImport(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisImportResponse(rsp)
}

// TigrisInsertWithBodyWithResponse request with arbitrary body returning *TigrisInsertResponse
func (c *ClientWithResponses) TigrisInsertWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error) {
	rsp, err := c.TigrisInsertWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisInsertResponse(rsp)
}

func (c *ClientWithResponses) TigrisInsertWithResponse(ctx context.Context, project string, collection string, body TigrisInsertJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisInsertResponse, error) {
	rsp, err := c.TigrisInsert(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisInsertResponse(rsp)
}

// TigrisReadWithBodyWithResponse request with arbitrary body returning *TigrisReadResponse
func (c *ClientWithResponses) TigrisReadWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error) {
	rsp, err := c.TigrisReadWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReadResponse(rsp)
}

func (c *ClientWithResponses) TigrisReadWithResponse(ctx context.Context, project string, collection string, body TigrisReadJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReadResponse, error) {
	rsp, err := c.TigrisRead(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReadResponse(rsp)
}

// TigrisReplaceWithBodyWithResponse request with arbitrary body returning *TigrisReplaceResponse
func (c *ClientWithResponses) TigrisReplaceWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error) {
	rsp, err := c.TigrisReplaceWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReplaceResponse(rsp)
}

func (c *ClientWithResponses) TigrisReplaceWithResponse(ctx context.Context, project string, collection string, body TigrisReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisReplaceResponse, error) {
	rsp, err := c.TigrisReplace(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisReplaceResponse(rsp)
}

// TigrisSearchWithBodyWithResponse request with arbitrary body returning *TigrisSearchResponse
func (c *ClientWithResponses) TigrisSearchWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error) {
	rsp, err := c.TigrisSearchWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisSearchResponse(rsp)
}

func (c *ClientWithResponses) TigrisSearchWithResponse(ctx context.Context, project string, collection string, body TigrisSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisSearchResponse, error) {
	rsp, err := c.TigrisSearch(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisSearchResponse(rsp)
}

// TigrisUpdateWithBodyWithResponse request with arbitrary body returning *TigrisUpdateResponse
func (c *ClientWithResponses) TigrisUpdateWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error) {
	rsp, err := c.TigrisUpdateWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisUpdateResponse(rsp)
}

func (c *ClientWithResponses) TigrisUpdateWithResponse(ctx context.Context, project string, collection string, body TigrisUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisUpdateResponse, error) {
	rsp, err := c.TigrisUpdate(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisUpdateResponse(rsp)
}

// TigrisDropCollectionWithBodyWithResponse request with arbitrary body returning *TigrisDropCollectionResponse
func (c *ClientWithResponses) TigrisDropCollectionWithBodyWithResponse(ctx context.Context, project string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error) {
	rsp, err := c.TigrisDropCollectionWithBody(ctx, project, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDropCollectionResponse(rsp)
}

func (c *ClientWithResponses) TigrisDropCollectionWithResponse(ctx context.Context, project string, collection string, body TigrisDropCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDropCollectionResponse, error) {
	rsp, err := c.TigrisDropCollection(ctx, project, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDropCollectionResponse(rsp)
}

// TigrisDescribeDatabaseWithBodyWithResponse request with arbitrary body returning *TigrisDescribeDatabaseResponse
func (c *ClientWithResponses) TigrisDescribeDatabaseWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error) {
	rsp, err := c.TigrisDescribeDatabaseWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeDatabaseResponse(rsp)
}

func (c *ClientWithResponses) TigrisDescribeDatabaseWithResponse(ctx context.Context, project string, body TigrisDescribeDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDescribeDatabaseResponse, error) {
	rsp, err := c.TigrisDescribeDatabase(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDescribeDatabaseResponse(rsp)
}

// TigrisBeginTransactionWithBodyWithResponse request with arbitrary body returning *TigrisBeginTransactionResponse
func (c *ClientWithResponses) TigrisBeginTransactionWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error) {
	rsp, err := c.TigrisBeginTransactionWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisBeginTransactionResponse(rsp)
}

func (c *ClientWithResponses) TigrisBeginTransactionWithResponse(ctx context.Context, project string, body TigrisBeginTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisBeginTransactionResponse, error) {
	rsp, err := c.TigrisBeginTransaction(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisBeginTransactionResponse(rsp)
}

// TigrisCommitTransactionWithBodyWithResponse request with arbitrary body returning *TigrisCommitTransactionResponse
func (c *ClientWithResponses) TigrisCommitTransactionWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error) {
	rsp, err := c.TigrisCommitTransactionWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCommitTransactionResponse(rsp)
}

func (c *ClientWithResponses) TigrisCommitTransactionWithResponse(ctx context.Context, project string, body TigrisCommitTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisCommitTransactionResponse, error) {
	rsp, err := c.TigrisCommitTransaction(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisCommitTransactionResponse(rsp)
}

// TigrisRollbackTransactionWithBodyWithResponse request with arbitrary body returning *TigrisRollbackTransactionResponse
func (c *ClientWithResponses) TigrisRollbackTransactionWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error) {
	rsp, err := c.TigrisRollbackTransactionWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisRollbackTransactionResponse(rsp)
}

func (c *ClientWithResponses) TigrisRollbackTransactionWithResponse(ctx context.Context, project string, body TigrisRollbackTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisRollbackTransactionResponse, error) {
	rsp, err := c.TigrisRollbackTransaction(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisRollbackTransactionResponse(rsp)
}

// TigrisDeleteProjectWithBodyWithResponse request with arbitrary body returning *TigrisDeleteProjectResponse
func (c *ClientWithResponses) TigrisDeleteProjectWithBodyWithResponse(ctx context.Context, project string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TigrisDeleteProjectResponse, error) {
	rsp, err := c.TigrisDeleteProjectWithBody(ctx, project, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteProjectResponse(rsp)
}

func (c *ClientWithResponses) TigrisDeleteProjectWithResponse(ctx context.Context, project string, body TigrisDeleteProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*TigrisDeleteProjectResponse, error) {
	rsp, err := c.TigrisDeleteProject(ctx, project, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTigrisDeleteProjectResponse(rsp)
}

// RealtimeGetRTChannelsWithResponse request returning *RealtimeGetRTChannelsResponse
func (c *ClientWithResponses) RealtimeGetRTChannelsWithResponse(ctx context.Context, project string, reqEditors ...RequestEditorFn) (*RealtimeGetRTChannelsResponse, error) {
	rsp, err := c.RealtimeGetRTChannels(ctx, project, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRealtimeGetRTChannelsResponse(rsp)
}

// RealtimeGetRTChannelWithResponse request returning *RealtimeGetRTChannelResponse
func (c *ClientWithResponses) RealtimeGetRTChannelWithResponse(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*RealtimeGetRTChannelResponse, error) {
	rsp, err := c.RealtimeGetRTChannel(ctx, project, channel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRealtimeGetRTChannelResponse(rsp)
}

// RealtimeReadMessagesWithResponse request returning *RealtimeReadMessagesResponse
func (c *ClientWithResponses) RealtimeReadMessagesWithResponse(ctx context.Context, project string, channel string, params *RealtimeReadMessagesParams, reqEditors ...RequestEditorFn) (*RealtimeReadMessagesResponse, error) {
	rsp, err := c.RealtimeReadMessages(ctx, project, channel, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRealtimeReadMessagesResponse(rsp)
}

// RealtimeMessagesWithBodyWithResponse request with arbitrary body returning *RealtimeMessagesResponse
func (c *ClientWithResponses) RealtimeMessagesWithBodyWithResponse(ctx context.Context, project string, channel string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RealtimeMessagesResponse, error) {
	rsp, err := c.RealtimeMessagesWithBody(ctx, project, channel, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRealtimeMessagesResponse(rsp)
}

func (c *ClientWithResponses) RealtimeMessagesWithResponse(ctx context.Context, project string, channel string, body RealtimeMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*RealtimeMessagesResponse, error) {
	rsp, err := c.RealtimeMessages(ctx, project, channel, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRealtimeMessagesResponse(rsp)
}

// RealtimePresenceWithResponse request returning *RealtimePresenceResponse
func (c *ClientWithResponses) RealtimePresenceWithResponse(ctx context.Context, project string, channel string, reqEditors ...RequestEditorFn) (*RealtimePresenceResponse, error) {
	rsp, err := c.RealtimePresence(ctx, project, channel, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRealtimePresenceResponse(rsp)
}

// RealtimeListSubscriptionsWithResponse request returning *RealtimeListSubscriptionsResponse
func (c *ClientWithResponses) RealtimeListSubscriptionsWithResponse(ctx context.Context, project string, channel string, params *RealtimeListSubscriptionsParams, reqEditors ...RequestEditorFn) (*RealtimeListSubscriptionsResponse, error) {
	rsp, err := c.RealtimeListSubscriptions(ctx, project, channel, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRealtimeListSubscriptionsResponse(rsp)
}

// SearchListIndexesWithResponse request returning *SearchListIndexesResponse
func (c *ClientWithResponses) SearchListIndexesWithResponse(ctx context.Context, project string, params *SearchListIndexesParams, reqEditors ...RequestEditorFn) (*SearchListIndexesResponse, error) {
	rsp, err := c.SearchListIndexes(ctx, project, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchListIndexesResponse(rsp)
}

// SearchDeleteWithBodyWithResponse request with arbitrary body returning *SearchDeleteResponse
func (c *ClientWithResponses) SearchDeleteWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeleteResponse, error) {
	rsp, err := c.SearchDeleteWithBody(ctx, project, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeleteResponse(rsp)
}

func (c *ClientWithResponses) SearchDeleteWithResponse(ctx context.Context, project string, index string, body SearchDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDeleteResponse, error) {
	rsp, err := c.SearchDelete(ctx, project, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeleteResponse(rsp)
}

// SearchGetWithResponse request returning *SearchGetResponse
func (c *ClientWithResponses) SearchGetWithResponse(ctx context.Context, project string, index string, params *SearchGetParams, reqEditors ...RequestEditorFn) (*SearchGetResponse, error) {
	rsp, err := c.SearchGet(ctx, project, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGetResponse(rsp)
}

// SearchUpdateWithBodyWithResponse request with arbitrary body returning *SearchUpdateResponse
func (c *ClientWithResponses) SearchUpdateWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchUpdateResponse, error) {
	rsp, err := c.SearchUpdateWithBody(ctx, project, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUpdateResponse(rsp)
}

func (c *ClientWithResponses) SearchUpdateWithResponse(ctx context.Context, project string, index string, body SearchUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchUpdateResponse, error) {
	rsp, err := c.SearchUpdate(ctx, project, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchUpdateResponse(rsp)
}

// SearchCreateWithBodyWithResponse request with arbitrary body returning *SearchCreateResponse
func (c *ClientWithResponses) SearchCreateWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateResponse, error) {
	rsp, err := c.SearchCreateWithBody(ctx, project, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateResponse(rsp)
}

func (c *ClientWithResponses) SearchCreateWithResponse(ctx context.Context, project string, index string, body SearchCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateResponse, error) {
	rsp, err := c.SearchCreate(ctx, project, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateResponse(rsp)
}

// SearchCreateOrReplaceWithBodyWithResponse request with arbitrary body returning *SearchCreateOrReplaceResponse
func (c *ClientWithResponses) SearchCreateOrReplaceWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateOrReplaceResponse, error) {
	rsp, err := c.SearchCreateOrReplaceWithBody(ctx, project, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateOrReplaceResponse(rsp)
}

func (c *ClientWithResponses) SearchCreateOrReplaceWithResponse(ctx context.Context, project string, index string, body SearchCreateOrReplaceJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateOrReplaceResponse, error) {
	rsp, err := c.SearchCreateOrReplace(ctx, project, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateOrReplaceResponse(rsp)
}

// SearchDeleteByQueryWithBodyWithResponse request with arbitrary body returning *SearchDeleteByQueryResponse
func (c *ClientWithResponses) SearchDeleteByQueryWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeleteByQueryResponse, error) {
	rsp, err := c.SearchDeleteByQueryWithBody(ctx, project, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeleteByQueryResponse(rsp)
}

func (c *ClientWithResponses) SearchDeleteByQueryWithResponse(ctx context.Context, project string, index string, body SearchDeleteByQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDeleteByQueryResponse, error) {
	rsp, err := c.SearchDeleteByQuery(ctx, project, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeleteByQueryResponse(rsp)
}

// SearchSearchWithBodyWithResponse request with arbitrary body returning *SearchSearchResponse
func (c *ClientWithResponses) SearchSearchWithBodyWithResponse(ctx context.Context, project string, index string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchSearchResponse, error) {
	rsp, err := c.SearchSearchWithBody(ctx, project, index, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchSearchResponse(rsp)
}

func (c *ClientWithResponses) SearchSearchWithResponse(ctx context.Context, project string, index string, body SearchSearchJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchSearchResponse, error) {
	rsp, err := c.SearchSearch(ctx, project, index, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchSearchResponse(rsp)
}

// SearchCreateByIdWithBodyWithResponse request with arbitrary body returning *SearchCreateByIdResponse
func (c *ClientWithResponses) SearchCreateByIdWithBodyWithResponse(ctx context.Context, project string, index string, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateByIdResponse, error) {
	rsp, err := c.SearchCreateByIdWithBody(ctx, project, index, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateByIdResponse(rsp)
}

func (c *ClientWithResponses) SearchCreateByIdWithResponse(ctx context.Context, project string, index string, id string, body SearchCreateByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateByIdResponse, error) {
	rsp, err := c.SearchCreateById(ctx, project, index, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateByIdResponse(rsp)
}

// SearchDeleteIndexWithBodyWithResponse request with arbitrary body returning *SearchDeleteIndexResponse
func (c *ClientWithResponses) SearchDeleteIndexWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDeleteIndexResponse, error) {
	rsp, err := c.SearchDeleteIndexWithBody(ctx, project, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeleteIndexResponse(rsp)
}

func (c *ClientWithResponses) SearchDeleteIndexWithResponse(ctx context.Context, project string, name string, body SearchDeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDeleteIndexResponse, error) {
	rsp, err := c.SearchDeleteIndex(ctx, project, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDeleteIndexResponse(rsp)
}

// SearchGetIndexWithResponse request returning *SearchGetIndexResponse
func (c *ClientWithResponses) SearchGetIndexWithResponse(ctx context.Context, project string, name string, reqEditors ...RequestEditorFn) (*SearchGetIndexResponse, error) {
	rsp, err := c.SearchGetIndex(ctx, project, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchGetIndexResponse(rsp)
}

// SearchCreateOrUpdateIndexWithBodyWithResponse request with arbitrary body returning *SearchCreateOrUpdateIndexResponse
func (c *ClientWithResponses) SearchCreateOrUpdateIndexWithBodyWithResponse(ctx context.Context, project string, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchCreateOrUpdateIndexResponse, error) {
	rsp, err := c.SearchCreateOrUpdateIndexWithBody(ctx, project, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateOrUpdateIndexResponse(rsp)
}

func (c *ClientWithResponses) SearchCreateOrUpdateIndexWithResponse(ctx context.Context, project string, name string, body SearchCreateOrUpdateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchCreateOrUpdateIndexResponse, error) {
	rsp, err := c.SearchCreateOrUpdateIndex(ctx, project, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchCreateOrUpdateIndexResponse(rsp)
}

// ParseAuthGetAccessTokenResponse parses an HTTP response from a AuthGetAccessTokenWithResponse call
func ParseAuthGetAccessTokenResponse(rsp *http.Response) (*AuthGetAccessTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthGetAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccessTokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseHealthAPIHealthResponse parses an HTTP response from a HealthAPIHealthWithResponse call
func ParseHealthAPIHealthResponse(rsp *http.Response) (*HealthAPIHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthAPIHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HealthCheckResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementGetNamespaceMetadataResponse parses an HTTP response from a ManagementGetNamespaceMetadataWithResponse call
func ParseManagementGetNamespaceMetadataResponse(rsp *http.Response) (*ManagementGetNamespaceMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementGetNamespaceMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNamespaceMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementInsertNamespaceMetadataResponse parses an HTTP response from a ManagementInsertNamespaceMetadataWithResponse call
func ParseManagementInsertNamespaceMetadataResponse(rsp *http.Response) (*ManagementInsertNamespaceMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementInsertNamespaceMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsertNamespaceMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementUpdateNamespaceMetadataResponse parses an HTTP response from a ManagementUpdateNamespaceMetadataWithResponse call
func ParseManagementUpdateNamespaceMetadataResponse(rsp *http.Response) (*ManagementUpdateNamespaceMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementUpdateNamespaceMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateNamespaceMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementCreateNamespaceResponse parses an HTTP response from a ManagementCreateNamespaceWithResponse call
func ParseManagementCreateNamespaceResponse(rsp *http.Response) (*ManagementCreateNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementCreateNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateNamespaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementDescribeNamespacesResponse parses an HTTP response from a ManagementDescribeNamespacesWithResponse call
func ParseManagementDescribeNamespacesResponse(rsp *http.Response) (*ManagementDescribeNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementDescribeNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeNamespacesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementListNamespacesResponse parses an HTTP response from a ManagementListNamespacesWithResponse call
func ParseManagementListNamespacesResponse(rsp *http.Response) (*ManagementListNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementListNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListNamespacesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementGetUserMetadataResponse parses an HTTP response from a ManagementGetUserMetadataWithResponse call
func ParseManagementGetUserMetadataResponse(rsp *http.Response) (*ManagementGetUserMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementGetUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementInsertUserMetadataResponse parses an HTTP response from a ManagementInsertUserMetadataWithResponse call
func ParseManagementInsertUserMetadataResponse(rsp *http.Response) (*ManagementInsertUserMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementInsertUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsertUserMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseManagementUpdateUserMetadataResponse parses an HTTP response from a ManagementUpdateUserMetadataWithResponse call
func ParseManagementUpdateUserMetadataResponse(rsp *http.Response) (*ManagementUpdateUserMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ManagementUpdateUserMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserMetadataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObservabilityGetInfoResponse parses an HTTP response from a ObservabilityGetInfoWithResponse call
func ParseObservabilityGetInfoResponse(rsp *http.Response) (*ObservabilityGetInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservabilityGetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInfoResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObservabilityQueryTimeSeriesMetricsResponse parses an HTTP response from a ObservabilityQueryTimeSeriesMetricsWithResponse call
func ParseObservabilityQueryTimeSeriesMetricsResponse(rsp *http.Response) (*ObservabilityQueryTimeSeriesMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservabilityQueryTimeSeriesMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryTimeSeriesMetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObservabilityQuotaLimitsResponse parses an HTTP response from a ObservabilityQuotaLimitsWithResponse call
func ParseObservabilityQuotaLimitsResponse(rsp *http.Response) (*ObservabilityQuotaLimitsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservabilityQuotaLimitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuotaLimitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseObservabilityQuotaUsageResponse parses an HTTP response from a ObservabilityQuotaUsageWithResponse call
func ParseObservabilityQuotaUsageResponse(rsp *http.Response) (*ObservabilityQuotaUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ObservabilityQuotaUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QuotaUsageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisListProjectsResponse parses an HTTP response from a TigrisListProjectsWithResponse call
func ParseTigrisListProjectsResponse(rsp *http.Response) (*TigrisListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListProjectsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisListAppKeysResponse parses an HTTP response from a TigrisListAppKeysWithResponse call
func ParseTigrisListAppKeysResponse(rsp *http.Response) (*TigrisListAppKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisListAppKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAppKeysResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCreateAppKeyResponse parses an HTTP response from a TigrisCreateAppKeyWithResponse call
func ParseTigrisCreateAppKeyResponse(rsp *http.Response) (*TigrisCreateAppKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCreateAppKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateAppKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDeleteAppKeyResponse parses an HTTP response from a TigrisDeleteAppKeyWithResponse call
func ParseTigrisDeleteAppKeyResponse(rsp *http.Response) (*TigrisDeleteAppKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDeleteAppKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteAppKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisRotateAppKeySecretResponse parses an HTTP response from a TigrisRotateAppKeySecretWithResponse call
func ParseTigrisRotateAppKeySecretResponse(rsp *http.Response) (*TigrisRotateAppKeySecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisRotateAppKeySecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RotateAppKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisUpdateAppKeyResponse parses an HTTP response from a TigrisUpdateAppKeyWithResponse call
func ParseTigrisUpdateAppKeyResponse(rsp *http.Response) (*TigrisUpdateAppKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisUpdateAppKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateAppKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheListCachesResponse parses an HTTP response from a CacheListCachesWithResponse call
func ParseCacheListCachesResponse(rsp *http.Response) (*CacheListCachesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheListCachesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCachesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheCreateCacheResponse parses an HTTP response from a CacheCreateCacheWithResponse call
func ParseCacheCreateCacheResponse(rsp *http.Response) (*CacheCreateCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheCreateCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateCacheResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheDeleteCacheResponse parses an HTTP response from a CacheDeleteCacheWithResponse call
func ParseCacheDeleteCacheResponse(rsp *http.Response) (*CacheDeleteCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheDeleteCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteCacheResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheKeysResponse parses an HTTP response from a CacheKeysWithResponse call
func ParseCacheKeysResponse(rsp *http.Response) (*CacheKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeysResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheDelResponse parses an HTTP response from a CacheDelWithResponse call
func ParseCacheDelResponse(rsp *http.Response) (*CacheDelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheDelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheGetResponse parses an HTTP response from a CacheGetWithResponse call
func ParseCacheGetResponse(rsp *http.Response) (*CacheGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheGetSetResponse parses an HTTP response from a CacheGetSetWithResponse call
func ParseCacheGetSetResponse(rsp *http.Response) (*CacheGetSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheGetSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCacheSetResponse parses an HTTP response from a CacheSetWithResponse call
func ParseCacheSetResponse(rsp *http.Response) (*CacheSetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CacheSetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCreateProjectResponse parses an HTTP response from a TigrisCreateProjectWithResponse call
func ParseTigrisCreateProjectResponse(rsp *http.Response) (*TigrisCreateProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCreateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisListBranchesResponse parses an HTTP response from a TigrisListBranchesWithResponse call
func ParseTigrisListBranchesResponse(rsp *http.Response) (*TigrisListBranchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisListBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBranchesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCreateBranchResponse parses an HTTP response from a TigrisCreateBranchWithResponse call
func ParseTigrisCreateBranchResponse(rsp *http.Response) (*TigrisCreateBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCreateBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateBranchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDeleteBranchResponse parses an HTTP response from a TigrisDeleteBranchWithResponse call
func ParseTigrisDeleteBranchResponse(rsp *http.Response) (*TigrisDeleteBranchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDeleteBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteBranchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisListCollectionsResponse parses an HTTP response from a TigrisListCollectionsWithResponse call
func ParseTigrisListCollectionsResponse(rsp *http.Response) (*TigrisListCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisListCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCollectionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCreateOrUpdateCollectionResponse parses an HTTP response from a TigrisCreateOrUpdateCollectionWithResponse call
func ParseTigrisCreateOrUpdateCollectionResponse(rsp *http.Response) (*TigrisCreateOrUpdateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCreateOrUpdateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateOrUpdateCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDescribeCollectionResponse parses an HTTP response from a TigrisDescribeCollectionWithResponse call
func ParseTigrisDescribeCollectionResponse(rsp *http.Response) (*TigrisDescribeCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDescribeCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDeleteResponse parses an HTTP response from a TigrisDeleteWithResponse call
func ParseTigrisDeleteResponse(rsp *http.Response) (*TigrisDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisImportResponse parses an HTTP response from a TigrisImportWithResponse call
func ParseTigrisImportResponse(rsp *http.Response) (*TigrisImportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ImportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisInsertResponse parses an HTTP response from a TigrisInsertWithResponse call
func ParseTigrisInsertResponse(rsp *http.Response) (*TigrisInsertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisInsertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InsertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisReadResponse parses an HTTP response from a TigrisReadWithResponse call
func ParseTigrisReadResponse(rsp *http.Response) (*TigrisReadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamingReadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisReplaceResponse parses an HTTP response from a TigrisReplaceWithResponse call
func ParseTigrisReplaceResponse(rsp *http.Response) (*TigrisReplaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisReplaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReplaceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisSearchResponse parses an HTTP response from a TigrisSearchWithResponse call
func ParseTigrisSearchResponse(rsp *http.Response) (*TigrisSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StreamingSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisUpdateResponse parses an HTTP response from a TigrisUpdateWithResponse call
func ParseTigrisUpdateResponse(rsp *http.Response) (*TigrisUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDropCollectionResponse parses an HTTP response from a TigrisDropCollectionWithResponse call
func ParseTigrisDropCollectionResponse(rsp *http.Response) (*TigrisDropCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDropCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DropCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDescribeDatabaseResponse parses an HTTP response from a TigrisDescribeDatabaseWithResponse call
func ParseTigrisDescribeDatabaseResponse(rsp *http.Response) (*TigrisDescribeDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDescribeDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DescribeDatabaseResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisBeginTransactionResponse parses an HTTP response from a TigrisBeginTransactionWithResponse call
func ParseTigrisBeginTransactionResponse(rsp *http.Response) (*TigrisBeginTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisBeginTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BeginTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisCommitTransactionResponse parses an HTTP response from a TigrisCommitTransactionWithResponse call
func ParseTigrisCommitTransactionResponse(rsp *http.Response) (*TigrisCommitTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisCommitTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisRollbackTransactionResponse parses an HTTP response from a TigrisRollbackTransactionWithResponse call
func ParseTigrisRollbackTransactionResponse(rsp *http.Response) (*TigrisRollbackTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisRollbackTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RollbackTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseTigrisDeleteProjectResponse parses an HTTP response from a TigrisDeleteProjectWithResponse call
func ParseTigrisDeleteProjectResponse(rsp *http.Response) (*TigrisDeleteProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TigrisDeleteProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteProjectResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRealtimeGetRTChannelsResponse parses an HTTP response from a RealtimeGetRTChannelsWithResponse call
func ParseRealtimeGetRTChannelsResponse(rsp *http.Response) (*RealtimeGetRTChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RealtimeGetRTChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRTChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRealtimeGetRTChannelResponse parses an HTTP response from a RealtimeGetRTChannelWithResponse call
func ParseRealtimeGetRTChannelResponse(rsp *http.Response) (*RealtimeGetRTChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RealtimeGetRTChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRTChannelResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRealtimeReadMessagesResponse parses an HTTP response from a RealtimeReadMessagesWithResponse call
func ParseRealtimeReadMessagesResponse(rsp *http.Response) (*RealtimeReadMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RealtimeReadMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReadMessagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRealtimeMessagesResponse parses an HTTP response from a RealtimeMessagesWithResponse call
func ParseRealtimeMessagesResponse(rsp *http.Response) (*RealtimeMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RealtimeMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MessagesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRealtimePresenceResponse parses an HTTP response from a RealtimePresenceWithResponse call
func ParseRealtimePresenceResponse(rsp *http.Response) (*RealtimePresenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RealtimePresenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PresenceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRealtimeListSubscriptionsResponse parses an HTTP response from a RealtimeListSubscriptionsWithResponse call
func ParseRealtimeListSubscriptionsResponse(rsp *http.Response) (*RealtimeListSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RealtimeListSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchListIndexesResponse parses an HTTP response from a SearchListIndexesWithResponse call
func ParseSearchListIndexesResponse(rsp *http.Response) (*SearchListIndexesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchListIndexesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIndexesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchDeleteResponse parses an HTTP response from a SearchDeleteWithResponse call
func ParseSearchDeleteResponse(rsp *http.Response) (*SearchDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchGetResponse parses an HTTP response from a SearchGetWithResponse call
func ParseSearchGetResponse(rsp *http.Response) (*SearchGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchUpdateResponse parses an HTTP response from a SearchUpdateWithResponse call
func ParseSearchUpdateResponse(rsp *http.Response) (*SearchUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchCreateResponse parses an HTTP response from a SearchCreateWithResponse call
func ParseSearchCreateResponse(rsp *http.Response) (*SearchCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchCreateOrReplaceResponse parses an HTTP response from a SearchCreateOrReplaceWithResponse call
func ParseSearchCreateOrReplaceResponse(rsp *http.Response) (*SearchCreateOrReplaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCreateOrReplaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateOrReplaceDocumentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchDeleteByQueryResponse parses an HTTP response from a SearchDeleteByQueryWithResponse call
func ParseSearchDeleteByQueryResponse(rsp *http.Response) (*SearchDeleteByQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDeleteByQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteByQueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchSearchResponse parses an HTTP response from a SearchSearchWithResponse call
func ParseSearchSearchResponse(rsp *http.Response) (*SearchSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchIndexResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchCreateByIdResponse parses an HTTP response from a SearchCreateByIdWithResponse call
func ParseSearchCreateByIdResponse(rsp *http.Response) (*SearchCreateByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCreateByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateByIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchDeleteIndexResponse parses an HTTP response from a SearchDeleteIndexWithResponse call
func ParseSearchDeleteIndexResponse(rsp *http.Response) (*SearchDeleteIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteIndexResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchGetIndexResponse parses an HTTP response from a SearchGetIndexWithResponse call
func ParseSearchGetIndexResponse(rsp *http.Response) (*SearchGetIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchGetIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIndexResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchCreateOrUpdateIndexResponse parses an HTTP response from a SearchCreateOrUpdateIndexWithResponse call
func ParseSearchCreateOrUpdateIndexResponse(rsp *http.Response) (*SearchCreateOrUpdateIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchCreateOrUpdateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateOrUpdateIndexResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
